import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __require
} from "./chunk-BJNOTN5A.js";

// browser-external:worker_threads
var require_worker_threads = __commonJS({
  "browser-external:worker_threads"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "worker_threads" has been externalized for browser compatibility. Cannot access "worker_threads.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/iink-ts/dist/iink.esm.js
var i;
var r;
var s;
var n;
!function(i2) {
  i2.Write = "write", i2.Erase = "erase", i2.Select = "select", i2.Move = "move";
}(i || (i = {})), function(i2) {
  i2.Pencil = "pencil", i2.Rectangle = "rectangle", i2.Rhombus = "rhombus", i2.Circle = "circle", i2.Ellipse = "ellipse", i2.Triangle = "triangle", i2.Parallelogram = "parallelogram", i2.Line = "line", i2.Arrow = "arrow", i2.DoubleArrow = "double-arrow";
}(r || (r = {})), function(i2) {
  i2.Guide = "guide", i2.InteractElementsGroup = "interact-elements-group", i2.Translate = "translate", i2.Resize = "resize", i2.Rotate = "rotate";
}(s || (s = {})), function(i2) {
  i2.North = "n-resize", i2.East = "e-resize", i2.South = "s-resize", i2.West = "w-resize", i2.NorthEast = "ne-resize", i2.NorthWest = "nw-resize", i2.SouthEast = "se-resize", i2.SouthWest = "sw-resize";
}(n || (n = {}));
var a = 10;
var DeferredPromise = class {
  constructor() {
    __publicField(this, "promise");
    __publicField(this, "resolve");
    __publicField(this, "reject");
    __publicField(this, "isFullFilled");
    __publicField(this, "isPending");
    this.isFullFilled = false, this.isPending = true, this.promise = new Promise((i2, r2) => {
      this.reject = async (i3) => (this.isFullFilled = true, this.isPending = false, r2(i3)), this.resolve = async (r3) => (this.isFullFilled = true, this.isPending = false, i2(r3));
    });
  }
};
function isValidNumber(i2) {
  return null != i2 && (!isNaN(parseFloat(i2.toString())) && isFinite(+i2));
}
function isBetween(i2, r2, s2) {
  return i2 >= r2 && i2 <= s2;
}
function computeAverage(i2) {
  return i2.reduce((i3, r2) => i3 + r2, 0) / (i2.length || 1);
}
function computeDistance(i2, r2) {
  const s2 = Math.hypot(r2.y - i2.y, r2.x - i2.x);
  return isNaN(s2) ? 0 : s2;
}
function computeAngleAxeRadian(i2, r2) {
  return Math.atan2(r2.y - i2.y, r2.x - i2.x);
}
function createPointsOnSegment(i2, r2, s2 = 1) {
  const n2 = [], a2 = computeDistance(i2, r2);
  let l2 = s2;
  for (; l2 < a2; ) {
    const d2 = { x: i2.x + l2 * (r2.x - i2.x) / a2, y: i2.y + l2 * (r2.y - i2.y) / a2 };
    n2.push(d2), l2 += s2;
  }
  return n2;
}
function scalaire(i2, r2) {
  return i2.x * r2.x + i2.y * r2.y;
}
function computeNearestPointOnSegment(i2, r2) {
  const s2 = { x: i2.x - r2.p1.x, y: i2.y - r2.p1.y }, n2 = { x: r2.p2.x - r2.p1.x, y: r2.p2.y - r2.p1.y };
  if (0 === n2.x && 0 === n2.y) return r2.p1;
  const a2 = scalaire(s2, n2), l2 = scalaire(n2, n2), d2 = Math.min(1, Math.max(0, a2 / l2));
  return { x: r2.p1.x + n2.x * d2, y: r2.p1.y + n2.y * d2 };
}
function isPointInsideBox(i2, r2) {
  return isBetween(i2.x, r2.x, r2.x + r2.width) && isBetween(i2.y, r2.y, r2.y + r2.height);
}
function convertRadianToDegree(i2) {
  return +(i2 % (2 * Math.PI) / Math.PI * 180).toFixed(4);
}
function convertDegreeToRadian(i2) {
  return +(i2 % 360 / 180 * Math.PI).toFixed(4);
}
function computeRotatedPoint(i2, r2, s2) {
  const n2 = i2.x - r2.x, a2 = i2.y - r2.y, l2 = Math.cos(s2), d2 = Math.sin(s2);
  return { x: +(r2.x + l2 * n2 - d2 * a2).toFixed(3), y: +(r2.y + d2 * n2 + l2 * a2).toFixed(3) };
}
function computePointOnEllipse(i2, r2, s2, n2, a2) {
  const l2 = Math.cos(n2), d2 = Math.sin(n2), h2 = Math.abs(r2) * Math.cos(a2), c2 = Math.abs(s2) * Math.sin(a2);
  return { x: +(i2.x + l2 * h2 - d2 * c2).toFixed(3), y: +(i2.y + d2 * h2 + l2 * c2).toFixed(3) };
}
function computeDistanceBetweenPointAndSegment(i2, r2) {
  return computeDistance(i2, computeNearestPointOnSegment(i2, r2));
}
function findIntersectionBetween2Segment(i2, r2) {
  if (i2.p1.x === r2.p1.x && i2.p1.y === r2.p1.y) return i2.p1;
  if (i2.p1.x === r2.p2.x && i2.p1.y === r2.p2.y) return i2.p1;
  if (i2.p2.x === r2.p1.x && i2.p2.y === r2.p1.y) return i2.p2;
  if (i2.p2.x === r2.p2.x && i2.p2.y === r2.p2.y) return i2.p2;
  const s2 = i2.p2.x - i2.p1.x, n2 = i2.p2.y - i2.p1.y, a2 = r2.p2.x - r2.p1.x, l2 = r2.p2.y - r2.p1.y, d2 = i2.p1.x - r2.p1.x, h2 = i2.p1.y - r2.p1.y, c2 = a2 * h2 - l2 * d2, u2 = s2 * h2 - n2 * d2, p2 = l2 * s2 - a2 * n2;
  if (0 === c2 || 0 === u2 || 0 === p2) return;
  const g2 = c2 / p2, m2 = u2 / p2;
  return isBetween(g2, 0, 1) && isBetween(m2, 0, 1) ? { x: i2.p1.x + g2 * s2, y: i2.p1.y + g2 * n2 } : void 0;
}
function findIntersectBetweenSegmentAndCircle(i2, r2, s2) {
  const n2 = [], a2 = Math.pow(i2.p2.x - i2.p1.x, 2) + Math.pow(i2.p2.y - i2.p1.y, 2), l2 = 2 * ((i2.p2.x - i2.p1.x) * (i2.p1.x - r2.x) + (i2.p2.y - i2.p1.y) * (i2.p1.y - r2.y)), d2 = Math.pow(r2.x, 2) + Math.pow(r2.y, 2) + Math.pow(i2.p1.x, 2) + Math.pow(i2.p1.y, 2) - 2 * (r2.x * i2.p1.x + r2.y * i2.p1.y) - Math.pow(s2, 2), h2 = Math.pow(l2, 2) - 4 * a2 * d2;
  if (h2 <= 0) return [];
  const c2 = Math.sqrt(h2), u2 = (-l2 + c2) / (2 * a2), p2 = (-l2 - c2) / (2 * a2);
  return (u2 < 0 || u2 > 1) && (p2 < 0 || p2 > 1) || (isBetween(u2, 0, 1) && n2.push({ x: (i2.p2.x - i2.p1.x) * u2 + i2.p1.x, y: (i2.p2.y - i2.p1.y) * u2 + i2.p1.y }), isBetween(p2, 0, 1) && n2.push({ x: (i2.p2.x - i2.p1.x) * p2 + i2.p1.x, y: (i2.p2.y - i2.p1.y) * p2 + i2.p1.y })), n2;
}
function computeAngleRadian(i2, r2, s2) {
  const n2 = Math.sqrt(Math.pow(r2.x - i2.x, 2) + Math.pow(r2.y - i2.y, 2)), a2 = Math.sqrt(Math.pow(r2.x - s2.x, 2) + Math.pow(r2.y - s2.y, 2)), l2 = Math.sqrt(Math.pow(s2.x - i2.x, 2) + Math.pow(s2.y - i2.y, 2));
  return Math.acos((a2 * a2 + n2 * n2 - l2 * l2) / (2 * a2 * n2));
}
function getClosestPoints(i2, r2) {
  let s2 = i2[0], n2 = r2[0], a2 = Number.MAX_SAFE_INTEGER;
  return i2.forEach((i3) => {
    r2.forEach((r3) => {
      const l2 = computeDistance(i3, r3);
      a2 > l2 && (a2 = l2, s2 = i3, n2 = r3);
    });
  }), { p1: s2, p2: n2 };
}
function getClosestPoint(i2, r2) {
  let s2, n2 = Number.MAX_SAFE_INTEGER, a2 = -1;
  return i2.forEach((i3, l2) => {
    const d2 = computeDistance(i3, r2);
    n2 > d2 && (n2 = d2, s2 = i3, a2 = l2);
  }), { point: s2, index: a2 };
}
function isPointInsidePolygon(i2, r2) {
  let s2 = false;
  for (let n2 = 0, a2 = r2.length - 1; n2 < r2.length; a2 = n2++) {
    const l2 = r2[n2], d2 = r2[a2];
    l2.y > i2.y != d2.y > i2.y && i2.x < (d2.x - l2.x) * (i2.y - l2.y) / (d2.y - l2.y) + l2.x && (s2 = !s2);
  }
  return s2;
}
var isVersionSuperiorOrEqual = (i2, r2) => {
  const s2 = i2.split("."), n2 = r2.split(".");
  for (let i3 = 0; i3 < n2.length; i3++) {
    const r3 = Number(n2[i3]), a2 = Number(s2[i3]);
    if (r3 > a2) return false;
    if (r3 < a2) return true;
  }
  return true;
};
async function computeHmac(i2, r2, s2) {
  const n2 = new TextEncoder(), a2 = n2.encode(i2), l2 = n2.encode(r2 + s2), d2 = await crypto.subtle.importKey("raw", l2, { name: "HMAC", hash: { name: "SHA-512" } }, false, ["sign"]), h2 = await crypto.subtle.sign("HMAC", d2, a2), c2 = new Uint8Array(h2);
  return Array.prototype.map.call(c2, (i3) => i3.toString(16).padStart(2, "0")).join("");
}
function convertMillimeterToPixel(i2) {
  return +(96 * i2 / 25.4).toFixed(3);
}
function convertPixelToMillimeter(i2) {
  return +(i2 / 96 * 25.4).toFixed(3);
}
function convertBoundingBoxMillimeterToPixel(i2) {
  return i2 ? { x: convertMillimeterToPixel(i2.x), y: convertMillimeterToPixel(i2.y), width: convertMillimeterToPixel(i2.width), height: convertMillimeterToPixel(i2.height) } : { height: 0, width: 0, x: 0, y: 0 };
}
function createUUID() {
  let i2 = Date.now();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(r2) {
    const s2 = (i2 + 16 * Math.random()) % 16 | 0;
    return i2 = Math.floor(i2 / 16), ("x" == r2 ? s2 : 3 & s2 | 8).toString(16);
  });
}
var mergeDeep = (i2, ...r2) => {
  const isObject2 = (i3) => i3 && "object" == typeof i3 && !Array.isArray(i3);
  if (!r2.length) return i2;
  const s2 = r2.shift();
  if (isObject2(i2) && isObject2(s2)) for (const r3 in s2) isObject2(s2[r3]) ? (i2[r3] || Object.assign(i2, { [r3]: {} }), mergeDeep(i2[r3], s2[r3])) : Array.isArray(i2[r3]) && Array.isArray(s2[r3]) ? i2[r3] = i2[r3].concat(s2[r3]) : Object.assign(i2, { [r3]: s2[r3] });
  else Array.isArray(i2) && Array.isArray(s2) ? i2 = i2.concat(s2) : s2 && (i2 = s2);
  return mergeDeep(i2, ...r2);
};
var isDeepEqual = (i2, r2) => {
  const s2 = Object.keys(i2), n2 = Object.keys(r2);
  if (s2.length !== n2.length) return false;
  for (const n3 of s2) {
    const s3 = i2[n3], a2 = r2[n3], l2 = isObject(s3) && isObject(a2);
    if (l2 && !isDeepEqual(s3, a2) || !l2 && s3 !== a2) return false;
  }
  return true;
};
var isObject = (i2) => i2 && "object" == typeof i2;
async function getAvailableFontList(i2) {
  var _a, _b2, _c2;
  if (!((_a = i2 == null ? void 0 : i2.server) == null ? void 0 : _a.scheme) && !((_b2 = i2 == null ? void 0 : i2.server) == null ? void 0 : _b2.host)) return Promise.reject("Failed to get fonts: configuration.server.scheme & configuration.server.host are required!");
  if (!((_c2 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _c2.lang)) return Promise.reject("Failed to get fonts: configuration.recognition.lang is required!");
  const r2 = i2.server, s2 = await fetch(`${r2.scheme}://${r2.host}/api/v4.0/iink/font/google/language/` + i2.recognition.lang), { result: n2 } = await s2.json();
  return n2.sort();
}
async function getAvailableLanguageList(i2) {
  var _a, _b2;
  if (((_a = i2 == null ? void 0 : i2.server) == null ? void 0 : _a.scheme) && ((_b2 = i2 == null ? void 0 : i2.server) == null ? void 0 : _b2.host)) {
    const r2 = i2.server;
    return (await fetch(`${r2.scheme}://${r2.host}/api/v4.0/iink/availableLanguageList`)).json();
  }
  return Promise.reject("Failed to get languages: configuration.server.scheme & configuration.server.host are required!");
}
function computeLinksPointers(i2, r2, s2) {
  const n2 = i2.p * s2;
  return [{ x: +(i2.x - Math.sin(r2) * n2).toFixed(3), y: +(i2.y + Math.cos(r2) * n2).toFixed(3) }, { x: +(i2.x + Math.sin(r2) * n2).toFixed(3), y: +(i2.y - Math.cos(r2) * n2).toFixed(3) }];
}
function computeMiddlePointer(i2, r2) {
  return { x: +((r2.x + i2.x) / 2).toFixed(3), y: +((r2.y + i2.y) / 2).toFixed(3), p: +((r2.p + i2.p) / 2).toFixed(3), t: +((r2.t + i2.t) / 2).toFixed(3) };
}
async function getApiInfos(i2) {
  var _a, _b2;
  try {
    if (!((_a = i2 == null ? void 0 : i2.server) == null ? void 0 : _a.scheme) && !((_b2 = i2 == null ? void 0 : i2.server) == null ? void 0 : _b2.host)) return Promise.reject("Failed to get infos: configuration.server.scheme & configuration.server.host are required!");
    const r2 = await fetch(`${i2.server.scheme}://${i2.server.host}/api/v4.0/iink/version`);
    if (r2.ok) {
      return await r2.json();
    }
    return { version: "3.1.3", gitCommit: "unknown", nativeVersion: "<=3.1.1" };
  } catch {
    return { version: "3.1.3", gitCommit: "7e148bd566438ca77dc83cb4edcc6ed0f51a8a15", nativeVersion: "<=3.1.1" };
  }
}
var l;
var d;
!function(i2) {
  i2.DEBUG = "1", i2.INFO = "2", i2.WARN = "3", i2.ERROR = "4";
}(l || (l = {})), function(i2) {
  i2.EDITOR = "EDITOR", i2.RECOGNIZER = "RECOGNIZER", i2.GRABBER = "GRABBER", i2.GESTURE = "GESTURE", i2.EDITOR_EVENT = "EDITOR_EVENT", i2.MODEL = "MODEL", i2.RENDERER = "RENDERER", i2.SMARTGUIDE = "SMARTGUIDE", i2.STYLE = "STYLE", i2.HISTORY = "HISTORY", i2.SYMBOL = "SYMBOL", i2.WRITE = "WRITE", i2.TRANSFORMER = "TRANSFORMER", i2.CONVERTER = "CONVERTER", i2.SELECTION = "SELECTION", i2.SVGDEBUG = "SVGDEBUG", i2.MENU = "MENU";
}(d || (d = {}));
var Logger = class {
  constructor(i2, r2) {
    __publicField(this, "category");
    __publicField(this, "level");
    this.category = i2, this.level = r2;
  }
  debug(i2, ...r2) {
    if (l.DEBUG >= this.level) {
      const s2 = { level: "debug", from: `${this.category}.${i2}`, message: r2 };
      console.debug(s2);
    }
  }
  info(i2, ...r2) {
    if (l.INFO >= this.level) {
      const s2 = { level: "info", from: `${this.category}.${i2}`, message: r2 };
      console.info(s2);
    }
  }
  warn(i2, ...r2) {
    if (l.WARN >= this.level) {
      const s2 = { level: "warn", from: `${this.category}.${i2}`, message: r2 };
      console.warn(s2);
    }
  }
  error(i2, ...r2) {
    const s2 = { level: "error", from: `${this.category}.${i2}`, message: r2 };
    console.error(s2);
  }
};
var _e;
var _LoggerManager = class _LoggerManager {
  static getLogger(i2) {
    return __privateGet(this, _e).has(i2) || __privateGet(this, _e).set(i2, new Logger(i2, l.ERROR)), __privateGet(this, _e).get(i2);
  }
  static setLoggerLevel(i2) {
    Object.keys(i2).forEach((r2) => {
      _LoggerManager.getLogger(r2).level = i2[r2];
    });
  }
};
_e = new WeakMap();
__privateAdd(_LoggerManager, _e, /* @__PURE__ */ new Map());
var LoggerManager = _LoggerManager;
var h = { [d.EDITOR]: l.ERROR, [d.RECOGNIZER]: l.ERROR, [d.GRABBER]: l.ERROR, [d.RENDERER]: l.ERROR, [d.EDITOR_EVENT]: l.ERROR, [d.MODEL]: l.ERROR, [d.SYMBOL]: l.ERROR, [d.SMARTGUIDE]: l.ERROR, [d.GESTURE]: l.ERROR, [d.STYLE]: l.ERROR, [d.HISTORY]: l.ERROR, [d.TRANSFORMER]: l.ERROR, [d.CONVERTER]: l.ERROR, [d.WRITE]: l.ERROR, [d.SELECTION]: l.ERROR, [d.SVGDEBUG]: l.ERROR, [d.MENU]: l.ERROR };
var c;
!function(i2) {
  i2.CHANGED = "changed", i2.CLEARED = "cleared", i2.CONVERTED = "converted", i2.ERROR = "error", i2.POINTEREVENTS = "pointer_events", i2.NOTIF = "notif", i2.EXPORTED = "exported", i2.IMPORTED = "imported", i2.IDLE = "idle", i2.LOADED = "loaded", i2.SESSION_OPENED = "session-opened", i2.SELECTED = "selected", i2.TOOL_CHANGED = "tool-changed", i2.UI_UPDATED = "ui-updated", i2.SYNCHRONIZED = "synchronized", i2.GESTURED = "gestured";
}(c || (c = {}));
var _t;
var EditorEvent = class extends EventTarget {
  constructor(i2) {
    super();
    __privateAdd(this, _t, LoggerManager.getLogger(d.EDITOR_EVENT));
    __publicField(this, "abortController");
    __publicField(this, "element");
    __privateGet(this, _t).info("constructor", { element: i2 }), this.abortController = new AbortController(), this.element = i2;
  }
  removeAllListeners() {
    __privateGet(this, _t).info("removeAllListeners"), this.abortController.abort(), this.abortController = new AbortController();
  }
  emit(i2, r2) {
    var _a;
    const s2 = new CustomEvent(i2, Object.assign({ bubbles: true, composed: true }, r2 ? { detail: r2 } : void 0));
    this.dispatchEvent(s2), (_a = this.element) == null ? void 0 : _a.dispatchEvent(s2);
  }
  emitSessionOpened(i2) {
    __privateGet(this, _t).info("emitSessionOpened"), this.emit(c.SESSION_OPENED, i2);
  }
  addSessionOpenedListener(i2) {
    __privateGet(this, _t).info("addSessionOpenedListener", { callback: i2 }), this.addEventListener(c.SESSION_OPENED, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitLoaded() {
    __privateGet(this, _t).info("emitLoaded"), this.emit(c.LOADED);
  }
  addLoadedListener(i2) {
    __privateGet(this, _t).info("addLoadedListener", { callback: i2 }), this.addEventListener(c.LOADED, () => i2(), { signal: this.abortController.signal });
  }
  emitNotif(i2) {
    __privateGet(this, _t).info("emitNotif", { notif: i2 }), this.emit(c.NOTIF, i2);
  }
  addNotifListener(i2) {
    __privateGet(this, _t).info("addNotifListener", { callback: i2 }), this.addEventListener(c.NOTIF, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitError(i2) {
    __privateGet(this, _t).info("emitError", { err: i2 }), this.emit(c.ERROR, i2);
  }
  addErrorListener(i2) {
    __privateGet(this, _t).info("addErrorListener", { callback: i2 }), this.addEventListener(c.ERROR, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitExported(i2) {
    __privateGet(this, _t).info("emitExported", { exports: i2 }), this.emit(c.EXPORTED, i2);
  }
  addExportedListener(i2) {
    __privateGet(this, _t).info("addExportedListener", { callback: i2 }), this.addEventListener(c.EXPORTED, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitChanged(i2) {
    __privateGet(this, _t).info("emitChanged", { undoRedoContext: i2 }), this.emit(c.CHANGED, { ...i2, canClear: !i2.empty });
  }
  addChangedListener(i2) {
    __privateGet(this, _t).info("addChangedListener", { callback: i2 }), this.addEventListener(c.CHANGED, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitIdle(i2) {
    __privateGet(this, _t).info("emitIdle", { idle: i2 }), this.emit(c.IDLE, i2);
  }
  addIdleListener(i2) {
    __privateGet(this, _t).info("addIdleListener", { callback: i2 }), this.addEventListener(c.IDLE, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitCleared() {
    __privateGet(this, _t).info("emitCleared"), this.emit(c.CLEARED);
  }
  addClearedListener(i2) {
    __privateGet(this, _t).info("addClearedListener", { callback: i2 }), this.addEventListener(c.CLEARED, () => i2(), { signal: this.abortController.signal });
  }
  emitConverted(i2) {
    __privateGet(this, _t).info("emitConverted", { exports: i2 }), this.emit(c.CONVERTED, i2);
  }
  addConvertedListener(i2) {
    __privateGet(this, _t).info("addConvertedListener", { callback: i2 }), this.addEventListener(c.CONVERTED, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitImported(i2) {
    __privateGet(this, _t).info("emitImported", { exports: i2 }), this.emit(c.IMPORTED, i2);
  }
  addImportedListener(i2) {
    __privateGet(this, _t).info("addImportedListener", { callback: i2 }), this.addEventListener(c.IMPORTED, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitSelected(i2) {
    __privateGet(this, _t).info("emitSelected"), this.emit(c.SELECTED, i2);
  }
  addSelectedListener(i2) {
    __privateGet(this, _t).info("addSelectedListener", { callback: i2 }), this.addEventListener(c.SELECTED, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitToolChanged(i2) {
    __privateGet(this, _t).info("emitToolChanged"), this.emit(c.TOOL_CHANGED, i2);
  }
  addToolChangedListener(i2) {
    __privateGet(this, _t).info("addToolChangedListener", { callback: i2 }), this.addEventListener(c.TOOL_CHANGED, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitUIpdated() {
    __privateGet(this, _t).info("emitUIpdated"), this.emit(c.UI_UPDATED);
  }
  addUIpdatedListener(i2) {
    __privateGet(this, _t).info("addUIpdatedListener", { callback: i2 }), this.addEventListener(c.UI_UPDATED, () => i2(), { signal: this.abortController.signal });
  }
  emitSynchronized() {
    __privateGet(this, _t).info("emitSynchronized"), this.emit(c.SYNCHRONIZED);
  }
  addSynchronizedListener(i2) {
    __privateGet(this, _t).info("addSynchronizedListener", { callback: i2 }), this.addEventListener(c.SYNCHRONIZED, () => i2(), { signal: this.abortController.signal });
  }
  emitGestured(i2) {
    __privateGet(this, _t).info("emitSynchronized"), this.emit(c.GESTURED, i2);
  }
  addGesturedListener(i2) {
    __privateGet(this, _t).info("addSynchronizedListener", { callback: i2 }), this.addEventListener(c.GESTURED, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
};
_t = new WeakMap();
var u;
var p;
var g;
var m;
var EditorLayer = class {
  constructor(i2, r2 = "ms-editor") {
    __publicField(this, "root");
    __publicField(this, "ui");
    __publicField(this, "rendering");
    __publicField(this, "onCloseModal");
    this.root = i2, this.root.classList.add(r2), this.rendering = this.createLayerRender(), this.ui = this.createLayerUI();
  }
  render() {
    const i2 = document.createElement("style");
    i2.appendChild(document.createTextNode(`.ms-editor{color:#1a9fff;container-name:editor;container-type:inline-size;font-family:sans-serif;height:100%;overflow:auto;position:relative;touch-action:none;width:100%;z-index:10}#editor:active,#editor:focus{-webkit-tap-highlight-color:transparent}.ms-editor.draw{cursor:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m14.363 5.652 1.48-1.48a2 2 0 0 1 2.829 0l1.414 1.414a2 2 0 0 1 0 2.828l-1.48 1.48m-4.243-4.242-9.616 9.615a2 2 0 0 0-.578 1.238l-.242 2.74a1 1 0 0 0 1.084 1.085l2.74-.242a2 2 0 0 0 1.24-.578l9.615-9.616m-4.243-4.242 4.243 4.242' stroke='%23000' fill='%23fff' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E") 5 20,pointer}.ms-editor.draw.shape{cursor:crosshair}.ms-editor.erase{cursor:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m2.893 12.607 9.193-9.193a2 2 0 0 1 2.828 0l4.95 4.95a2 2 0 0 1 0 2.828l-9.243 9.243a1.929 1.929 0 0 1-2.728 0l-5-5a2 2 0 0 1 0-2.828Z' stroke='%23000' fill='%23fff' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M21 21H9M15.889 14.89 8.464 7.463' stroke='%23000' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E") 5 20,auto}.ms-editor.move{cursor:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='m7 10.5-2.004 2.672a2 2 0 0 0 .126 2.552l3.784 4.128c.378.413.912.648 1.473.648H15c2.4 0 4-1.5 4-4 0 0 0 0 0 0V7.929M16 8.5v-.571c0-2.286 3-2.286 3 0' stroke='%23000' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M13 8.5V7.027m0-.527v.527M16 8.5V7.027c0-2.286-3-2.286-3 0' stroke='%23000' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M13 8.5V7.027c0-2.286 3-2.286 3 0V8.5M10 8.5v-2c0-2.286 3-2.286 3 0 0 0 0 0 0 0v2M7 13.5v-7A1.5 1.5 0 0 1 8.5 5v0c.828 0 1.5.555 1.5 1.384V8.5' stroke='%23000' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E") 10 10,auto}.ms-editor.select{cursor:context-menu}.ms-editor .ms-layer-rendering{height:100%;width:100%}.ms-editor .ms-layer-rendering,.ms-editor [data-layer=CAPTURE],.ms-editor [data-layer=MODEL]{left:0;position:absolute;top:0;z-index:20}.ms-editor .ms-layer-rendering .ms-rendering-canvas{pointer-events:none;z-index:9}.ms-editor .ms-layer-rendering.text .ms-rendering-canvas{background-image:linear-gradient(180deg,#c8c8c8 1px,transparent 0)}.ms-editor .ms-layer-rendering.diagram .ms-rendering-canvas,.ms-editor .ms-layer-rendering.raw-content .ms-rendering-canvas,.ms-editor .ms-layer-rendering.shape .ms-rendering-canvas{background-image:linear-gradient(90deg,#c8c8c8 1px,transparent 0),linear-gradient(180deg,#c8c8c8 1px,transparent 0);background-size:40px 40px}.ms-editor .ms-layer-ui{height:100%;left:0;pointer-events:none;position:sticky;top:0;user-select:none;width:100%;z-index:25}.ms-editor .ms-layer-ui>*{cursor:auto;pointer-events:all;user-select:none}.ms-editor .loader{-webkit-animation:spin 2s linear infinite;animation:spin 2s linear infinite;border:16px solid #f5f6f7;border-radius:50%;border-top-color:#1a9fff;height:120px;left:calc(50% - 60px);position:absolute;top:calc(50% - 60px);width:120px;z-index:30}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg)}to{-webkit-transform:rotate(1turn)}}.ms-editor .state{background-color:#f5f6f7;bottom:8px;box-shadow:1px 1px 5px rgba(0,0,0,.25),-1px -1px 5px rgba(0,0,0,.25);color:#717171;cursor:auto;height:42px;left:0;position:absolute;width:42px;z-index:99}.ms-editor .state .busy{-webkit-animation:spin 2s linear infinite;animation:spin 2s linear infinite;border:4px solid #1a9fff;border-radius:100%;border-right-color:#f5f6f7;color:#717171;height:30px;margin-left:6px;margin-top:6px;width:30px}.ms-editor .message-container,.ms-editor .message-overlay{height:100%;position:absolute;width:100%}.ms-editor .message-overlay{background-color:hsla(0,0%,73%,.25);z-index:99}.ms-editor .message-modal{word-wrap:break-word;background-color:#fff;box-shadow:1px 1px 5px rgba(0,0,0,.25),-1px -1px 5px rgba(0,0,0,.25);font-size:16px;left:50%;max-height:calc(100% - 100px);max-width:calc(100% - 8px);overflow:auto;padding:12px;position:absolute;text-align:center;top:50%;transform:translate(-50%,-50%);z-index:999}@container editor (max-width: 400px){.ms-editor .message-modal{width:100%}}@container editor (min-width: 401px) and (max-width: 800px){.ms-editor .message-modal{width:66%}}@container editor (min-width: 801px){.ms-editor .message-modal{width:50%}}.ms-editor .message-modal.error-msg:before{content:url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgNzYuNSA2MTIgNDU5IiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWluWU1pbiBtZWV0Ij48cGF0aCBmaWxsPSIjMUE5RkZGIiBkPSJNNDk0LjcgMjI5LjVjLTE3Ljg1MS04Ni43LTk0LjM1MS0xNTMtMTg4LjctMTUzLTM4LjI1IDAtNzMuOTUgMTAuMi0xMDIgMzAuNmwzOC4yNSAzOC4yNWMxNy44NS0xMi43NSA0MC44LTE3Ljg1IDYzLjc1LTE3Ljg1IDc2LjUgMCAxNDAuMjUgNjMuNzUgMTQwLjI1IDE0MC4yNXYxMi43NWgzOC4yNWM0My4zNSAwIDc2LjUgMzMuMTUgNzYuNSA3Ni41IDAgMjguMDUtMTUuMyA1My41NS00MC44IDY2LjNsMzguMjUgMzguMjVDNTkxLjYgNDM4LjYgNjEyIDQwMC4zNSA2MTIgMzU3YzAtNjYuMy01My41NS0xMjIuNC0xMTcuMy0xMjcuNXpNNzYuNSAxMDkuNjVsNzEuNCA2OC44NUM2Ni4zIDE4My42IDAgMjQ5LjkgMCAzMzEuNWMwIDg0LjE1IDY4Ljg1IDE1MyAxNTMgMTUzaDI5OC4zNWw1MSA1MSAzMy4xNS0zMy4xNUwxMDkuNjUgNzYuNSA3Ni41IDEwOS42NXpNMTk2LjM1IDIyOS41bDIwNCAyMDRIMTUzYy01Ni4xIDAtMTAyLTQ1LjktMTAyLTEwMnM0NS45LTEwMiAxMDItMTAyaDQzLjM1eiIvPjwvc3ZnPg==");display:block;margin:auto;width:100px}.ms-editor .message-modal.info-msg:before{background-image:url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMUE5RkZGIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTAiLz48cGF0aCBkPSJNMTIgMTZ2LTRNMTIgOGguMDEiLz48L3N2Zz4=");background-size:100% 100%;content:"";display:block;height:25px;margin:auto;padding-bottom:10px;width:25px}.ms-editor .message-modal .ms-button{background-color:#fff;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' fill='none' xmlns='http://www.w3.org/2000/svg' color='%23000'%3E%3Cpath d='M9.172 14.828 12.001 12m2.828-2.828L12.001 12m0 0L9.172 9.172M12.001 12l2.828 2.828M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10Z' stroke='%23000' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");background-position:50%;background-repeat:no-repeat;border:none;border-radius:4px;color:#000;cursor:pointer;font-size:inherit;height:32px;padding:0;position:absolute;right:0;top:0;width:32px}.ms-editor .message-modal .ms-button:hover{background-color:#eee}.ms-editor .collapsible-wrapper .collapsible-header{align-items:center;color:#424242;cursor:pointer;display:flex;justify-content:space-between}.ms-editor .collapsible-wrapper .collapsible-header:hover{background-color:#efefef}.ms-editor .collapsible-wrapper .collapsible-header .collapsible-header-icon{align-items:center;display:flex;height:32px;justify-content:center;padding:4px;position:relative;transition:transform .5s;width:32px}.ms-editor .collapsible-wrapper.active .collapsible-header .collapsible-header-icon{transform:rotate(180deg)}.ms-editor .collapsible-wrapper .collapsible-content{max-height:0;overflow:auto;transition:max-height .5s}.ms-editor .collapsible-wrapper.active .collapsible-content{max-height:200px}.ms-editor .removed-stroke{opacity:0;transition:opacity .1s ease-in-out}`)), this.root.prepend(i2), this.root.appendChild(this.rendering), this.root.appendChild(this.ui.root);
  }
  createLoader() {
    const i2 = document.createElement("div");
    return i2.classList.add("loader"), i2.style.display = "none", i2;
  }
  showLoader() {
    this.ui.loader.style.display = "block";
  }
  hideLoader() {
    this.ui.loader.style.display = "none";
  }
  createMessageOverlay() {
    const i2 = document.createElement("div");
    return i2.classList.add("message-overlay"), i2;
  }
  closeMessageModal() {
    var _a;
    (_a = this.onCloseModal) == null ? void 0 : _a.call(this, this.ui.message.modal.root.classList.contains("error-msg")), this.hideMessageModal();
  }
  hideMessageModal() {
    this.ui.message.root.style.display = "none", this.ui.message.modal.text.innerText = "", this.ui.message.modal.root.classList.remove("error-msg"), this.ui.message.modal.root.classList.remove("info-msg");
  }
  createMessageModal() {
    const i2 = document.createElement("div");
    i2.classList.add("message-modal");
    const r2 = document.createElement("button");
    r2.classList.add("ms-button", "close"), r2.addEventListener("pointerup", this.closeMessageModal.bind(this)), i2.appendChild(r2);
    const s2 = document.createElement("p");
    return i2.appendChild(s2), { root: i2, text: s2 };
  }
  createMessage() {
    const i2 = document.createElement("div");
    i2.classList.add("message-container"), i2.style.display = "none";
    const r2 = this.createMessageOverlay();
    i2.appendChild(r2);
    const s2 = this.createMessageModal();
    return i2.appendChild(s2.root), { root: i2, overlay: r2, modal: s2 };
  }
  showMessageInfo(i2) {
    this.ui.message.modal.root.classList.add("info-msg"), this.ui.message.modal.root.classList.remove("error-msg"), this.ui.message.root.style.display = "block", this.ui.message.modal.text.innerText = i2.message, setTimeout(() => {
      this.closeMessageModal();
    }, i2.timeout || 2500);
  }
  showMessageError(i2) {
    this.ui.message.modal.root.classList.add("error-msg"), this.ui.message.modal.root.classList.remove("info-msg"), this.ui.message.root.style.display = "block", this.ui.message.modal.text.innerText = "string" == typeof i2 ? i2 : i2.message;
  }
  createBusy() {
    const i2 = document.createElement("div");
    return i2.classList.add("busy"), i2;
  }
  createState() {
    const i2 = document.createElement("div");
    i2.classList.add("state"), i2.style.display = "none";
    const r2 = this.createBusy();
    return i2.appendChild(r2), { root: i2, busy: r2 };
  }
  showState() {
    this.ui.state.root.style.display = "block";
  }
  hideState() {
    this.ui.state.root.style.display = "none";
  }
  updateState(i2) {
    i2 ? this.hideState() : this.showState();
  }
  createLayerUI() {
    const i2 = document.createElement("div");
    i2.classList.add("ms-layer-ui");
    const r2 = this.createLoader();
    i2.appendChild(r2);
    const s2 = this.createMessage();
    i2.appendChild(s2.root);
    const n2 = this.createState();
    return i2.appendChild(n2.root), { root: i2, loader: r2, message: s2, state: n2 };
  }
  createLayerRender() {
    const i2 = document.createElement("div");
    return i2.classList.add("ms-layer-rendering"), i2;
  }
  destroy() {
    for (; this.root.lastChild; ) this.root.removeChild(this.root.lastChild);
  }
};
var _i;
var AbstractEditor = class {
  constructor(i2, r2) {
    __publicField(this, "logger", LoggerManager.getLogger(d.EDITOR));
    __publicField(this, "layers");
    __publicField(this, "event");
    __publicField(this, "info");
    __privateAdd(this, _i);
    var _a, _b2;
    this.loggerConfiguration = Object.assign({}, h, (_a = r2 == null ? void 0 : r2.configuration) == null ? void 0 : _a.logger), this.logger.info("constructor", { rootElement: i2, options: r2 }), this.event = new EditorEvent(i2), this.layers = new EditorLayer(i2, ((_b2 = r2 == null ? void 0 : r2.override) == null ? void 0 : _b2.cssClass) || "ms-editor"), i2.editor = this;
  }
  get loggerConfiguration() {
    return __privateGet(this, _i);
  }
  set loggerConfiguration(i2) {
    __privateSet(this, _i, Object.assign({}, h, i2)), LoggerManager.setLoggerLevel(__privateGet(this, _i));
  }
  async loadInfo(i2) {
    return this.info || (this.info = await getApiInfos({ server: i2 })), this.info;
  }
};
_i = new WeakMap();
!function(i2) {
  i2.JIIX = "application/vnd.myscript.jiix", i2.TEXT = "text/plain", i2.LATEX = "application/x-latex", i2.MATHML = "application/mathml+xml", i2.SVG = "image/svg+xml", i2.OFFICE_DOCUMENT = "application/vnd.openxmlformats-officedocument.presentationml.presentation";
}(u || (u = {})), function(i2) {
  i2.Text = "Text", i2.Node = "Node", i2.Edge = "Edge", i2.RawContent = "Raw Content";
}(p || (p = {})), function(i2) {
  i2.Circle = "circle", i2.Ellipse = "ellipse", i2.Rectangle = "rectangle", i2.Triangle = "triangle", i2.Parallelogram = "parallelogram", i2.Polygon = "polygon", i2.Rhombus = "rhombus";
}(g || (g = {})), function(i2) {
  i2.Line = "line", i2.PolyEdge = "polyedge", i2.Arc = "arc";
}(m || (m = {}));
var Box = class _Box {
  constructor(i2) {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "width");
    __publicField(this, "height");
    if (i2.width < 0) throw new Error("width must be positive");
    if (i2.height < 0) throw new Error("height must be positive");
    this.height = i2.height, this.width = i2.width, this.x = i2.x, this.y = i2.y;
  }
  static createFromBoxes(i2) {
    if (!(i2 == null ? void 0 : i2.length)) return new _Box({ height: 0, width: 0, x: 0, y: 0 });
    const r2 = Math.min(...i2.map((i3) => i3.x)), s2 = Math.max(...i2.map((i3) => i3.x + i3.width)) - r2, n2 = Math.min(...i2.map((i3) => i3.y)), a2 = Math.max(...i2.map((i3) => i3.y + i3.height)) - n2;
    return new _Box({ x: r2, y: n2, width: s2, height: a2 });
  }
  static createFromPoints(i2) {
    if (!(i2 == null ? void 0 : i2.length)) return new _Box({ height: 0, width: 0, x: 0, y: 0 });
    const r2 = Math.min(...i2.map((i3) => i3.x)), s2 = Math.max(...i2.map((i3) => i3.x)) - r2, n2 = Math.min(...i2.map((i3) => i3.y)), a2 = Math.max(...i2.map((i3) => i3.y)) - n2;
    return new _Box({ x: r2, y: n2, width: s2, height: a2 });
  }
  static getCorners(i2) {
    return [{ x: i2.x, y: i2.y }, { x: i2.x + i2.width, y: i2.y }, { x: i2.x + i2.width, y: i2.y + i2.height }, { x: i2.x, y: i2.y + i2.height }];
  }
  static getCenter(i2) {
    return { x: i2.x + i2.width / 2, y: i2.y + i2.height / 2 };
  }
  static getSides(i2) {
    const r2 = _Box.getCorners(i2);
    return r2.map((i3, s2) => 3 === s2 ? { p1: r2[0], p2: i3 } : { p1: i3, p2: r2[s2 + 1] });
  }
  static isContained(i2, r2) {
    return isBetween(i2.x, r2.x, r2.x + r2.width) && isBetween(i2.x + i2.width, r2.x, r2.x + r2.width) && isBetween(i2.y, r2.y, r2.y + r2.height) && isBetween(i2.y + i2.height, r2.y, r2.y + r2.height);
  }
  static containsPoint(i2, r2) {
    return isBetween(r2.x, i2.x, i2.x + i2.width) && isBetween(r2.y, i2.y, i2.y + i2.height);
  }
  static contains(i2, r2) {
    return isBetween(r2.x, i2.x, i2.x + i2.width) && isBetween(r2.x + r2.width, i2.x, i2.x + i2.width) && isBetween(r2.y, i2.y, i2.y + i2.height) && isBetween(r2.y + r2.height, i2.y, i2.y + i2.height);
  }
  static overlaps(i2, r2) {
    return !(i2.x > r2.x + r2.width) && (!(i2.x + i2.width < r2.x) && (!(i2.y > r2.y + r2.height) && !(i2.y + i2.height < r2.y)));
  }
  get xMin() {
    return this.x;
  }
  get xMid() {
    return this.x + this.width / 2;
  }
  get xMax() {
    return this.x + this.width;
  }
  get yMin() {
    return this.y;
  }
  get yMid() {
    return this.y + this.height / 2;
  }
  get yMax() {
    return this.y + this.height;
  }
  get corners() {
    return _Box.getCorners(this);
  }
  get center() {
    return _Box.getCenter(this);
  }
  get snapPoints() {
    return [...this.corners, this.center];
  }
  isContained(i2) {
    return _Box.isContained(this, i2);
  }
  contains(i2) {
    return _Box.contains(this, i2);
  }
  containsPoint(i2) {
    return _Box.containsPoint(this, i2);
  }
  overlaps(i2) {
    return _Box.overlaps(this, i2);
  }
};
var y = { width: 2, color: "#000000" };
var b = {};
var f = { ink: { color: "#000000", width: 1, "-myscript-pen-width": 1, "-myscript-pen-fill-style": "none", "-myscript-pen-fill-color": "#FFFFFF00" }, ".math": { "font-family": "STIXGeneral" }, ".math-solved": { "font-family": "STIXGeneral", color: "#A8A8A8FF" }, ".text": { "font-family": "MyScriptInter", "font-size": 10 } };
var x = function createCommonjsModule(i2, r2) {
  return i2(r2 = { exports: {} }, r2.exports), r2.exports;
}(function(i2, r2) {
  i2.exports = function(i3) {
    function e(s2) {
      if (r3[s2]) return r3[s2].exports;
      var n2 = r3[s2] = { i: s2, l: false, exports: {} };
      return i3[s2].call(n2.exports, n2, n2.exports, e), n2.l = true, n2.exports;
    }
    var r3 = {};
    return e.m = i3, e.c = r3, e.i = function(i4) {
      return i4;
    }, e.d = function(i4, r4, s2) {
      e.o(i4, r4) || Object.defineProperty(i4, r4, { configurable: false, enumerable: true, get: s2 });
    }, e.n = function(i4) {
      var r4 = i4 && i4.__esModule ? function() {
        return i4.default;
      } : function() {
        return i4;
      };
      return e.d(r4, "a", r4), r4;
    }, e.o = function(i4, r4) {
      return Object.prototype.hasOwnProperty.call(i4, r4);
    }, e.p = "", e(e.s = 1);
  }([function(i3, r3, s2) {
    function o(i4, r4) {
      if (!(i4 instanceof r4)) throw new TypeError("Cannot call a class as a function");
    }
    Object.defineProperty(r3, "__esModule", { value: true });
    var n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(i4) {
      return typeof i4;
    } : function(i4) {
      return i4 && "function" == typeof Symbol && i4.constructor === Symbol && i4 !== Symbol.prototype ? "symbol" : typeof i4;
    }, a2 = function t(i4) {
      var r4 = this;
      o(this, t), this.toJSON = function(i5) {
        if ("string" != typeof i5) return console.error("Need a CSS string but given ", void 0 === i5 ? "undefined" : n2(i5), i5), "Not a valid CSS..!";
        var s3 = {}, a3 = void 0, l2 = void 0, d2 = void 0;
        try {
          i5.split("{").forEach(function(i6) {
            if (l2 = i6.trim()) if (-1 === l2.indexOf("}")) s3[l2] = {}, a3 = l2;
            else {
              l2.substring(0, l2.indexOf("}")).split(";").forEach(function(i7) {
                (d2 = i7.split(":")) && 2 === d2.length && (s3[a3][d2[0].trim().replace(/^\"|\"$/g, "")] = r4._trimSemiColon(d2[1].trim().replace(/^\"|\"$/g, "")));
              });
              try {
                (a3 = l2.split("}")[1].trim()) && (s3[a3] = {});
              } catch (i7) {
              }
            }
          });
        } catch (i6) {
          return "Not a valid CSS..!";
        }
        return s3;
      }, this.toCSS = function(i5) {
        if ("object" !== (void 0 === i5 ? "undefined" : n2(i5))) return console.error("Need a JSON object but given ", void 0 === i5 ? "undefined" : n2(i5), i5), "Not a valid JSON..!";
        var r5 = "";
        try {
          for (var s3 in i5) if (i5.hasOwnProperty(s3)) {
            for (var a3 in r5 += s3 + " {\n", i5[s3]) i5[s3].hasOwnProperty(a3) && (r5 += a3 + ": " + i5[s3][a3] + ";\n");
            r5 += "}\n";
          }
        } catch (i6) {
          return "Not a valid JSON..!";
        }
        return r5;
      }, this._trimSemiColon = function(i5) {
        return ";" === i5.slice(-1) ? i5.slice(0, r4.length - 1) : i5;
      };
    };
    r3.default = a2;
  }, function(i3, r3, s2) {
    i3.exports = s2(0).default;
  }]);
});
var S = function unwrapExports(i2) {
  return i2 && i2.__esModule && Object.prototype.hasOwnProperty.call(i2, "default") ? i2.default : i2;
}(x);
x.JsonCSS;
var w = new S();
var v = { themeToCSS: (i2) => w.toCSS(i2), themeToJSON(i2) {
  const r2 = w.toJSON(i2);
  return r2[".text"]["font-size"] = Number(r2[".text"]["font-size"]), r2.ink["-myscript-pen-width"] = Number(r2.ink["-myscript-pen-width"]), r2.ink.width = Number(r2.ink.width), r2;
}, penStyleToCSS(i2) {
  let r2 = w.toCSS({ css: i2 });
  return r2 = r2.substring(6, r2.length - 3), r2;
}, penStyleToJSON(i2) {
  const r2 = w.toJSON(`css {${i2}}`).css;
  return r2.width ? r2.width = Number(r2.width) : delete r2.width, r2["-myscript-pen-width"] ? r2["-myscript-pen-width"] = Number(r2["-myscript-pen-width"]) : delete r2["-myscript-pen-width"], r2;
}, stringToJSON: (i2) => w.toJSON(`css {${i2}}`).css, JSONToString: (i2) => Object.entries(i2).map(([i3, r2]) => `${i3}:${r2}`).join(";") };
var _r, _o, _s, _n, _t2;
var StyleManager = class {
  constructor(i2, r2) {
    __privateAdd(this, _r);
    __privateAdd(this, _o);
    __privateAdd(this, _s);
    __privateAdd(this, _n);
    __privateAdd(this, _t2, LoggerManager.getLogger(d.STYLE));
    __privateGet(this, _t2).info("constructor", { penStyle: i2, theme: r2 }), this.setTheme(r2), this.setPenStyleClasses(), this.setPenStyle(i2);
  }
  get currentPenStyle() {
    return __privateGet(this, _n) || __privateGet(this, _r);
  }
  get penStyle() {
    return __privateGet(this, _r);
  }
  setPenStyle(i2) {
    __privateGet(this, _t2).info("setPenStyle", { style: i2 }), __privateSet(this, _r, mergeDeep(structuredClone(b), i2 || {})), __privateSet(this, _n, i2 || this.theme[`.${__privateGet(this, _s)}`]), __privateGet(this, _t2).debug("setPenStyle", __privateGet(this, _n));
  }
  get theme() {
    return __privateGet(this, _o);
  }
  setTheme(i2) {
    __privateGet(this, _t2).info("setTheme", { theme: i2 }), __privateSet(this, _o, mergeDeep(structuredClone(f), i2 || {})), __privateGet(this, _t2).debug("setTheme", __privateGet(this, _o));
  }
  get penStyleClasses() {
    return __privateGet(this, _s);
  }
  setPenStyleClasses(i2 = "") {
    __privateGet(this, _t2).info("setPenStyleClasses", { penStyleClass: i2 }), __privateSet(this, _s, i2), __privateSet(this, _n, this.theme[`.${__privateGet(this, _s)}`]), __privateGet(this, _t2).debug("setPenStyleClasses", __privateGet(this, _n));
  }
};
_r = new WeakMap();
_o = new WeakMap();
_s = new WeakMap();
_n = new WeakMap();
_t2 = new WeakMap();
var k;
var E;
var I;
var C;
var M;
var T;
!function(i2) {
  i2.Highlight = "highlight", i2.Surround = "surround", i2.Underline = "underline", i2.Strikethrough = "strikethrough";
}(k || (k = {}));
var IIDecorator = class _IIDecorator {
  constructor(i2, r2) {
    __publicField(this, "id");
    __publicField(this, "kind");
    __publicField(this, "style");
    this.id = `${i2}-${createUUID()}`, this.style = structuredClone(mergeDeep({}, y, r2)), this.kind = i2;
  }
  clone() {
    const i2 = new _IIDecorator(this.kind, structuredClone(this.style));
    return i2.id = this.id, i2;
  }
};
var MatrixTransform = class _MatrixTransform {
  constructor(i2, r2, s2, n2, a2, l2) {
    __publicField(this, "xx");
    __publicField(this, "yx");
    __publicField(this, "xy");
    __publicField(this, "yy");
    __publicField(this, "tx");
    __publicField(this, "ty");
    this.xx = i2, this.yx = r2, this.xy = s2, this.yy = n2, this.tx = a2, this.ty = l2;
  }
  static identity() {
    return new _MatrixTransform(1, 0, 0, 1, 0, 0);
  }
  static applyToPoint(i2, r2) {
    return { x: i2.xx * r2.x + i2.xy * r2.y + i2.tx, y: i2.yx * r2.x + i2.yy * r2.y + i2.ty };
  }
  static rotation(i2) {
    let r2;
    if (0 !== i2.xx || 0 !== i2.xy) {
      const s2 = Math.hypot(i2.xx, i2.xy);
      r2 = Math.acos(i2.xx / s2) * (i2.xy > 0 ? -1 : 1);
    } else if (0 !== i2.yx || 0 !== i2.yy) {
      const s2 = Math.hypot(i2.yx, i2.yy);
      r2 = Math.PI / 2 + Math.acos(i2.yx / s2) * (i2.yy > 0 ? -1 : 1);
    } else r2 = 0;
    return r2;
  }
  static toCssString(i2) {
    return `matrix(${i2.xx}, ${i2.yx}, ${i2.xy}, ${i2.yy}, ${i2.tx}, ${i2.ty})`;
  }
  invert() {
    const { xx: i2, yx: r2, xy: s2, yy: n2, tx: a2, ty: l2 } = this, d2 = i2 * n2 - r2 * s2;
    return this.xx = n2 / d2, this.yx = r2 / -d2, this.xy = s2 / -d2, this.yy = i2 / d2, this.tx = (n2 * a2 - s2 * l2) / -d2, this.ty = (r2 * a2 - i2 * l2) / d2, this;
  }
  multiply(i2) {
    const { xx: r2, yx: s2, xy: n2, yy: a2, tx: l2, ty: d2 } = this;
    return this.xx = r2 * i2.xx + n2 * i2.yx, this.yx = s2 * i2.xx + a2 * i2.yx, this.xy = r2 * i2.xy + n2 * i2.yy, this.yy = s2 * i2.xy + a2 * i2.yy, this.tx = r2 * i2.tx + n2 * i2.ty + l2, this.ty = s2 * i2.tx + a2 * i2.ty + d2, this;
  }
  translate(i2, r2) {
    return this.multiply({ xx: 1, yx: 0, xy: 0, yy: 1, tx: i2, ty: r2 });
  }
  rotate(i2, r2) {
    r2 && this.translate(r2.x, r2.y);
    const s2 = Math.round(1e3 * Math.cos(i2)) / 1e3, n2 = Math.round(1e3 * Math.sin(i2)) / 1e3;
    return this.multiply({ xx: s2, yx: n2, xy: -n2, yy: s2, tx: 0, ty: 0 }), r2 && this.translate(-r2.x, -r2.y), this;
  }
  scale(i2, r2, s2) {
    return s2 && this.translate(s2.x, s2.y), this.multiply({ xx: i2, yx: 0, xy: 0, yy: r2, tx: 0, ty: 0 }), s2 && this.translate(-s2.x, -s2.y), this;
  }
  applyToPoint(i2) {
    return _MatrixTransform.applyToPoint(this, i2);
  }
  clone() {
    return new _MatrixTransform(this.xx, this.yx, this.xy, this.yy, this.tx, this.ty);
  }
  toCssString() {
    return _MatrixTransform.toCssString(this);
  }
};
var IISymbolBase = class {
  constructor(i2, r2) {
    __publicField(this, "type");
    __publicField(this, "style");
    __publicField(this, "id");
    __publicField(this, "creationTime");
    __publicField(this, "modificationDate");
    __publicField(this, "selected");
    __publicField(this, "deleting");
    __publicField(this, "transform");
    this.type = i2, this.id = `${this.type}-${createUUID()}`, this.creationTime = Date.now(), this.modificationDate = this.creationTime, this.selected = false, this.deleting = false, this.transform = MatrixTransform.identity(), this.style = Object.assign({}, y, r2), this.style.opacity && (this.style.opacity = +this.style.opacity), this.style.width = +this.style.width;
  }
  get edges() {
    return this.isClosed ? this.vertices.map((i2, r2) => r2 === this.vertices.length - 1 ? { p1: i2, p2: this.vertices[0] } : { p1: i2, p2: this.vertices[r2 + 1] }) : this.vertices.slice(0, -1).map((i2, r2) => ({ p1: i2, p2: this.vertices[r2 + 1] }));
  }
  isIntersected(i2) {
    return this.edges.some((r2) => findIntersectionBetween2Segment(r2, i2));
  }
};
!function(i2) {
  i2.Stroke = "stroke", i2.Group = "group", i2.Shape = "shape", i2.Edge = "edge", i2.Text = "text", i2.Eraser = "eraser", i2.Recognized = "recognized";
}(E || (E = {})), function(i2) {
  i2.Line = "line", i2.PolyEdge = "polyedge", i2.Arc = "arc";
}(I || (I = {})), function(i2) {
  i2.Arrow = "arrow-head";
}(C || (C = {}));
var OIEdgeBase = class extends IISymbolBase {
  constructor(i2, r2, s2, n2) {
    super(E.Edge, n2);
    __publicField(this, "kind");
    __publicField(this, "isClosed", false);
    __publicField(this, "startDecoration");
    __publicField(this, "endDecoration");
    this.kind = i2, this.startDecoration = r2, this.endDecoration = s2;
  }
  get bounds() {
    const i2 = Box.createFromPoints(this.vertices);
    return i2.x -= 5, i2.y -= 5, i2.height += a, i2.width += a, (this.startDecoration || this.endDecoration) && (i2.x -= 2.5 * (this.style.width || 1), i2.y -= 2.5 * (this.style.width || 1), i2.height += 5 * (this.style.width || 1), i2.width += 5 * (this.style.width || 1)), i2;
  }
  get snapPoints() {
    return this.vertices;
  }
  overlaps(i2) {
    return this.bounds.isContained(i2) || this.edges.some((r2) => Box.getSides(i2).some((i3) => !!findIntersectionBetween2Segment(r2, i3)));
  }
};
function isValidPoint(i2) {
  return !!i2 && (!!isValidNumber(i2.x) && !!isValidNumber(i2.y));
}
var IIEdgeArc = class _IIEdgeArc extends OIEdgeBase {
  constructor(i2, r2, s2, n2, a2, l2, d2, h2, c2) {
    super(I.Arc, d2, h2, c2);
    __publicField(this, "center");
    __publicField(this, "startAngle");
    __publicField(this, "sweepAngle");
    __publicField(this, "radiusX");
    __publicField(this, "radiusY");
    __publicField(this, "phi");
    __publicField(this, "_vertices");
    this.center = i2, this.startAngle = r2, this.sweepAngle = s2, this.radiusX = n2, this.radiusY = a2, this.phi = l2, this._vertices = /* @__PURE__ */ new Map(), this._vertices.set(this.verticesId, this.computedVertices());
  }
  get verticesId() {
    return `${this.center.x}-${this.center.y}-${this.startAngle}-${this.sweepAngle}-${this.radiusX}-${this.radiusY}-${this.phi}`;
  }
  computedVertices() {
    const i2 = Math.abs(this.sweepAngle) * Math.sqrt((Math.pow(this.radiusX, 2) + Math.pow(this.radiusY, 2)) / 2), r2 = Math.max(8, Math.round(i2 / a)), s2 = this.sweepAngle / r2, n2 = [], l2 = this.startAngle + this.sweepAngle;
    if (this.sweepAngle > 0) for (let i3 = this.startAngle; i3 < l2; i3 += s2) n2.push(computePointOnEllipse(this.center, this.radiusX, this.radiusY, this.phi, i3));
    else for (let i3 = this.startAngle; i3 > l2; i3 += s2) n2.push(computePointOnEllipse(this.center, this.radiusX, this.radiusY, this.phi, i3));
    return n2.push(computePointOnEllipse(this.center, this.radiusX, this.radiusY, this.phi, l2)), n2;
  }
  get vertices() {
    return this._vertices.has(this.verticesId) || this._vertices.set(this.verticesId, this.computedVertices()), this._vertices.get(this.verticesId);
  }
  get snapPoints() {
    return [this.vertices[0], this.vertices.at(-1)];
  }
  clone() {
    const i2 = new _IIEdgeArc(structuredClone(this.center), this.startAngle, this.sweepAngle, this.radiusX, this.radiusY, this.phi, this.startDecoration, this.endDecoration, structuredClone(this.style));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, kind: this.kind, center: this.center, startAngle: this.startAngle, sweepAngle: this.sweepAngle, radiusX: this.radiusX, radiusY: this.radiusY, phi: this.phi, startDecoration: this.startDecoration, style: this.style, endDecoration: this.endDecoration };
  }
  static create(i2) {
    if (!isValidPoint(i2 == null ? void 0 : i2.center)) throw new Error("Unable to create a arc, center point is invalid");
    if (!isValidNumber(i2 == null ? void 0 : i2.startAngle)) throw new Error("Unable to create a arc, startAngle is invalid");
    if (!isValidNumber(i2 == null ? void 0 : i2.sweepAngle)) throw new Error("Unable to create a arc, sweepAngle is invalid");
    if (!isValidNumber(i2 == null ? void 0 : i2.radiusX)) throw new Error("Unable to create a arc, radiusX is invalid");
    if (!isValidNumber(i2 == null ? void 0 : i2.radiusY)) throw new Error("Unable to create a arc, radiusY is invalid");
    const r2 = new _IIEdgeArc(i2 == null ? void 0 : i2.center, i2.startAngle, i2.sweepAngle, i2.radiusX, i2.radiusY, i2.phi || 0, i2.startDecoration, i2.endDecoration, i2.style);
    return i2.id && (r2.id = i2.id), r2;
  }
};
var IIEdgeLine = class _IIEdgeLine extends OIEdgeBase {
  constructor(i2, r2, s2, n2, a2) {
    super(I.Line, s2, n2, a2);
    __publicField(this, "start");
    __publicField(this, "end");
    this.start = i2, this.end = r2;
  }
  get vertices() {
    return [this.start, this.end];
  }
  clone() {
    const i2 = new _IIEdgeLine(structuredClone(this.start), structuredClone(this.end), this.startDecoration, this.endDecoration, structuredClone(this.style));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, kind: this.kind, start: this.start, end: this.end, style: this.style, startDecoration: this.startDecoration, endDecoration: this.endDecoration };
  }
  static create(i2) {
    if (!isValidPoint(i2 == null ? void 0 : i2.start)) throw new Error("Unable to create a arc, start point is invalid");
    if (!isValidPoint(i2 == null ? void 0 : i2.end)) throw new Error("Unable to create a arc, end point is invalid");
    const r2 = new _IIEdgeLine(i2 == null ? void 0 : i2.start, i2 == null ? void 0 : i2.end, i2.startDecoration, i2.endDecoration, i2.style);
    return i2.id && (r2.id = i2.id), r2;
  }
};
var IIEdgePolyLine = class _IIEdgePolyLine extends OIEdgeBase {
  constructor(i2, r2, s2, n2) {
    super(I.PolyEdge, r2, s2, n2);
    __publicField(this, "points");
    this.points = i2;
  }
  get vertices() {
    return this.points;
  }
  clone() {
    const i2 = new _IIEdgePolyLine(structuredClone(this.points), this.startDecoration, this.endDecoration, structuredClone(this.style));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, kind: this.kind, points: this.points, style: this.style, startDecoration: this.startDecoration, endDecoration: this.endDecoration };
  }
  static create(i2) {
    var _a;
    if (!((_a = i2 == null ? void 0 : i2.points) == null ? void 0 : _a.map((i3) => isValidPoint(i3)))) throw new Error("Unable to create a PolyLine, points are invalid");
    const r2 = new _IIEdgePolyLine(i2 == null ? void 0 : i2.points, i2.startDecoration, i2.endDecoration, i2.style);
    return i2.id && (r2.id = i2.id), r2;
  }
};
!function(i2) {
  i2.Circle = "circle", i2.Ellipse = "ellipse", i2.Polygon = "polygon", i2.Table = "table";
}(M || (M = {}));
var OIShapeBase = class extends IISymbolBase {
  constructor(i2, r2) {
    super(E.Shape, r2);
    __publicField(this, "kind");
    __publicField(this, "isClosed", true);
    this.kind = i2;
  }
  get bounds() {
    return Box.createFromPoints(this.vertices);
  }
  get snapPoints() {
    return this.bounds.snapPoints;
  }
  overlaps(i2) {
    return this.bounds.isContained(i2) || this.edges.some((r2) => Box.getSides(i2).some((i3) => !!findIntersectionBetween2Segment(r2, i3)));
  }
};
var IIShapeCircle = class _IIShapeCircle extends OIShapeBase {
  constructor(i2, r2, s2) {
    super(M.Circle, s2);
    __publicField(this, "center");
    __publicField(this, "radius");
    __publicField(this, "_vertices");
    __publicField(this, "_bounds");
    this.center = i2, this.radius = r2, this._vertices = /* @__PURE__ */ new Map(), this._vertices.set(this.verticesId, this.computedVertices()), this._bounds = /* @__PURE__ */ new Map(), this._bounds.set(this.verticesId, this.computedBondingBox());
  }
  get verticesId() {
    return `${this.center.x}-${this.center.y}-${this.radius}`;
  }
  computedVertices() {
    const i2 = { x: this.center.x, y: this.radius + this.center.y }, r2 = 2 * Math.PI * this.radius, s2 = Math.max(8, Math.round(r2 / a)), n2 = [];
    for (let r3 = 0; r3 < s2; r3++) {
      const a2 = 2 * Math.PI * (r3 / s2);
      n2.push(computeRotatedPoint(i2, this.center, a2));
    }
    return n2;
  }
  computedBondingBox() {
    const i2 = { x: this.center.x - this.radius, y: this.center.y - this.radius, height: 2 * this.radius, width: 2 * this.radius };
    return new Box(i2);
  }
  get bounds() {
    return this._bounds.has(this.verticesId) || this._bounds.set(this.verticesId, this.computedBondingBox()), this._bounds.get(this.verticesId);
  }
  get vertices() {
    return this._vertices.has(this.verticesId) || this._vertices.set(this.verticesId, this.computedVertices()), this._vertices.get(this.verticesId);
  }
  overlaps(i2) {
    return this.bounds.isContained(i2) || Box.getSides(i2).some((i3) => findIntersectBetweenSegmentAndCircle(i3, this.center, this.radius).length);
  }
  clone() {
    const i2 = new _IIShapeCircle(structuredClone(this.center), this.radius, structuredClone(this.style));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, kind: this.kind, center: this.center, radius: this.radius, style: this.style };
  }
  static createBetweenPoints(i2, r2, s2) {
    const n2 = { x: (i2.x + r2.x) / 2, y: (i2.y + r2.y) / 2 }, a2 = Math.abs(i2.x - r2.x), l2 = Math.abs(i2.y - r2.y), d2 = Math.min(a2, l2) / 2;
    return new _IIShapeCircle(n2, d2, s2);
  }
  static updateBetweenPoints(i2, r2, s2) {
    i2.center = { x: (r2.x + s2.x) / 2, y: (r2.y + s2.y) / 2 };
    const n2 = Math.abs(r2.x - s2.x), a2 = Math.abs(r2.y - s2.y);
    return i2.radius = Math.min(n2, a2) / 2, i2;
  }
  static create(i2) {
    if (!isValidPoint(i2.center)) throw new Error("Unable to create circle, center is invalid");
    if (!isValidNumber(i2.radius)) throw new Error("Unable to create circle, radius is undefined");
    const r2 = new _IIShapeCircle(i2.center, i2.radius, i2.style);
    return i2.id && (r2.id = i2.id), r2;
  }
};
var IIShapeEllipse = class _IIShapeEllipse extends OIShapeBase {
  constructor(i2, r2, s2, n2, a2) {
    super(M.Ellipse, a2);
    __publicField(this, "center");
    __publicField(this, "radiusX");
    __publicField(this, "radiusY");
    __publicField(this, "orientation");
    __publicField(this, "_vertices");
    this.center = i2, this.radiusX = r2, this.radiusY = s2, this.orientation = n2, this._vertices = /* @__PURE__ */ new Map();
  }
  get verticesId() {
    return `${this.center.x}-${this.center.y}-${this.radiusX}-${this.radiusY}-${this.orientation}`;
  }
  computedVertices() {
    const i2 = [], r2 = 2 * Math.PI * Math.sqrt((Math.pow(this.radiusX, 2) + Math.pow(this.radiusY, 2)) / 2), s2 = Math.max(8, Math.round(r2 / a));
    for (let r3 = 0; r3 < s2; r3++) {
      const n2 = 2 * Math.PI * (r3 / s2);
      i2.push(computePointOnEllipse(this.center, this.radiusX, this.radiusY, this.orientation, n2));
    }
    return i2;
  }
  get vertices() {
    return this._vertices.has(this.verticesId) || this._vertices.set(this.verticesId, this.computedVertices()), this._vertices.get(this.verticesId);
  }
  overlaps(i2) {
    return this.bounds.isContained(i2) || this.edges.some((r2) => Box.getSides(i2).some((i3) => !!findIntersectionBetween2Segment(r2, i3)));
  }
  clone() {
    const i2 = new _IIShapeEllipse(structuredClone(this.center), this.radiusX, this.radiusY, this.orientation, structuredClone(this.style));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, kind: this.kind, center: this.center, orientation: this.orientation, radiusX: this.radiusX, radiusY: this.radiusY, style: this.style };
  }
  static createBetweenPoints(i2, r2, s2) {
    const n2 = { x: (i2.x + r2.x) / 2, y: (i2.y + r2.y) / 2 }, a2 = Math.abs(i2.x - r2.x) / 2, l2 = Math.abs(i2.y - r2.y) / 2;
    return new _IIShapeEllipse(n2, a2, l2, 0, s2);
  }
  static updateBetweenPoints(i2, r2, s2) {
    return i2.center = { x: (r2.x + s2.x) / 2, y: (r2.y + s2.y) / 2 }, i2.radiusX = Math.abs(r2.x - s2.x) / 2, i2.radiusY = Math.abs(r2.y - s2.y) / 2, i2;
  }
  static create(i2) {
    if (!isValidPoint(i2.center)) throw new Error("Unable to create ellipse, center is undefined");
    if (!isValidNumber(i2.radiusX)) throw new Error("Unable to create ellipse, radiusX is undefined");
    if (!isValidNumber(i2.radiusY)) throw new Error("Unable to create ellipse, radiusY is undefined");
    const r2 = new _IIShapeEllipse(i2.center, i2.radiusX, i2.radiusY, i2.orientation || 0, i2.style);
    return i2.id && (r2.id = i2.id), r2;
  }
};
var IIShapePolygon = class _IIShapePolygon extends OIShapeBase {
  constructor(i2, r2) {
    super(M.Polygon, r2);
    __publicField(this, "points");
    this.points = i2;
  }
  get vertices() {
    return this.points;
  }
  get bounds() {
    return Box.createFromPoints(this.vertices);
  }
  clone() {
    const i2 = new _IIShapePolygon(structuredClone(this.points), structuredClone(this.style));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, kind: this.kind, points: this.points, style: this.style };
  }
  static create(i2) {
    var _a, _b2;
    if (!(i2 == null ? void 0 : i2.points) || ((_a = i2 == null ? void 0 : i2.points) == null ? void 0 : _a.length) < 3) throw new Error("Unable to create polygon at least 3 points required");
    if ((_b2 = i2 == null ? void 0 : i2.points) == null ? void 0 : _b2.some((i3) => !isValidPoint(i3))) throw new Error("Unable to create a polygon, one or more points are invalid");
    const r2 = new _IIShapePolygon(i2.points, i2.style);
    return i2.id && (r2.id = i2.id), r2;
  }
  static createTriangleBetweenPoints(i2, r2, s2) {
    const n2 = [{ x: i2.x, y: i2.y }, { x: r2.x, y: i2.y }, { x: (i2.x + r2.x) / 2, y: r2.y }];
    return new _IIShapePolygon(n2, s2);
  }
  static updateTriangleBetweenPoints(i2, r2, s2) {
    return i2.points = [{ x: r2.x, y: r2.y }, { x: s2.x, y: r2.y }, { x: (r2.x + s2.x) / 2, y: s2.y }], i2.modificationDate = Date.now(), i2;
  }
  static createParallelogramBetweenPoints(i2, r2, s2) {
    const n2 = [{ x: i2.x, y: i2.y }, { x: i2.x + 0.75 * (r2.x - i2.x), y: i2.y }, { x: r2.x, y: r2.y }, { x: i2.x + 0.25 * (r2.x - i2.x), y: r2.y }];
    return new _IIShapePolygon(n2, s2);
  }
  static updateParallelogramBetweenPoints(i2, r2, s2) {
    const n2 = [{ x: r2.x, y: r2.y }, { x: r2.x + 0.75 * (s2.x - r2.x), y: r2.y }, { x: s2.x, y: s2.y }, { x: r2.x + 0.25 * (s2.x - r2.x), y: s2.y }];
    return i2.points = n2, i2.modificationDate = Date.now(), i2;
  }
  static createRectangleBetweenPoints(i2, r2, s2) {
    const n2 = Box.createFromPoints([i2, r2]), a2 = [{ x: n2.xMin, y: n2.yMin }, { x: n2.xMax, y: n2.yMin }, { x: n2.xMax, y: n2.yMax }, { x: n2.xMin, y: n2.yMax }];
    return new _IIShapePolygon(a2, s2);
  }
  static updateRectangleBetweenPoints(i2, r2, s2) {
    const n2 = Box.createFromPoints([r2, s2]), a2 = [{ x: n2.xMin, y: n2.yMin }, { x: n2.xMax, y: n2.yMin }, { x: n2.xMax, y: n2.yMax }, { x: n2.xMin, y: n2.yMax }];
    return i2.points = a2, i2.modificationDate = Date.now(), i2;
  }
  static createRhombusBetweenPoints(i2, r2, s2) {
    const n2 = Box.createFromPoints([i2, r2]), a2 = [{ x: n2.xMid, y: n2.yMin }, { x: n2.xMax, y: n2.yMid }, { x: n2.xMid, y: n2.yMax }, { x: n2.xMin, y: n2.yMid }];
    return new _IIShapePolygon(a2, s2);
  }
  static updateRhombusBetweenPoints(i2, r2, s2) {
    const n2 = Box.createFromPoints([r2, s2]), a2 = [{ x: n2.xMid, y: n2.yMin }, { x: n2.xMax, y: n2.yMid }, { x: n2.xMid, y: n2.yMax }, { x: n2.xMin, y: n2.yMid }];
    return i2.points = a2, i2.modificationDate = Date.now(), i2;
  }
};
var IIStroke = class _IIStroke extends IISymbolBase {
  constructor(i2, r2 = "pen") {
    super(E.Stroke, i2);
    __publicField(this, "isClosed", false);
    __publicField(this, "pointerType");
    __publicField(this, "length");
    __publicField(this, "decorators");
    __publicField(this, "pointers");
    this.pointerType = r2, this.pointers = [], this.decorators = [], this.length = 0;
  }
  get bounds() {
    return Box.createFromPoints(this.vertices);
  }
  static split(i2, r2) {
    const s2 = new _IIStroke(i2.style, i2.pointerType);
    s2.pointers = i2.pointers.slice(0, r2);
    const n2 = new _IIStroke(i2.style, i2.pointerType);
    return n2.pointers = i2.pointers.slice(r2), { before: s2, after: n2 };
  }
  static substract(i2, r2) {
    var _a, _b2;
    if (!r2.length) return { before: i2 };
    const s2 = {}, n2 = { x: r2.pointers[0].x, y: r2.pointers[0].y }, a2 = getClosestPoint(i2.pointers, n2);
    if (a2.index > -1) {
      const r3 = _IIStroke.split(i2, a2.index);
      s2.before = r3.before, s2.after = r3.after;
    }
    const l2 = s2.after || i2, d2 = { x: r2.pointers.at(-1).x, y: r2.pointers.at(-1).y }, h2 = getClosestPoint(l2.pointers, d2);
    if (h2.index > -1) {
      const i3 = _IIStroke.split(l2, h2.index);
      s2.after = i3.after;
    }
    return ((_a = s2.before) == null ? void 0 : _a.pointers.length) || (s2.before = void 0), ((_b2 = s2.after) == null ? void 0 : _b2.pointers.length) || (s2.after = void 0), s2;
  }
  get snapPoints() {
    return this.bounds.snapPoints;
  }
  get vertices() {
    return this.pointers;
  }
  computePressure(i2) {
    let r2 = 1;
    i2 === this.length ? r2 = 1 : i2 < 10 ? r2 = 0.2 + Math.pow(0.1 * i2, 0.4) : i2 > this.length - 10 && (r2 = 0.2 + Math.pow(0.1 * (this.length - i2), 0.4));
    const s2 = r2 * Math.max(0.1, 1 - 0.1 * Math.sqrt(i2));
    return isNaN(s2) ? 0.5 : Math.round(100 * s2) / 100;
  }
  filterPointByAcquisitionDelta(i2) {
    const r2 = this.pointers.at(-1), s2 = 2 + (this.style.width || 1) / 4;
    return !r2 || Math.abs(r2.x - i2.x) >= s2 || Math.abs(r2.y - i2.y) >= s2;
  }
  addPointer(i2) {
    if (this.filterPointByAcquisitionDelta(i2)) {
      const r2 = this.pointers.at(-1), s2 = r2 ? computeDistance(i2, r2) : 0;
      this.length += s2, i2.p = this.computePressure(s2), this.pointers.push(i2), this.modificationDate = Date.now();
    }
  }
  overlaps(i2) {
    return this.pointers.some((r2) => r2.x >= i2.x && r2.x <= i2.x + i2.width && r2.y >= i2.y && r2.y <= i2.y + i2.height);
  }
  clone() {
    const i2 = new _IIStroke(this.style, this.pointerType);
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2.pointers = structuredClone(this.pointers), i2.decorators = this.decorators.map((i3) => i3.clone()), i2.length = this.length, i2;
  }
  formatToSend() {
    const i2 = { id: this.id, pointerType: this.pointerType, p: [], t: [], x: [], y: [] };
    return this.pointers.forEach((r2) => {
      i2.p.push(r2.p), i2.t.push(r2.t), i2.x.push(r2.x), i2.y.push(r2.y);
    }), i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, pointers: this.pointers, style: this.style, decorators: this.decorators.length ? this.decorators : void 0 };
  }
  static create(i2) {
    var _a, _b2, _c2;
    if (!((_a = i2.pointers) == null ? void 0 : _a.length)) throw new Error("not pointers");
    const r2 = new _IIStroke(i2.style, i2.pointerType);
    i2.id && (r2.id = i2.id);
    const s2 = [];
    let n2 = true;
    if ((_b2 = i2.pointers) == null ? void 0 : _b2.forEach((i3, a2) => {
      if (!i3) return s2.push(`no pointer at ${a2}`), void (n2 = false);
      const l2 = { p: i3.p || 1, t: i3.t || a2, x: 0, y: 0 };
      return null == (i3 == null ? void 0 : i3.x) || null == (i3 == null ? void 0 : i3.x) ? (s2.push(`no x at pointer at ${a2}`), void (n2 = false)) : (l2.x = i3.x, null == (i3 == null ? void 0 : i3.y) || null == (i3 == null ? void 0 : i3.y) ? (s2.push(`no y at pointer at ${a2}`), void (n2 = false)) : (l2.y = i3.y, void (n2 && r2.addPointer(l2))));
    }), s2.length) throw new Error(s2.join(" and "));
    return ((_c2 = i2.decorators) == null ? void 0 : _c2.length) && i2.decorators.forEach((i3) => {
      (i3 == null ? void 0 : i3.kind) && r2.decorators.push(new IIDecorator(i3.kind, Object.assign({}, r2.style, i3.style)));
    }), r2;
  }
};
function convertPartialStrokesToOIStrokes(i2) {
  const r2 = [], s2 = [];
  if (i2.forEach((i3, n2) => {
    try {
      s2.push(IIStroke.create(i3));
    } catch (i4) {
      r2.push(`stroke ${n2 + 1} has ${i4.message}`);
    }
  }), r2.length) throw new Error(r2.join("\n"));
  return s2;
}
!function(i2) {
  i2.Text = "text", i2.Line = "line", i2.PolyEdge = "polyedge", i2.Arc = "arc", i2.Circle = "circle", i2.Ellipse = "ellipse", i2.Polygone = "polygone";
}(T || (T = {}));
var IIRecognizedBase = class extends IISymbolBase {
  constructor(i2, r2, s2) {
    super(E.Recognized, s2);
    __publicField(this, "kind");
    __publicField(this, "strokes");
    this.kind = i2, this.strokes = r2;
  }
  get vertices() {
    return this.strokes.flatMap((i2) => i2.vertices);
  }
  get bounds() {
    return Box.createFromBoxes(this.strokes.map((i2) => i2.bounds));
  }
  get snapPoints() {
    return this.bounds.snapPoints;
  }
  updateChildrenStyle() {
    this.strokes.forEach((i2) => i2.style = Object.assign({}, i2.style, this.style));
  }
  overlaps(i2) {
    return this.strokes.some((r2) => r2.overlaps(i2));
  }
  containsStroke(i2) {
    return this.strokes.some((r2) => r2.id === i2);
  }
  removeStrokes(i2) {
    const r2 = this.strokes.filter((r3) => i2.includes(r3.id));
    return this.strokes = this.strokes.filter((r3) => !i2.includes(r3.id)), r2;
  }
};
var IIRecognizedArc = class _IIRecognizedArc extends IIRecognizedBase {
  constructor(i2, r2) {
    super(T.Arc, i2, r2);
    __publicField(this, "isClosed", false);
  }
  clone() {
    const i2 = new _IIRecognizedArc(this.strokes.map((i3) => i3.clone()), structuredClone({ ...this.style }));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, kind: this.kind, strokes: JSON.parse(JSON.stringify(this.strokes)) };
  }
  static create(i2) {
    var _a;
    if (!((_a = i2.strokes) == null ? void 0 : _a.length)) throw new Error("no strokes");
    const r2 = i2.strokes.map((i3) => IIStroke.create(i3)), s2 = new _IIRecognizedArc(r2, i2.style);
    return i2.id && (s2.id = i2.id), s2;
  }
};
var IIRecognizedCircle = class _IIRecognizedCircle extends IIRecognizedBase {
  constructor(i2, r2) {
    super(T.Circle, i2, r2);
    __publicField(this, "isClosed", true);
  }
  clone() {
    const i2 = new _IIRecognizedCircle(this.strokes.map((i3) => i3.clone()), structuredClone({ ...this.style }));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, kind: this.kind, strokes: JSON.parse(JSON.stringify(this.strokes)) };
  }
  static create(i2) {
    var _a;
    if (!((_a = i2.strokes) == null ? void 0 : _a.length)) throw new Error("no strokes");
    const r2 = i2.strokes.map((i3) => IIStroke.create(i3)), s2 = new _IIRecognizedCircle(r2, i2.style);
    return i2.id && (s2.id = i2.id), s2;
  }
};
var IIRecognizedEllipse = class _IIRecognizedEllipse extends IIRecognizedBase {
  constructor(i2, r2) {
    super(T.Ellipse, i2, r2);
    __publicField(this, "isClosed", true);
  }
  clone() {
    const i2 = new _IIRecognizedEllipse(this.strokes.map((i3) => i3.clone()), structuredClone({ ...this.style }));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, kind: this.kind, strokes: JSON.parse(JSON.stringify(this.strokes)) };
  }
  static create(i2) {
    var _a;
    if (!((_a = i2.strokes) == null ? void 0 : _a.length)) throw new Error("no strokes");
    const r2 = i2.strokes.map((i3) => IIStroke.create(i3)), s2 = new _IIRecognizedEllipse(r2, i2.style);
    return i2.id && (s2.id = i2.id), s2;
  }
};
var IIRecognizedLine = class _IIRecognizedLine extends IIRecognizedBase {
  constructor(i2, r2) {
    super(T.Line, i2, r2);
    __publicField(this, "isClosed", false);
  }
  clone() {
    const i2 = new _IIRecognizedLine(this.strokes.map((i3) => i3.clone()), structuredClone({ ...this.style }));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, kind: this.kind, strokes: JSON.parse(JSON.stringify(this.strokes)) };
  }
  static create(i2) {
    var _a;
    if (!((_a = i2.strokes) == null ? void 0 : _a.length)) throw new Error("no strokes");
    const r2 = i2.strokes.map((i3) => IIStroke.create(i3)), s2 = new _IIRecognizedLine(r2, i2.style);
    return i2.id && (s2.id = i2.id), s2;
  }
};
var IIRecognizedPolyLine = class _IIRecognizedPolyLine extends IIRecognizedBase {
  constructor(i2, r2) {
    super(T.PolyEdge, i2, r2);
    __publicField(this, "isClosed", false);
  }
  clone() {
    const i2 = new _IIRecognizedPolyLine(this.strokes.map((i3) => i3.clone()), structuredClone({ ...this.style }));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, kind: this.kind, strokes: JSON.parse(JSON.stringify(this.strokes)) };
  }
  static create(i2) {
    var _a;
    if (!((_a = i2.strokes) == null ? void 0 : _a.length)) throw new Error("no strokes");
    const r2 = i2.strokes.map((i3) => IIStroke.create(i3)), s2 = new _IIRecognizedPolyLine(r2, i2.style);
    return i2.id && (s2.id = i2.id), s2;
  }
};
var IIRecognizedPolygon = class _IIRecognizedPolygon extends IIRecognizedBase {
  constructor(i2, r2) {
    super(T.Polygone, i2, r2);
    __publicField(this, "isClosed", true);
  }
  clone() {
    const i2 = new _IIRecognizedPolygon(this.strokes.map((i3) => i3.clone()), structuredClone({ ...this.style }));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, kind: this.kind, strokes: JSON.parse(JSON.stringify(this.strokes)) };
  }
  static create(i2) {
    var _a;
    if (!((_a = i2.strokes) == null ? void 0 : _a.length)) throw new Error("no strokes");
    const r2 = i2.strokes.map((i3) => IIStroke.create(i3)), s2 = new _IIRecognizedPolygon(r2, i2.style);
    return i2.id && (s2.id = i2.id), s2;
  }
};
var IIRecognizedText = class _IIRecognizedText extends IIRecognizedBase {
  constructor(i2, r2, s2) {
    super(T.Text, i2, s2);
    __publicField(this, "isClosed", false);
    __publicField(this, "decorators");
    __publicField(this, "baseline");
    __publicField(this, "xHeight");
    __publicField(this, "label");
    this.baseline = r2.baseline, this.xHeight = r2.xHeight, this.decorators = [];
  }
  clone() {
    const i2 = new _IIRecognizedText(this.strokes.map((i3) => i3.clone()), { baseline: this.baseline, xHeight: this.xHeight }, structuredClone({ ...this.style }));
    return i2.id = this.id, i2.label = this.label, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2.decorators = this.decorators.map((i3) => i3.clone()), i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, kind: this.kind, label: this.label, baseline: this.baseline, xHeight: this.xHeight, strokes: JSON.parse(JSON.stringify(this.strokes)), decorators: this.decorators.length ? JSON.parse(JSON.stringify(this.decorators)) : void 0 };
  }
  static create(i2) {
    var _a, _b2;
    if (!((_a = i2.strokes) == null ? void 0 : _a.length)) throw new Error("no strokes");
    const r2 = i2.strokes.map((i3) => IIStroke.create(i3)), s2 = { baseline: i2.baseline || 0, xHeight: i2.xHeight || 0 }, n2 = new _IIRecognizedText(r2, s2, i2.style);
    return ((_b2 = i2.decorators) == null ? void 0 : _b2.length) && i2.decorators.forEach((i3) => {
      (i3 == null ? void 0 : i3.kind) && n2.decorators.push(new IIDecorator(i3.kind, Object.assign({}, n2.style, i3.style)));
    }), i2.id && (n2.id = i2.id), n2;
  }
};
var IISymbolGroup = class _IISymbolGroup extends IISymbolBase {
  constructor(i2, r2) {
    super(E.Group, r2);
    __publicField(this, "isClosed", false);
    __publicField(this, "children");
    __publicField(this, "decorators");
    this.children = i2, this.decorators = [];
  }
  get snapPoints() {
    return this.bounds.snapPoints;
  }
  get vertices() {
    return this.children.flatMap((i2) => i2.vertices);
  }
  get bounds() {
    return Box.createFromBoxes(this.children.map((i2) => i2.bounds));
  }
  updateChildrenStyle() {
    this.children.forEach((i2) => {
      switch (i2.style = Object.assign({}, i2.style, this.style), i2.type) {
        case E.Group:
          i2.updateChildrenStyle();
          break;
        case E.Text:
          i2.chars.forEach((r2) => {
            i2.style.color && (r2.color = i2.style.color);
          });
          break;
        case E.Recognized:
          i2.updateChildrenStyle();
      }
    });
  }
  overlaps(i2) {
    return this.children.some((r2) => r2.overlaps(i2));
  }
  containsSymbol(i2) {
    return _IISymbolGroup.containsSymbol(this, i2);
  }
  containsOnlyStroke() {
    return _IISymbolGroup.containsOnlyStroke(this);
  }
  extractText() {
    return _IISymbolGroup.extractText(this);
  }
  extractStrokes() {
    return _IISymbolGroup.extractStrokes(this);
  }
  removeChilds(i2) {
    return _IISymbolGroup.removeChilds(this, i2);
  }
  static containsOnlyStroke(i2) {
    return i2.children.every((i3) => i3.type === E.Group ? _IISymbolGroup.containsOnlyStroke(i3) : i3.type === E.Stroke);
  }
  static extractText(i2) {
    const r2 = [];
    return i2.children.forEach((i3) => {
      switch (i3.type) {
        case E.Text:
          r2.push(i3);
          break;
        case E.Group:
          r2.push(..._IISymbolGroup.extractText(i3));
      }
    }), r2;
  }
  static extractStrokes(i2) {
    const r2 = [];
    return i2.children.forEach((i3) => {
      switch (i3.type) {
        case E.Stroke:
          r2.push(i3);
          break;
        case E.Recognized:
          r2.push(...i3.strokes);
          break;
        case E.Group:
          r2.push(..._IISymbolGroup.extractStrokes(i3));
      }
    }), r2;
  }
  static containsSymbol(i2, r2) {
    return i2.children.some((i3) => i3.id === r2 || (i3.type === E.Group ? _IISymbolGroup.containsSymbol(i3, r2) : i3.type === E.Recognized && i3.containsStroke(r2)));
  }
  static removeChilds(i2, r2) {
    i2.children = i2.children.filter((i3) => !r2.includes(i3.id));
    return i2.children.slice().forEach((s2) => {
      s2.type === E.Group ? s2.removeChilds(r2).children.length || (i2.children = i2.children.filter((i3) => i3.id !== s2.id)) : s2.type === E.Recognized && (s2.removeStrokes(r2), s2.strokes.length || i2.removeChilds([s2.id]));
    }), i2;
  }
  clone() {
    const i2 = new _IISymbolGroup(this.children.map((i3) => i3.clone()), structuredClone({ ...this.style }));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2.decorators = this.decorators.map((i3) => i3.clone()), i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, children: JSON.parse(JSON.stringify(this.children)), decorators: this.decorators.length ? JSON.parse(JSON.stringify(this.decorators)) : void 0 };
  }
};
var IIText = class _IIText extends IISymbolBase {
  constructor(i2, r2, s2, n2) {
    super(E.Text, n2);
    __publicField(this, "isClosed", true);
    __publicField(this, "point");
    __publicField(this, "chars");
    __publicField(this, "decorators");
    __publicField(this, "bounds");
    __publicField(this, "rotation");
    this.point = r2, this.bounds = new Box(s2), this.chars = i2, this.decorators = [];
  }
  get label() {
    return this.chars.map((i2) => i2.label).join("");
  }
  get vertices() {
    if (this.rotation) {
      const i2 = this.rotation.center, r2 = convertDegreeToRadian(-this.rotation.degree);
      return this.bounds.corners.map((s2) => computeRotatedPoint(s2, i2, r2));
    }
    return this.bounds.corners;
  }
  get snapPoints() {
    const i2 = this.bounds.yMax - this.point.y, r2 = [{ x: this.bounds.x, y: this.bounds.yMin + i2 }, { x: this.bounds.xMax, y: this.bounds.yMin + i2 }, { x: this.bounds.xMax, y: this.bounds.yMax - i2 }, { x: this.bounds.x, y: this.bounds.yMax - i2 }, this.bounds.center];
    if (this.rotation) {
      const i3 = this.rotation.center, s2 = convertDegreeToRadian(-this.rotation.degree);
      return r2.map((r3) => computeRotatedPoint(r3, i3, s2));
    }
    return r2;
  }
  getCharCorners(i2) {
    const r2 = new Box(i2.bounds);
    if (this.rotation) {
      const i3 = this.rotation.center, s2 = convertDegreeToRadian(-this.rotation.degree);
      return r2.corners.map((r3) => computeRotatedPoint(r3, i3, s2));
    }
    return r2.corners;
  }
  updateChildrenStyle() {
    this.chars.forEach((i2) => {
      this.style.color && (i2.color = this.style.color);
    }), this.modificationDate = Date.now();
  }
  updateChildrenFont({ fontSize: i2, fontWeight: r2 }) {
    this.chars.forEach((s2) => {
      i2 && (s2.fontSize = i2), r2 && (s2.fontWeight = r2);
    }), this.modificationDate = Date.now();
  }
  getCharsOverlaps(i2) {
    return this.chars.filter((r2) => {
      const s2 = this.getCharCorners(r2);
      return i2.some((i3) => isPointInsidePolygon(i3, s2));
    });
  }
  overlaps(i2) {
    return this.vertices.some((r2) => Box.containsPoint(i2, r2)) || this.edges.some((r2) => Box.getSides(i2).some((i3) => !!findIntersectionBetween2Segment(r2, i3)));
  }
  clone() {
    const i2 = new _IIText(structuredClone(this.chars), structuredClone(this.point), this.bounds, structuredClone(this.style));
    return i2.id = this.id, i2.selected = this.selected, i2.deleting = this.deleting, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2.decorators = this.decorators.map((i3) => i3.clone()), i2.rotation = this.rotation ? structuredClone(this.rotation) : void 0, i2;
  }
  toJSON() {
    return { id: this.id, type: this.type, point: this.point, chars: this.chars, style: this.style, rotation: this.rotation, bounds: this.bounds, decorators: this.decorators.length ? this.decorators : void 0 };
  }
  static create(i2) {
    var _a, _b2;
    if (!isValidPoint(i2 == null ? void 0 : i2.point)) throw new Error("Unable to create a IIText, point are invalid");
    if (!((_a = i2.chars) == null ? void 0 : _a.length)) throw new Error("Unable to create a IIText, no chars");
    if (!i2.bounds) throw new Error("Unable to create a IIText, no boundingBox");
    const r2 = new _IIText(i2.chars, i2.point, i2.bounds, i2.style);
    return i2.id && (r2.id = i2.id), ((_b2 = i2.decorators) == null ? void 0 : _b2.length) && i2.decorators.forEach((i3) => {
      (i3 == null ? void 0 : i3.kind) && r2.decorators.push(new IIDecorator(i3.kind, Object.assign({}, r2.style, i3.style)));
    }), r2;
  }
};
var L = { color: "grey", fill: "none", width: 12, opacity: 0.2 };
var IIEraser = class _IIEraser extends IISymbolBase {
  constructor() {
    super(E.Eraser, L);
    __publicField(this, "isClosed", false);
    __publicField(this, "pointers");
    this.id = `${this.type}-${createUUID()}`, this.creationTime = Date.now(), this.modificationDate = this.creationTime, this.pointers = [];
  }
  get bounds() {
    return Box.createFromPoints(this.vertices);
  }
  get vertices() {
    return this.pointers;
  }
  get snapPoints() {
    return [];
  }
  clone() {
    const i2 = new _IIEraser();
    return i2.id = this.id, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2.pointers = structuredClone(this.pointers), i2;
  }
  overlaps(i2) {
    return this.pointers.some((r2) => r2.x >= i2.x && r2.x <= i2.x + i2.width && r2.y >= i2.y && r2.y <= i2.y + i2.height);
  }
  toJSON() {
    return { id: this.id, pointers: this.pointers, style: this.style };
  }
};
var Stroke = class _Stroke {
  constructor(i2, r2 = "pen") {
    __publicField(this, "type", E.Stroke);
    __publicField(this, "id");
    __publicField(this, "creationTime");
    __publicField(this, "modificationDate");
    __publicField(this, "style");
    __publicField(this, "pointerType");
    __publicField(this, "pointers");
    __publicField(this, "length");
    this.id = `${this.type}-${createUUID()}`, this.creationTime = Date.now(), this.modificationDate = this.creationTime, this.style = i2, this.pointerType = r2, this.pointers = [], this.length = 0;
  }
  clone() {
    const i2 = new _Stroke(this.style, this.pointerType);
    return i2.id = this.id, i2.creationTime = this.creationTime, i2.modificationDate = this.modificationDate, i2.pointers = structuredClone(this.pointers), i2.length = this.length, i2;
  }
  formatToSend() {
    const i2 = { id: this.id, pointerType: this.pointerType, p: [], t: [], x: [], y: [] };
    return this.pointers.forEach((r2) => {
      i2.p.push(r2.p), i2.t.push(r2.t), i2.x.push(r2.x), i2.y.push(r2.y);
    }), i2;
  }
};
function convertPartialStrokesToStrokes(i2) {
  const r2 = [], s2 = [];
  if (i2.forEach((i3, n2) => {
    var _a, _b2;
    let a2 = true;
    const l2 = new Stroke(i3.style || b, i3.pointerType);
    if (i3.id && (l2.id = i3.id), !((_a = i3.pointers) == null ? void 0 : _a.length)) return r2.push(`stroke ${n2 + 1} has not pointers`), void (a2 = false);
    (_b2 = i3.pointers) == null ? void 0 : _b2.forEach((i4, s3) => {
      if (!i4) return r2.push(`stroke ${n2 + 1} has no pointer at ${s3}`), void (a2 = false);
      const d2 = { p: i4.p || 1, t: i4.t || s3, x: 0, y: 0 };
      return null == (i4 == null ? void 0 : i4.x) || null == (i4 == null ? void 0 : i4.x) ? (r2.push(`stroke ${n2 + 1} has no x at pointer at ${s3}`), void (a2 = false)) : (d2.x = i4.x, null == (i4 == null ? void 0 : i4.y) || null == (i4 == null ? void 0 : i4.y) ? (r2.push(`stroke ${n2 + 1} has no y at pointer at ${s3}`), void (a2 = false)) : (d2.y = i4.y, void (a2 && l2.pointers.push(d2))));
    }), a2 && s2.push(l2);
  }), r2.length) throw new Error(r2.join("\n"));
  return s2;
}
var _t3;
var _Model = class _Model {
  constructor(i2 = 100, r2 = 100, s2 = 0, n2 = Date.now()) {
    __publicField(this, "creationTime");
    __publicField(this, "modificationDate");
    __publicField(this, "positions");
    __publicField(this, "currentSymbol");
    __publicField(this, "symbols");
    __publicField(this, "exports");
    __publicField(this, "converts");
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "rowHeight");
    __publicField(this, "idle");
    __privateAdd(this, _t3, LoggerManager.getLogger(d.MODEL));
    __privateGet(this, _t3).info("constructor", { width: i2, height: r2, creationDate: n2 }), this.creationTime = n2, this.modificationDate = n2, this.width = i2, this.height = r2, this.rowHeight = s2, this.symbols = [], this.positions = { lastSentPosition: 0, lastReceivedPosition: 0 }, this.idle = true;
  }
  computePressure(i2, r2) {
    let s2 = 1;
    i2 === r2 ? s2 = 1 : i2 < 10 ? s2 = 0.2 + Math.pow(0.1 * i2, 0.4) : i2 > r2 - 10 && (s2 = 0.2 + Math.pow(0.1 * (r2 - i2), 0.4));
    const n2 = s2 * Math.max(0.1, 1 - 0.1 * Math.sqrt(i2));
    return isNaN(n2) ? 0.5 : Math.round(100 * n2) / 100;
  }
  filterPointByAcquisitionDelta(i2, r2, s2) {
    const n2 = 2 + (i2.style["-myscript-pen-width"] || 0) / 4;
    return !s2 || 0 === i2.pointers.length || Math.abs(s2.x - r2.x) >= n2 || Math.abs(s2.y - r2.y) >= n2;
  }
  getStrokeFromPoint(i2) {
    __privateGet(this, _t3).info("getStrokeFromPoint", { point: i2 });
    const isBetween2 = (i3, r3, s2) => i3 >= r3 && i3 <= s2, r2 = [];
    return this.symbols.forEach((s2) => {
      for (let n2 = 0; n2 < s2.pointers.length; n2++) {
        const a2 = s2.pointers[n2];
        if (isBetween2(a2.x, i2.x - 5, i2.x + 5) && isBetween2(a2.y, i2.y - 5, i2.y + 5)) {
          r2.push(s2);
          break;
        }
        if (computeDistance(i2, a2) < 10) {
          r2.push(s2);
          break;
        }
      }
    }), __privateGet(this, _t3).debug("getStrokeFromPoint", { strokes: r2 }), r2;
  }
  addPoint(i2, r2) {
    __privateGet(this, _t3).debug("addPoint", { stroke: i2, pointer: r2 });
    const s2 = i2.pointers.at(-1);
    if (this.filterPointByAcquisitionDelta(i2, r2, s2)) {
      const n2 = s2 ? computeDistance(r2, s2) : 0;
      i2.length += n2, r2.p = this.computePressure(n2, i2.length), i2.pointers.push(r2), i2.modificationDate = Date.now();
    }
  }
  addStroke(i2) {
    __privateGet(this, _t3).info("addStroke", { stroke: i2 }), this.symbols.push(i2), this.modificationDate = Date.now(), this.converts = void 0, this.exports = void 0;
  }
  updateStroke(i2) {
    __privateGet(this, _t3).info("updateStroke", { updatedStroke: i2 });
    const r2 = this.symbols.findIndex((r3) => r3.id === i2.id);
    -1 !== r2 && (i2.modificationDate = Date.now(), this.symbols.splice(r2, 1, i2), this.modificationDate = Date.now(), this.converts = void 0, this.exports = void 0), __privateGet(this, _t3).debug("updateStroke", this.symbols);
  }
  removeStroke(i2) {
    __privateGet(this, _t3).info("removeStroke", { id: i2 });
    const r2 = this.symbols.findIndex((r3) => r3.id === i2);
    -1 !== r2 && (this.positions.lastSentPosition--, this.positions.lastReceivedPosition--, this.symbols.splice(r2, 1), this.modificationDate = Date.now(), this.converts = void 0, this.exports = void 0), __privateGet(this, _t3).debug("removeStroke", this.symbols);
  }
  removeStrokesFromPoint(i2) {
    __privateGet(this, _t3).info("removeStrokesFromPoint", { point: i2 });
    const r2 = this.getStrokeFromPoint(i2);
    return r2.forEach((i3) => {
      this.removeStroke(i3.id);
    }), __privateGet(this, _t3).debug("removeStrokesFromPoint", r2.map((i3) => i3.id)), r2.map((i3) => i3.id);
  }
  extractUnsentStrokes() {
    return this.symbols.slice(this.positions.lastSentPosition);
  }
  initCurrentStroke(i2, r2, s2, n2 = 96) {
    if (__privateGet(this, _t3).info("initCurrentStroke", { point: i2, pointerType: r2, style: s2, dpi: n2 }), s2["-myscript-pen-width"]) {
      const i3 = s2["-myscript-pen-width"] * n2 / 25.4;
      s2.width = i3 / 2;
    }
    this.modificationDate = Date.now(), this.exports = void 0, this.currentSymbol = new Stroke(s2, r2), __privateGet(this, _t3).debug("initCurrentStroke", this.currentSymbol), this.addPoint(this.currentSymbol, i2);
  }
  appendToCurrentStroke(i2) {
    __privateGet(this, _t3).info("appendToCurrentStroke", { point: i2 }), this.currentSymbol && this.addPoint(this.currentSymbol, i2), __privateGet(this, _t3).debug("appendToCurrentStroke", this.currentSymbol);
  }
  endCurrentStroke(i2) {
    __privateGet(this, _t3).info("endCurrentStroke", { point: i2 }), this.currentSymbol && (this.addPoint(this.currentSymbol, i2), this.addStroke(this.currentSymbol), this.currentSymbol = void 0), __privateGet(this, _t3).debug("endCurrentStroke", this.currentSymbol);
  }
  updatePositionSent(i2 = this.symbols.length) {
    __privateGet(this, _t3).info("updatePositionSent", { position: i2 }), this.positions.lastSentPosition = i2, __privateGet(this, _t3).debug("updatePositionSent", this.positions.lastSentPosition);
  }
  updatePositionReceived() {
    __privateGet(this, _t3).info("updatePositionReceived"), this.positions.lastReceivedPosition = this.positions.lastSentPosition, __privateGet(this, _t3).debug("updatePositionReceived", this.positions.lastReceivedPosition);
  }
  mergeExport(i2) {
    __privateGet(this, _t3).info("mergeExport", { exports: i2 }), this.exports ? Object.assign(this.exports, i2) : this.exports = i2, __privateGet(this, _t3).debug("mergeExport", this.exports);
  }
  mergeConvert(i2) {
    __privateGet(this, _t3).info("mergeConvert", { converts: i2 }), this.converts ? Object.assign(this.converts, i2) : this.converts = i2, __privateGet(this, _t3).debug("mergeConvert", this.converts);
  }
  clone() {
    __privateGet(this, _t3).info("clone");
    const i2 = new _Model(this.width, this.height, this.rowHeight, this.creationTime);
    return i2.modificationDate = JSON.parse(JSON.stringify(this.modificationDate)), i2.currentSymbol = this.currentSymbol ? this.currentSymbol.clone() : void 0, i2.symbols = this.symbols.map((i3) => i3.clone()), i2.positions = JSON.parse(JSON.stringify(this.positions)), i2.exports = this.exports ? JSON.parse(JSON.stringify(this.exports)) : void 0, i2.converts = this.converts ? JSON.parse(JSON.stringify(this.converts)) : void 0, i2.idle = this.idle, __privateGet(this, _t3).debug("clone", { clonedModel: i2 }), i2;
  }
  clear() {
    __privateGet(this, _t3).info("clear"), this.modificationDate = Date.now(), this.currentSymbol = void 0, this.symbols = [], this.positions.lastSentPosition = 0, this.positions.lastReceivedPosition = 0, this.exports = void 0, this.converts = void 0, this.idle = true;
  }
};
_t3 = new WeakMap();
var Model = _Model;
var _t4;
var _IIModel = class _IIModel {
  constructor(i2 = 100, r2 = 100, s2 = 0, n2 = Date.now()) {
    __privateAdd(this, _t4, LoggerManager.getLogger(d.MODEL));
    __publicField(this, "creationTime");
    __publicField(this, "modificationDate");
    __publicField(this, "currentSymbol");
    __publicField(this, "symbols");
    __publicField(this, "exports");
    __publicField(this, "converts");
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "rowHeight");
    __publicField(this, "idle");
    this.creationTime = n2, this.modificationDate = n2, this.width = i2, this.height = r2, this.rowHeight = s2, this.symbols = [], this.exports = void 0, this.converts = void 0, this.idle = true;
  }
  get symbolsSelected() {
    return this.symbols.filter((i2) => i2.selected);
  }
  get symbolsToDelete() {
    return this.symbols.filter((i2) => i2.deleting);
  }
  selectSymbol(i2) {
    const r2 = this.symbols.find((r3) => r3.id === i2 || r3.type === E.Group && r3.containsSymbol(i2));
    r2 && (r2.selected = true);
  }
  unselectSymbol(i2) {
    const r2 = this.symbols.find((r3) => r3.id === i2);
    r2 && (r2.selected = false);
  }
  resetSelection() {
    this.symbols.forEach((i2) => i2.selected = false);
  }
  getRootSymbol(i2) {
    return this.symbols.find((r2) => r2.id === i2 || r2.type === E.Group && r2.containsSymbol(i2) || r2.type === E.Recognized && r2.containsStroke(i2) ? r2 : void 0);
  }
  getSymbolRowIndex(i2) {
    return Math.round((i2.type === E.Recognized && i2.kind === T.Text ? i2.baseline : i2.bounds.yMid) / this.rowHeight);
  }
  getSymbolsByRowOrdered() {
    const i2 = [];
    return this.symbols.forEach((r2) => {
      const s2 = this.getSymbolRowIndex(r2), n2 = i2.find((i3) => i3.rowIndex === s2);
      n2 ? n2.symbols.push(r2) : i2.push({ rowIndex: s2, symbols: [r2] });
    }), i2.forEach((i3) => {
      i3.symbols.sort((i4, r2) => i4.bounds.xMid - r2.bounds.xMid);
    }), i2.sort((i3, r2) => i3.rowIndex - r2.rowIndex);
  }
  roundToLineGuide(i2) {
    return Math.round(i2 / this.rowHeight) * this.rowHeight;
  }
  isSymbolAbove(i2, r2) {
    return this.getSymbolRowIndex(i2) > this.getSymbolRowIndex(r2);
  }
  isSymbolInRow(i2, r2) {
    return this.getSymbolRowIndex(i2) === this.getSymbolRowIndex(r2);
  }
  isSymbolBelow(i2, r2) {
    return this.getSymbolRowIndex(i2) < this.getSymbolRowIndex(r2);
  }
  getFirstSymbol(i2) {
    if (i2.length) return i2.reduce((i3, r2) => {
      if (i3) {
        if (this.getSymbolRowIndex(i3) < this.getSymbolRowIndex(r2)) return i3;
        if (this.getSymbolRowIndex(i3) == this.getSymbolRowIndex(r2) && i3.bounds.xMid < r2.bounds.xMid) return i3;
      }
      return r2;
    });
  }
  getLastSymbol(i2) {
    if (i2.length) return i2.reduce((i3, r2) => {
      if (i3) {
        if (this.getSymbolRowIndex(i3) > this.getSymbolRowIndex(r2)) return i3;
        if (this.getSymbolRowIndex(i3) < this.getSymbolRowIndex(r2)) return r2;
        if (i3.bounds.xMid > r2.bounds.xMid) return i3;
      }
      return r2;
    });
  }
  addSymbol(i2) {
    __privateGet(this, _t4).info("addSymbol", { symbol: i2 });
    if (this.symbols.findIndex((r2) => r2.id === i2.id) > -1) throw new Error(`Symbol id already exist: ${i2.id}`);
    this.symbols.push(i2), this.modificationDate = Date.now(), this.converts = void 0, this.exports = void 0, __privateGet(this, _t4).debug("addSymbol", this.symbols);
  }
  updateSymbol(i2) {
    __privateGet(this, _t4).info("updateSymbol", { updatedSymbol: i2 });
    const r2 = this.symbols.findIndex((r3) => r3.id === i2.id);
    -1 !== r2 && (i2.modificationDate = Date.now(), this.symbols.splice(r2, 1, i2), this.modificationDate = Date.now(), this.converts = void 0, this.exports = void 0), __privateGet(this, _t4).debug("updateSymbol", this.symbols);
  }
  replaceSymbol(i2, r2) {
    const s2 = this.symbols.findIndex((r3) => r3.id === i2);
    -1 !== s2 && (this.symbols.splice(s2, 1, ...r2), this.modificationDate = Date.now(), this.converts = void 0, this.exports = void 0);
  }
  changeOrderSymbol(i2, r2) {
    const s2 = this.symbols.findIndex((r3) => r3.id === i2);
    if (s2 > -1) {
      let i3 = s2;
      switch (r2) {
        case "first":
          i3 = 0;
          break;
        case "last":
          i3 = this.symbols.length - 1;
          break;
        case "forward":
          i3 = Math.min(i3 + 1, this.symbols.length - 1);
          break;
        case "backward":
          i3 = Math.max(i3 - 1, 0);
      }
      const n2 = this.symbols.splice(s2, 1)[0];
      this.symbols.splice(i3, 0, n2);
    }
  }
  removeSymbol(i2) {
    __privateGet(this, _t4).info("removeSymbol", { id: i2 });
    const r2 = this.symbols.findIndex((r3) => r3.id === i2);
    -1 !== r2 && (this.symbols.splice(r2, 1), this.modificationDate = Date.now(), this.converts = void 0, this.exports = void 0), __privateGet(this, _t4).debug("removeSymbol", this.symbols);
  }
  extractDifferenceSymbols(i2) {
    return { added: this.symbols.filter((r2) => -1 === i2.symbols.findIndex((i3) => r2.id === i3.id && r2.modificationDate === i3.modificationDate)), removed: i2.symbols.filter((i3) => -1 === this.symbols.findIndex((r2) => i3.id === r2.id && i3.modificationDate === r2.modificationDate)) };
  }
  mergeExport(i2) {
    __privateGet(this, _t4).info("mergeExport", { exports: i2 }), this.exports ? Object.assign(this.exports, i2) : this.exports = i2, __privateGet(this, _t4).debug("mergeExport", this.exports);
  }
  clone() {
    __privateGet(this, _t4).info("clone");
    const i2 = new _IIModel(this.width, this.height, this.rowHeight, this.creationTime);
    return i2.modificationDate = this.modificationDate, i2.symbols = this.symbols.map((i3) => {
      const r2 = i3.clone();
      return r2.selected = false, r2;
    }), i2.exports = structuredClone(this.exports), i2.idle = this.idle, __privateGet(this, _t4).debug("clone", { clonedModel: i2 }), i2;
  }
  clear() {
    __privateGet(this, _t4).info("clear"), this.modificationDate = Date.now(), this.symbols = [], this.currentSymbol = void 0, this.exports = void 0, this.converts = void 0, this.idle = true;
  }
};
_t4 = new WeakMap();
var IIModel = _IIModel;
var P = { scheme: "https", host: "cloud.myscript.com", applicationKey: "", hmacKey: "", version: "" };
var R = { ...P, websocket: { pingEnabled: true, pingDelay: 15e3, maxPingLostCount: 20, autoReconnect: true, maxRetryCount: 2, fileChunkSize: 3e5 } };
var D = { "erase-precisely": false };
var A = { types: ["text", "shape"], "match-text-size": true };
var z = { convert: A, eraser: D, mimeTypes: ["application/vnd.myscript.jiix"] };
var G = { "bounding-box": false, strokes: false, ids: false, "full-stroke-ids": false, text: { chars: false, words: true, lines: false } };
var B = { "image-resolution": 300, jiix: G };
var O = { top: 20, left: 10, right: 10, bottom: 10 };
var N = { enable: true, "fractional-part-digits": 3, "decimal-separator": ".", "rounding-mode": "half up", "angle-unit": "deg" };
var $ = { mode: "stroke" };
var j = { solver: N, margin: O, eraser: D, "undo-redo": $, mimeTypes: ["application/vnd.myscript.jiix"] };
var V = { recognition: { types: ["text", "math", "shape", "decoration"] }, classification: { types: ["text", "math", "shape", "decoration", "drawing"] }, eraser: D };
var U = { "draw-text-boxes": false, "draw-image-boxes": false };
var H = { debug: U };
var F = { enable: true };
var W = { guides: F, eraser: D, margin: O, mimeTypes: ["application/vnd.myscript.jiix"] };
var _ = { enable: true, "line-gap-mm": 100, "origin-y-mm": 0 };
var Y = { guides: _, eraser: D, margin: O, mimeTypes: ["application/vnd.myscript.jiix"] };
var X = { force: { "on-stylesheet-change": false } };
var J = { types: ["shape"], "match-text-size": true };
var q = { enable: true };
var Z = { convert: J, eraser: D, mimeTypes: ["application/vnd.myscript.jiix"], beautification: q };
var K;
var Q;
!function(i2) {
  i2.START_INITIALIZATION = "start-initialization", i2.END_INITIALIZATION = "end-initialization", i2.CONTENT_CHANGED = "content-changed", i2.IDLE = "idle", i2.EXPORTED = "exported", i2.ERROR = "error", i2.CONNECTION_CLOSE = "connection-close", i2.SVG_PATCH = "svg-patch", i2.SESSION_OPENED = "session-opened";
}(K || (K = {}));
var RecognizerEvent = class extends EventTarget {
  constructor() {
    super();
    __publicField(this, "abortController");
    this.abortController = new AbortController();
  }
  removeAllListeners() {
    this.abortController.abort(), this.abortController = new AbortController();
  }
  emit(i2, r2) {
    const s2 = new CustomEvent(i2, Object.assign({ bubbles: true, composed: true }, r2 ? { detail: r2 } : void 0));
    this.dispatchEvent(s2);
  }
  emitStartInitialization() {
    this.emit(K.START_INITIALIZATION);
  }
  addStartInitialization(i2) {
    this.addEventListener(K.START_INITIALIZATION, () => i2(), { signal: this.abortController.signal });
  }
  emitEndtInitialization() {
    this.emit(K.END_INITIALIZATION);
  }
  addEndInitialization(i2) {
    this.addEventListener(K.END_INITIALIZATION, () => i2(), { signal: this.abortController.signal });
  }
  emitSessionOpened(i2) {
    this.emit(K.SESSION_OPENED, i2);
  }
  addSessionOpenedListener(i2) {
    this.addEventListener(K.SESSION_OPENED, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitContentChanged(i2) {
    this.emit(K.CONTENT_CHANGED, { ...i2, canClear: !i2.empty });
  }
  addContentChangedListener(i2) {
    this.addEventListener(K.CONTENT_CHANGED, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitIdle(i2) {
    this.emit(K.IDLE, i2);
  }
  addIdleListener(i2) {
    this.addEventListener(K.IDLE, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitExported(i2) {
    this.emit(K.EXPORTED, i2);
  }
  addExportedListener(i2) {
    this.addEventListener(K.EXPORTED, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitError(i2) {
    this.emit(K.ERROR, i2);
  }
  addErrorListener(i2) {
    this.addEventListener(K.ERROR, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitConnectionClose({ code: i2, message: r2 }) {
    this.emit(K.CONNECTION_CLOSE, { code: i2, message: r2 });
  }
  addConnectionCloseListener(i2) {
    this.addEventListener(K.CONNECTION_CLOSE, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
  emitSVGPatch(i2) {
    this.emit(K.SVG_PATCH, i2);
  }
  addSVGPatchListener(i2) {
    this.addEventListener(K.SVG_PATCH, (r2) => i2(r2.detail), { signal: this.abortController.signal });
  }
};
!function(i2) {
  i2.NO_ACTIVITY = "Session closed due to no activity. Without a connection on your part, it will be permanently lost after an hour.", i2.WRONG_CREDENTIALS = "Application credentials are invalid. Please check or regenerate your application key and hmackey.", i2.TOO_OLD = "Session is too old. Max Session Duration Reached.", i2.NO_SESSION_FOUND = "No sessions found. Without activation for 1 hour, sessions are deleted from the server. To avoid losing your work, use the json export, then import it this will create a new session.", i2.UNKNOW = "An unknown error has occurred.", i2.ABNORMAL_CLOSURE = "MyScript recognition server is not reachable.", i2.CANT_ESTABLISH = "Unable to establish a connection to MyScript recognition server. Check the host and your connectivity.", i2.GOING_AWAY = "MyScript recognition server is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.", i2.PROTOCOL_ERROR = "MyScript recognition server terminated the connection due to a protocol error.", i2.UNSUPPORTED_DATA = "MyScript recognition server terminated the connection because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)", i2.INVALID_FRAME_PAYLOAD = "MyScript recognition server terminated the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message).", i2.POLICY_VIOLATION = "MyScript recognition server terminated the connection because it received a message that violates its policy.", i2.MESSAGE_TOO_BIG = "MyScript recognition server terminated the connection because a data frame was received that is too large.", i2.INTERNAL_ERROR = "MyScript recognition server terminated the connection because it encountered an unexpected condition that prevented it from fulfilling the request.", i2.SERVICE_RESTART = "MyScript recognition server terminated the connection because it is restarting.", i2.TRY_AGAIN = "MyScript recognition server terminated the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients.", i2.BAD_GATEWAY = "MyScript recognition server was acting as a gateway or proxy and received an invalid response from the upstream server.", i2.TLS_HANDSHAKE = "MyScript recognition server connection was closed due to a failure to perform a TLS handshake";
}(Q || (Q = {}));
var ee = { export: B, math: j, diagram: z, "raw-content": V, renderer: H, text: W, type: "TEXT", lang: "en_US" };
var te = { server: P, recognition: ee };
var RecognizerHTTPV1Configuration = class {
  constructor(i2) {
    __publicField(this, "recognition");
    __publicField(this, "server");
    var _a, _b2, _c2, _d6, _e2, _f2, _g2, _h2, _i2, _j, _k2, _l2, _m5, _n2, _o2, _p2, _q2, _r4, _s2, _t35, _u2;
    this.server = mergeDeep({}, te.server, i2 == null ? void 0 : i2.server), this.recognition = mergeDeep({}, te.recognition, i2 == null ? void 0 : i2.recognition), ((_b2 = (_a = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _a.text) == null ? void 0 : _b2.mimeTypes) && (this.recognition.text.mimeTypes = i2.recognition.text.mimeTypes), this.recognition.text.mimeTypes = [...new Set(this.recognition.text.mimeTypes)], ((_d6 = (_c2 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _c2.math) == null ? void 0 : _d6.mimeTypes) && (this.recognition.math.mimeTypes = i2.recognition.math.mimeTypes), this.recognition.math.mimeTypes = [...new Set(this.recognition.math.mimeTypes)], ((_f2 = (_e2 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _e2.diagram) == null ? void 0 : _f2.mimeTypes) && (this.recognition.diagram.mimeTypes = i2.recognition.diagram.mimeTypes), this.recognition.diagram.mimeTypes = [...new Set(this.recognition.diagram.mimeTypes)], ((_i2 = (_h2 = (_g2 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _g2.diagram) == null ? void 0 : _h2.convert) == null ? void 0 : _i2.types) && (this.recognition.diagram.convert.types = i2.recognition.diagram.convert.types), ((_l2 = (_k2 = (_j = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _j["raw-content"]) == null ? void 0 : _k2.recognition) == null ? void 0 : _l2.types) && (this.recognition["raw-content"].recognition.types = (_o2 = (_n2 = (_m5 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _m5["raw-content"]) == null ? void 0 : _n2.recognition) == null ? void 0 : _o2.types), this.recognition["raw-content"].recognition.types = [...new Set(this.recognition["raw-content"].recognition.types.filter((i3) => "decoration" !== i3))], ((_r4 = (_q2 = (_p2 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _p2["raw-content"]) == null ? void 0 : _q2.classification) == null ? void 0 : _r4.types) && (this.recognition["raw-content"].classification.types = (_u2 = (_t35 = (_s2 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _s2["raw-content"]) == null ? void 0 : _t35.classification) == null ? void 0 : _u2.types), this.server.version && (isVersionSuperiorOrEqual(this.server.version, "2.3.0") || delete this.recognition.convert, isVersionSuperiorOrEqual(this.server.version, "3.2.0") || delete this.recognition.export.jiix.text.lines);
  }
};
var _t5;
var RecognizerHTTPV1 = class {
  constructor(i2) {
    __privateAdd(this, _t5, LoggerManager.getLogger(d.RECOGNIZER));
    __publicField(this, "configuration");
    __privateGet(this, _t5).info("constructor", { config: i2 }), this.configuration = new RecognizerHTTPV1Configuration(i2);
  }
  get url() {
    return `${this.configuration.server.scheme}://${this.configuration.server.host}/api/v4.0/iink/batch`;
  }
  get postConfig() {
    switch (this.configuration.recognition.type) {
      case "DIAGRAM":
        return { lang: this.configuration.recognition.lang, diagram: this.configuration.recognition.diagram, export: this.configuration.recognition.export };
      case "MATH":
        return { lang: this.configuration.recognition.lang, math: this.configuration.recognition.math, export: this.configuration.recognition.export };
      case "Raw Content":
        return { lang: this.configuration.recognition.lang, "raw-content": this.configuration.recognition["raw-content"], export: this.configuration.recognition.export };
      case "TEXT":
        return { lang: this.configuration.recognition.lang, text: this.configuration.recognition.text, export: this.configuration.recognition.export };
      default:
        throw new Error(`get postConfig error Recognition type unkow "${this.configuration.recognition.type}"`);
    }
  }
  buildData(i2) {
    __privateGet(this, _t5).info("buildData", { model: i2 });
    const r2 = [];
    i2.symbols.forEach((i3) => {
      const s3 = r2.findIndex((r3) => {
        return s4 = r3.penStyle, n3 = i3.style, s4 && n3 && s4["-myscript-pen-fill-color"] === n3["-myscript-pen-fill-color"] && s4["-myscript-pen-fill-style"] === n3["-myscript-pen-fill-style"] && s4["-myscript-pen-width"] === n3["-myscript-pen-width"] && s4.color === n3.color && s4.width === n3.width;
        var s4, n3;
      });
      s3 > -1 ? r2[s3].strokes.push(i3) : r2.push({ penStyle: i3.style, strokes: [i3] });
    });
    const s2 = [];
    r2.forEach((i3) => {
      const r3 = { penStyle: "{}" === JSON.stringify(i3.penStyle) ? void 0 : v.penStyleToCSS(i3.penStyle), strokes: i3.strokes.map((i4) => i4.formatToSend()) };
      s2.push(r3);
    });
    const n2 = "Raw Content" === this.configuration.recognition.type ? "Raw Content" : this.configuration.recognition.type.charAt(0).toUpperCase() + this.configuration.recognition.type.slice(1).toLowerCase(), a2 = { configuration: this.postConfig, xDPI: 96, yDPI: 96, contentType: n2, height: i2.height, width: i2.width, strokeGroups: s2 };
    return __privateGet(this, _t5).debug("buildData", { data: a2 }), a2;
  }
  async post(i2, r2) {
    __privateGet(this, _t5).info("post", { data: i2, mimeType: r2 });
    const s2 = new Headers();
    s2.append("Accept", "application/json," + r2), s2.append("applicationKey", this.configuration.server.applicationKey);
    try {
      const r3 = await computeHmac(JSON.stringify(i2), this.configuration.server.applicationKey, this.configuration.server.hmacKey);
      s2.append("hmac", r3);
    } catch (i3) {
      __privateGet(this, _t5).error("post.computeHmac", i3);
    }
    s2.append("Content-Type", "application/json"), this.configuration.server.version || (this.configuration.server.version = (await getApiInfos(this.configuration)).version), isVersionSuperiorOrEqual(this.configuration.server.version, "2.0.4") && (s2.append("myscript-client-name", "iink-ts"), s2.append("myscript-client-version", "3.0.1")), isVersionSuperiorOrEqual(this.configuration.server.version, "2.3.0") || delete this.configuration.recognition.convert, isVersionSuperiorOrEqual(this.configuration.server.version, "3.2.0") || delete this.configuration.recognition.export.jiix.text.lines;
    const n2 = { method: "POST", headers: s2, body: JSON.stringify(i2) }, a2 = new Request(this.url, n2), l2 = await fetch(a2);
    if (l2.ok) {
      let i3;
      switch (l2.headers.get("content-type")) {
        case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
        case "image/png":
        case "image/jpeg":
          i3 = await l2.blob();
          break;
        case "application/json":
          i3 = await l2.json();
          break;
        case "application/vnd.myscript.jiix":
          i3 = await l2.clone().json().catch(async () => await l2.text());
          break;
        default:
          i3 = await l2.text();
      }
      return __privateGet(this, _t5).debug("post", { result: i3 }), i3;
    }
    {
      const i3 = await l2.json();
      throw __privateGet(this, _t5).error("post", { err: i3 }), i3;
    }
  }
  async tryFetch(i2, r2) {
    return __privateGet(this, _t5).debug("tryFetch", { data: i2, mimeType: r2 }), this.post(i2, r2).then((i3) => {
      const s2 = {};
      return s2[r2] = i3, __privateGet(this, _t5).debug("tryFetch", { exports: s2 }), s2;
    }).catch((s2) => {
      __privateGet(this, _t5).error("tryFetch", { data: i2, mimeType: r2, err: s2 });
      let n2 = s2.message || Q.UNKNOW;
      s2.code ? "access.not.granted" === s2.code && (n2 = Q.WRONG_CREDENTIALS) : n2 = Q.CANT_ESTABLISH;
      throw new Error(n2);
    });
  }
  getMimeTypes(i2) {
    __privateGet(this, _t5).info("getMimeTypes", { requestedMimeTypes: i2 });
    let r2 = i2 || [];
    if (!r2.length) switch (this.configuration.recognition.type) {
      case "DIAGRAM":
        r2 = this.configuration.recognition.diagram.mimeTypes;
        break;
      case "MATH":
        r2 = this.configuration.recognition.math.mimeTypes;
        break;
      case "Raw Content":
        r2 = ["application/vnd.myscript.jiix"];
        break;
      case "TEXT":
        r2 = this.configuration.recognition.text.mimeTypes;
        break;
      default:
        throw new Error(`Recognition type "${this.configuration.recognition.type}" is unknown.
 Possible types are:
 -DIAGRAM
 -MATH
 -Raw Content
 -TEXT`);
    }
    return r2;
  }
  async convert(i2, r2, s2) {
    __privateGet(this, _t5).info("convert", { model: i2, conversionState: r2, requestedMimeTypes: s2 });
    const n2 = i2.clone(), a2 = this.getMimeTypes(s2), l2 = this.buildData(n2);
    l2.conversionState = r2;
    const d2 = a2.map((i3) => this.tryFetch(l2, i3));
    return (await Promise.all(d2)).forEach((i3) => {
      n2.mergeConvert(i3);
    }), __privateGet(this, _t5).debug("convert", { model: n2 }), n2;
  }
  async export(i2, r2) {
    __privateGet(this, _t5).info("export", { model: i2, requestedMimeTypes: r2 });
    const s2 = i2.clone();
    if (0 === s2.symbols.length) return Promise.resolve(s2);
    const n2 = this.getMimeTypes(r2);
    if (!n2.length) return __privateGet(this, _t5).error("export", { model: i2, requestedMimeTypes: r2, "Export failed, no mimeTypes define in recognition configuration": String }), Promise.reject(new Error("Export failed, no mimeTypes define in recognition configuration"));
    const a2 = n2.filter((i3) => !s2.exports || !s2.exports[i3]), l2 = this.buildData(i2);
    return (await Promise.all(a2.map((i3) => this.tryFetch(l2, i3)))).forEach((i3) => {
      s2.mergeExport(i3);
    }), __privateGet(this, _t5).debug("export", { model: s2 }), s2;
  }
  async resize(i2) {
    return __privateGet(this, _t5).info("resize", { model: i2 }), this.export(i2);
  }
};
_t5 = new WeakMap();
var ie = { export: B, math: j, shape: Z, "raw-content": V, text: Y, type: "TEXT", lang: "en_US" };
var re = { server: P, recognition: ie };
var RecognizerHTTPV2Configuration = class {
  constructor(i2) {
    __publicField(this, "recognition");
    __publicField(this, "server");
    var _a, _b2, _c2, _d6, _e2, _f2, _g2, _h2, _i2, _j, _k2, _l2, _m5, _n2, _o2, _p2, _q2, _r4;
    this.server = mergeDeep({}, re.server, i2 == null ? void 0 : i2.server), this.recognition = mergeDeep({}, re.recognition, i2 == null ? void 0 : i2.recognition), ((_b2 = (_a = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _a.text) == null ? void 0 : _b2.mimeTypes) && (this.recognition.text.mimeTypes = i2.recognition.text.mimeTypes), this.recognition.text.mimeTypes = [...new Set(this.recognition.text.mimeTypes)], ((_d6 = (_c2 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _c2.math) == null ? void 0 : _d6.mimeTypes) && (this.recognition.math.mimeTypes = i2.recognition.math.mimeTypes), this.recognition.math.mimeTypes = [...new Set(this.recognition.math.mimeTypes)], ((_f2 = (_e2 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _e2.shape) == null ? void 0 : _f2.mimeTypes) && (this.recognition.shape.mimeTypes = i2.recognition.shape.mimeTypes), this.recognition.shape.mimeTypes = [...new Set(this.recognition.shape.mimeTypes)], ((_i2 = (_h2 = (_g2 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _g2["raw-content"]) == null ? void 0 : _h2.recognition) == null ? void 0 : _i2.types) && (this.recognition["raw-content"].recognition.types = (_l2 = (_k2 = (_j = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _j["raw-content"]) == null ? void 0 : _k2.recognition) == null ? void 0 : _l2.types), ((_o2 = (_n2 = (_m5 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _m5["raw-content"]) == null ? void 0 : _n2.classification) == null ? void 0 : _o2.types) && (this.recognition["raw-content"].classification.types = (_r4 = (_q2 = (_p2 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _p2["raw-content"]) == null ? void 0 : _q2.classification) == null ? void 0 : _r4.types), this.server.version && (isVersionSuperiorOrEqual(this.server.version, "2.3.0") || delete this.recognition.convert, isVersionSuperiorOrEqual(this.server.version, "3.2.0") || delete this.recognition.export.jiix.text.lines);
  }
};
var _t6;
var RecognizerHTTPV2 = class {
  constructor(i2) {
    __privateAdd(this, _t6, LoggerManager.getLogger(d.RECOGNIZER));
    __publicField(this, "configuration");
    __privateGet(this, _t6).info("constructor", { config: i2 }), this.configuration = new RecognizerHTTPV2Configuration(i2);
  }
  get url() {
    return `${this.configuration.server.scheme}://${this.configuration.server.host}/api/v4.0/iink/recognize`;
  }
  get postConfig() {
    switch (this.configuration.recognition.type) {
      case "SHAPE":
        return { lang: this.configuration.recognition.lang, diagram: this.configuration.recognition.shape, export: this.configuration.recognition.export };
      case "MATH":
        return { lang: this.configuration.recognition.lang, math: this.configuration.recognition.math, export: this.configuration.recognition.export };
      case "Raw Content":
        return { lang: this.configuration.recognition.lang, "raw-content": this.configuration.recognition["raw-content"], export: this.configuration.recognition.export };
      case "TEXT":
        return { lang: this.configuration.recognition.lang, text: this.configuration.recognition.text, export: this.configuration.recognition.export };
      default:
        throw new Error(`get postConfig error Recognition type unkow "${this.configuration.recognition.type}"`);
    }
  }
  formatStrokes(i2) {
    return i2.map((i3) => ({ id: i3.id, pointerType: i3.pointerType, p: i3.pointers.map((i4) => i4.p), t: i3.pointers.map((i4) => i4.t), x: i3.pointers.map((i4) => i4.x), y: i3.pointers.map((i4) => i4.y) }));
  }
  buildData(i2) {
    __privateGet(this, _t6).info("buildData", { strokes: i2 });
    const r2 = "Raw Content" === this.configuration.recognition.type ? "Raw Content" : this.configuration.recognition.type.charAt(0).toUpperCase() + this.configuration.recognition.type.slice(1).toLowerCase(), s2 = { configuration: this.postConfig, scaleX: 0.265, scaleY: 0.265, contentType: r2, strokes: this.formatStrokes(i2) };
    return __privateGet(this, _t6).debug("buildData", { data: s2 }), s2;
  }
  async post(i2, r2) {
    __privateGet(this, _t6).info("post", { data: i2, mimeType: r2 });
    const s2 = new Headers();
    s2.append("Accept", r2), s2.append("applicationKey", this.configuration.server.applicationKey);
    try {
      const r3 = await computeHmac(JSON.stringify(i2), this.configuration.server.applicationKey, this.configuration.server.hmacKey);
      s2.append("hmac", r3);
    } catch (i3) {
      __privateGet(this, _t6).error("post.computeHmac", i3);
    }
    s2.append("Content-Type", "application/json"), this.configuration.server.version || (this.configuration.server.version = (await getApiInfos(this.configuration)).version), this.configuration.server.version && isVersionSuperiorOrEqual(this.configuration.server.version, "2.0.4") && (s2.append("myscript-client-name", "iink-ts"), s2.append("myscript-client-version", "3.0.1"));
    const n2 = { method: "POST", headers: s2, body: JSON.stringify(i2) }, a2 = new Request(this.url, n2), l2 = await fetch(a2);
    if (l2.ok) {
      let i3;
      switch (l2.headers.get("content-type")) {
        case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
        case "image/png":
        case "image/jpeg":
          i3 = await l2.blob();
          break;
        case "application/json":
          i3 = await l2.json();
          break;
        case "application/vnd.myscript.jiix":
          i3 = await l2.clone().json().catch(async () => await l2.text());
          break;
        default:
          i3 = await l2.text();
      }
      return __privateGet(this, _t6).debug("post", { result: i3 }), i3;
    }
    {
      const i3 = await l2.json();
      throw __privateGet(this, _t6).error("post", { err: i3 }), i3;
    }
  }
  async tryFetch(i2, r2) {
    return __privateGet(this, _t6).debug("tryFetch", { data: i2, mimeType: r2 }), this.post(i2, r2).then((i3) => {
      const s2 = {};
      return s2[r2] = i3, __privateGet(this, _t6).debug("tryFetch", { exports: s2 }), s2;
    }).catch((s2) => {
      __privateGet(this, _t6).error("tryFetch", { data: i2, mimeType: r2, err: s2 });
      let n2 = s2.message || Q.UNKNOW;
      s2.code ? "access.not.granted" === s2.code && (n2 = Q.WRONG_CREDENTIALS) : n2 = Q.CANT_ESTABLISH;
      throw new Error(n2);
    });
  }
  getMimeTypes(i2) {
    __privateGet(this, _t6).info("getMimeTypes", { requestedMimeTypes: i2 });
    let r2 = i2 || [];
    if (!r2.length) switch (this.configuration.recognition.type) {
      case "SHAPE":
        r2 = this.configuration.recognition.shape.mimeTypes;
        break;
      case "MATH":
        r2 = this.configuration.recognition.math.mimeTypes;
        break;
      case "Raw Content":
        r2 = ["application/vnd.myscript.jiix"];
        break;
      case "TEXT":
        r2 = this.configuration.recognition.text.mimeTypes;
        break;
      default:
        throw new Error(`Recognition type "${this.configuration.recognition.type}" is unknown.
 Possible types are:
 -DIAGRAM
 -MATH
 -Raw Content
 -TEXT
 -SHAPE`);
    }
    return r2;
  }
  async send(i2) {
    __privateGet(this, _t6).info("send", i2);
    let r2 = {};
    if (0 === i2.length) return Promise.resolve(r2);
    if (this.configuration.recognition.type) {
      const s2 = this.getMimeTypes();
      if (!s2.length) {
        const i3 = new Error("send failed, no mimeTypes define in recognition configuration");
        return __privateGet(this, _t6).error("send", i3), Promise.reject(i3);
      }
      const n2 = this.buildData(i2);
      (await Promise.all(s2.map((i3) => this.tryFetch(n2, i3)))).forEach((i3) => {
        Object.assign(r2, i3);
      });
    } else {
      const s2 = this.buildData(i2);
      r2 = await this.tryFetch(s2, "application/vnd.myscript.jiix");
    }
    return __privateGet(this, _t6).debug("send", r2), r2;
  }
};
_t6 = new WeakMap();
var oe;
!function(i2) {
  i2.HMAC_Challenge = "hmacChallenge", i2.Authenticated = "authenticated", i2.SessionDescription = "sessionDescription", i2.NewPart = "newPart", i2.PartChanged = "partChanged", i2.ContentChanged = "contentChanged", i2.Idle = "idle", i2.Pong = "pong", i2.Exported = "exported", i2.GestureDetected = "gestureDetected", i2.ContextlessGesture = "contextlessGesture", i2.Error = "error";
}(oe || (oe = {}));
var se = null;
try {
  ne = "undefined" != typeof module && "function" == typeof module.require && module.require("worker_threads") || "function" == typeof __non_webpack_require__ && __non_webpack_require__("worker_threads") || "function" == typeof __require && require_worker_threads();
  se = ne.Worker;
} catch (i2) {
}
var ne;
function createBase64WorkerFactory$2(i2, r2, s2) {
  var n2 = function decodeBase64$1(i3, r3) {
    return Buffer.from(i3, "base64").toString("utf8");
  }(i2), a2 = n2.indexOf("\n", 10) + 1, l2 = n2.substring(a2) + "";
  return function WorkerFactory(i3) {
    return new se(l2, Object.assign({}, i3, { eval: true }));
  };
}
function createURL(i2, r2, s2) {
  var n2 = function decodeBase64(i3, r3) {
    return atob(i3);
  }(i2), a2 = n2.indexOf("\n", 10) + 1, l2 = n2.substring(a2) + "", d2 = new Blob([l2], { type: "application/javascript" });
  return URL.createObjectURL(d2);
}
var ae = "[object process]" === Object.prototype.toString.call("undefined" != typeof process ? process : 0);
var le = function createBase64WorkerFactory(i2, r2, s2) {
  return /* @__PURE__ */ function isNodeJS() {
    return ae;
  }() ? createBase64WorkerFactory$2(i2) : /* @__PURE__ */ function createBase64WorkerFactory$1(i3, r3, s3) {
    var n2;
    return function WorkerFactory(r4) {
      return n2 = n2 || createURL(i3), new Worker(n2, r4);
    };
  }(i2);
}("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7c2VsZi5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwoZT0+e3NldEludGVydmFsKCgoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOiJwaW5nIn0pfSksZS5kYXRhLnBpbmdEZWxheSl9KSl9KCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpbmcud29ya2VyLmpzLm1hcAoK");
var de = { export: { jiix: { "bounding-box": true, "full-stroke-ids": true, ids: true, strokes: false, text: { chars: true, words: true, lines: true } } }, "raw-content": { recognition: { types: ["text", "shape"] }, classification: { types: ["text", "shape"] }, gestures: ["underline", "scratch-out", "join", "insert", "strike-through", "surround"] }, lang: "en_US", gesture: { enable: true, ignoreGestureStrokes: false } };
var he = { server: R, recognition: de };
var RecognizerWebSocketConfiguration = class {
  constructor(i2) {
    __publicField(this, "server");
    __publicField(this, "recognition");
    var _a, _b2, _c2, _d6, _e2, _f2, _g2, _h2;
    this.server = mergeDeep({}, he.server, i2 == null ? void 0 : i2.server), this.recognition = mergeDeep({}, he.recognition, i2 == null ? void 0 : i2.recognition), this.recognition.export.jiix["full-stroke-ids"] = true, this.recognition.export.jiix.ids = true, this.recognition.export.jiix.text.words = true, this.recognition.export.jiix.text.chars = true, this.recognition.export.jiix.text.lines = true, this.recognition.export.jiix["bounding-box"] = true, ((_c2 = (_b2 = (_a = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _a["raw-content"]) == null ? void 0 : _b2.recognition) == null ? void 0 : _c2.types) && (this.recognition["raw-content"].recognition.types = i2.recognition["raw-content"].recognition.types), ((_f2 = (_e2 = (_d6 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _d6["raw-content"]) == null ? void 0 : _e2.classification) == null ? void 0 : _f2.types) && (this.recognition["raw-content"].classification.types = i2.recognition["raw-content"].classification.types), ((_h2 = (_g2 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _g2["raw-content"]) == null ? void 0 : _h2.gestures) && (this.recognition["raw-content"].gestures = i2.recognition["raw-content"].gestures), this.server.version && !isVersionSuperiorOrEqual(this.server.version, "3.2.0") && (delete this.recognition.export.jiix.text.lines, delete this.recognition["raw-content"].classification);
  }
};
var _t7, _RecognizerWebSocket_instances, a_fn;
var RecognizerWebSocket = class {
  constructor(i2, r2) {
    __privateAdd(this, _RecognizerWebSocket_instances);
    __privateAdd(this, _t7, LoggerManager.getLogger(d.RECOGNIZER));
    __publicField(this, "socket");
    __publicField(this, "pingWorker");
    __publicField(this, "pingCount", 0);
    __publicField(this, "reconnectionCount", 0);
    __publicField(this, "sessionId");
    __publicField(this, "currentPartId");
    __publicField(this, "currentErrorCode");
    __publicField(this, "addStrokeDeferred");
    __publicField(this, "contextlessGestureDeferred");
    __publicField(this, "transformStrokeDeferred");
    __publicField(this, "eraseStrokeDeferred");
    __publicField(this, "replaceStrokeDeferred");
    __publicField(this, "exportDeferredMap");
    __publicField(this, "closeDeferred");
    __publicField(this, "waitForIdleDeferred");
    __publicField(this, "undoDeferred");
    __publicField(this, "redoDeferred");
    __publicField(this, "clearDeferred");
    __publicField(this, "configuration");
    __publicField(this, "initialized");
    __publicField(this, "url");
    __publicField(this, "event");
    __privateGet(this, _t7).info("constructor", { config: i2 }), this.configuration = new RecognizerWebSocketConfiguration(i2);
    const s2 = "https" === this.configuration.server.scheme ? "wss" : "ws";
    this.url = `${s2}://${this.configuration.server.host}/api/v4.0/iink/offscreen?applicationKey=${this.configuration.server.applicationKey}`, this.event = r2 || new RecognizerEvent(), this.initialized = new DeferredPromise(), this.exportDeferredMap = /* @__PURE__ */ new Map(), this.contextlessGestureDeferred = /* @__PURE__ */ new Map();
  }
  get mimeTypes() {
    return ["application/vnd.myscript.jiix"];
  }
  rejectDeferredPending(i2) {
    var _a, _b2, _c2, _d6, _e2, _f2, _g2, _h2;
    this.initialized.reject(i2), (_a = this.addStrokeDeferred) == null ? void 0 : _a.reject(i2), (_b2 = this.transformStrokeDeferred) == null ? void 0 : _b2.reject(i2), (_c2 = this.eraseStrokeDeferred) == null ? void 0 : _c2.reject(i2), (_d6 = this.replaceStrokeDeferred) == null ? void 0 : _d6.reject(i2), (_e2 = this.undoDeferred) == null ? void 0 : _e2.reject(i2), (_f2 = this.redoDeferred) == null ? void 0 : _f2.reject(i2), (_g2 = this.clearDeferred) == null ? void 0 : _g2.reject(i2), Array.from(this.contextlessGestureDeferred.values()).forEach((r2) => {
      r2.reject(i2);
    }), Array.from(this.exportDeferredMap.values()).forEach((r2) => {
      r2.reject(i2);
    }), (_h2 = this.waitForIdleDeferred) == null ? void 0 : _h2.reject(i2);
  }
  resetAllDeferred() {
    this.initialized = new DeferredPromise(), this.addStrokeDeferred = void 0, this.contextlessGestureDeferred.clear(), this.transformStrokeDeferred = void 0, this.eraseStrokeDeferred = void 0, this.replaceStrokeDeferred = void 0, this.exportDeferredMap.clear(), this.waitForIdleDeferred = void 0, this.closeDeferred = void 0;
  }
  clearSocketListener() {
    this.socket.removeEventListener("open", this.openCallback.bind(this)), this.socket.removeEventListener("close", this.closeCallback.bind(this)), this.socket.removeEventListener("message", this.messageCallback.bind(this));
  }
  closeCallback(i2) {
    var _a, _b2;
    __privateGet(this, _t7).info("closeCallback", { evt: i2 });
    let r2 = i2.reason;
    if (!this.currentErrorCode) switch (i2.code) {
      case 1e3:
        break;
      case 1001:
        r2 = Q.GOING_AWAY;
        break;
      case 1002:
        r2 = Q.PROTOCOL_ERROR;
        break;
      case 1003:
        r2 = Q.UNSUPPORTED_DATA;
        break;
      case 1006:
        r2 = Q.ABNORMAL_CLOSURE;
        break;
      case 1007:
        r2 = Q.INVALID_FRAME_PAYLOAD;
        break;
      case 1008:
        r2 = Q.POLICY_VIOLATION;
        break;
      case 1009:
        r2 = Q.MESSAGE_TOO_BIG;
        break;
      case 1011:
        r2 = Q.INTERNAL_ERROR;
        break;
      case 1012:
        r2 = Q.SERVICE_RESTART;
        break;
      case 1013:
        r2 = Q.TRY_AGAIN;
        break;
      case 1014:
        r2 = Q.BAD_GATEWAY;
        break;
      case 1015:
        r2 = Q.TLS_HANDSHAKE;
        break;
      default:
        r2 = Q.CANT_ESTABLISH;
    }
    if (this.clearSocketListener(), (_a = this.closeDeferred) == null ? void 0 : _a.resolve(), !this.currentErrorCode && 1e3 !== i2.code) {
      const i3 = new Error(r2);
      this.event.emitError(i3), this.rejectDeferredPending(r2);
    }
    (_b2 = this.pingWorker) == null ? void 0 : _b2.terminate(), this.resetAllDeferred();
  }
  openCallback() {
    this.reconnectionCount = 0, __privateMethod(this, _RecognizerWebSocket_instances, a_fn).call(this, { type: "authenticate", "myscript-client-name": "iink-ts", "myscript-client-version": "3.0.1" });
  }
  async manageHMACChallenge(i2) {
    __privateMethod(this, _RecognizerWebSocket_instances, a_fn).call(this, { type: "hmac", hmac: await computeHmac(i2.hmacChallenge, this.configuration.server.applicationKey, this.configuration.server.hmacKey) });
  }
  initPing() {
    this.pingWorker = new le(), this.pingWorker.postMessage({ pingDelay: this.configuration.server.websocket.pingDelay }), this.pingWorker.onmessage = () => {
      var _a;
      this.socket.readyState <= 1 && (this.pingCount < this.configuration.server.websocket.maxPingLostCount ? this.send({ type: "ping" }) : (this.close(1e3, "MAXIMUM_PING_REACHED"), (_a = this.pingWorker) == null ? void 0 : _a.terminate()), this.pingCount++);
    };
  }
  manageAuthenticated() {
    isVersionSuperiorOrEqual(this.configuration.server.version, "3.2.0") || (delete this.configuration.recognition.export.jiix.text.lines, delete this.configuration.recognition["raw-content"].classification);
    const i2 = 25.4 / 96;
    __privateMethod(this, _RecognizerWebSocket_instances, a_fn).call(this, { type: this.sessionId ? "restoreSession" : "initSession", iinkSessionId: this.sessionId, scaleX: i2, scaleY: i2, configuration: this.configuration.recognition });
  }
  manageSessionDescriptionMessage(i2) {
    i2.iinkSessionId && (this.sessionId = i2.iinkSessionId, this.event.emitSessionOpened(this.sessionId)), this.currentPartId ? __privateMethod(this, _RecognizerWebSocket_instances, a_fn).call(this, { type: "openContentPart", id: this.currentPartId }) : __privateMethod(this, _RecognizerWebSocket_instances, a_fn).call(this, { type: "newContentPart", contentType: "Raw Content", mimeTypes: this.mimeTypes });
  }
  manageNewPartMessage(i2) {
    this.initialized.resolve(), this.currentPartId = i2.id;
  }
  managePartChangeMessage(i2) {
    this.initialized.resolve(), this.currentPartId = i2.partId;
  }
  manageContentChangedMessage(i2) {
    var _a, _b2, _c2, _d6, _e2, _f2;
    this.initialized.resolve(), (_a = this.replaceStrokeDeferred) == null ? void 0 : _a.resolve(), (_b2 = this.transformStrokeDeferred) == null ? void 0 : _b2.resolve(), (_c2 = this.eraseStrokeDeferred) == null ? void 0 : _c2.resolve(), (_d6 = this.undoDeferred) == null ? void 0 : _d6.resolve(), (_e2 = this.redoDeferred) == null ? void 0 : _e2.resolve(), (_f2 = this.clearDeferred) == null ? void 0 : _f2.resolve(), this.event.emitContentChanged({ canRedo: i2.canRedo, canUndo: i2.canRedo });
  }
  manageExportMessage(i2) {
    i2.exports["application/vnd.myscript.jiix"] && (i2.exports["application/vnd.myscript.jiix"] = JSON.parse(i2.exports["application/vnd.myscript.jiix"].toString())), Object.keys(i2.exports).forEach((r2) => {
      this.exportDeferredMap.has(r2) && this.exportDeferredMap.get(r2).resolve(i2.exports);
    }), this.event.emitExported(i2.exports);
  }
  manageWaitForIdle() {
    var _a;
    (_a = this.waitForIdleDeferred) == null ? void 0 : _a.resolve(), this.event.emitIdle(true);
  }
  manageErrorMessage(i2) {
    var _a, _b2;
    this.currentErrorCode = ((_a = i2.data) == null ? void 0 : _a.code) || i2.code;
    let r2 = ((_b2 = i2.data) == null ? void 0 : _b2.message) || i2.message || Q.UNKNOW;
    if ("no.activity" === this.currentErrorCode) this.rejectDeferredPending(r2), this.event.emitConnectionClose({ code: 1e3, message: Q.NO_ACTIVITY });
    else {
      switch (this.currentErrorCode) {
        case "access.not.granted":
          r2 = Q.WRONG_CREDENTIALS;
          break;
        case "session.too.old":
          r2 = Q.TOO_OLD;
          break;
        case "restore.session.not.found":
          r2 = Q.NO_SESSION_FOUND;
      }
      this.rejectDeferredPending(r2), this.event.emitError(new Error(r2));
    }
  }
  manageGestureDetected(i2) {
    var _a;
    (_a = this.addStrokeDeferred) == null ? void 0 : _a.resolve(i2);
  }
  manageContextlessGesture(i2) {
    var _a;
    (_a = this.contextlessGestureDeferred.get(i2.strokeId)) == null ? void 0 : _a.resolve(i2);
  }
  messageCallback(i2) {
    this.currentErrorCode = void 0;
    try {
      const r2 = JSON.parse(i2.data);
      if (r2.type === oe.Pong) return;
      switch (this.pingCount = 0, r2.type) {
        case oe.HMAC_Challenge:
          this.manageHMACChallenge(r2);
          break;
        case oe.Authenticated:
          this.manageAuthenticated();
          break;
        case oe.SessionDescription:
          this.manageSessionDescriptionMessage(r2);
          break;
        case oe.NewPart:
          this.manageNewPartMessage(r2);
          break;
        case oe.PartChanged:
          this.managePartChangeMessage(r2);
          break;
        case oe.ContentChanged:
          this.manageContentChangedMessage(r2);
          break;
        case oe.Exported:
          this.manageExportMessage(r2);
          break;
        case oe.GestureDetected:
          this.manageGestureDetected(r2);
          break;
        case oe.ContextlessGesture:
          this.manageContextlessGesture(r2);
          break;
        case oe.Error:
          this.manageErrorMessage(r2);
          break;
        case oe.Idle:
          this.manageWaitForIdle();
          break;
        default:
          __privateGet(this, _t7).warn("messageCallback", `Message type unknow: "${r2}".`);
      }
    } catch {
      this.event.emitError(new Error(i2.data));
    }
  }
  async newSession(i2) {
    await this.close(1e3, "new-session"), this.configuration = mergeDeep({}, this.configuration, i2), this.sessionId = void 0, this.currentPartId = void 0, await this.init();
  }
  async init() {
    this.event.emitStartInitialization(), "restore.session.not.found" === this.currentErrorCode && (this.currentErrorCode = void 0, this.sessionId = void 0, this.currentPartId = void 0), this.initialized = new DeferredPromise(), this.configuration.server.version || (this.configuration.server.version = (await getApiInfos(this.configuration)).version), this.socket = new WebSocket(this.url), this.clearSocketListener(), this.socket.addEventListener("open", this.openCallback.bind(this)), this.socket.addEventListener("close", this.closeCallback.bind(this)), this.socket.addEventListener("message", this.messageCallback.bind(this)), await this.initialized.promise, this.configuration.server.websocket.pingEnabled && (this.pingCount = 0, this.initPing()), this.event.emitEndtInitialization();
  }
  async send(i2) {
    if (!this.socket) return Promise.reject(new Error("Recognizer must be initilized"));
    switch (this.socket.readyState) {
      case this.socket.CONNECTING:
      case this.socket.OPEN:
        return await this.initialized.promise, __privateMethod(this, _RecognizerWebSocket_instances, a_fn).call(this, i2), Promise.resolve();
      case this.socket.CLOSING:
      case this.socket.CLOSED:
        return this.configuration.server.websocket.autoReconnect ? (this.reconnectionCount++, this.configuration.server.websocket.maxRetryCount > this.reconnectionCount ? (await this.init(), await this.waitForIdle(), __privateMethod(this, _RecognizerWebSocket_instances, a_fn).call(this, i2)) : Promise.reject(new Error("Unable to send message. The maximum number of connection attempts has been reached."))) : Promise.reject(new Error("Unable to send message. Connection closed and automatic reconnection disabled"));
    }
  }
  buildAddStrokesMessage(i2, r2 = true) {
    return { type: "addStrokes", processGestures: r2, strokes: i2.map((i3) => i3.formatToSend()) };
  }
  async addStrokes(i2, r2 = true) {
    var _a, _b2;
    return this.addStrokeDeferred = new DeferredPromise(), 0 === i2.length ? (this.addStrokeDeferred.resolve(void 0), (_a = this.addStrokeDeferred) == null ? void 0 : _a.promise) : (await this.send(this.buildAddStrokesMessage(i2, r2)), (_b2 = this.addStrokeDeferred) == null ? void 0 : _b2.promise);
  }
  buildReplaceStrokesMessage(i2, r2) {
    return { type: "replaceStrokes", oldStrokeIds: i2, newStrokes: r2.map((i3) => i3.formatToSend()) };
  }
  async replaceStrokes(i2, r2) {
    var _a, _b2;
    return this.replaceStrokeDeferred = new DeferredPromise(), 0 === i2.length ? (this.replaceStrokeDeferred.resolve(), (_a = this.replaceStrokeDeferred) == null ? void 0 : _a.promise) : (await this.send(this.buildReplaceStrokesMessage(i2, r2)), (_b2 = this.replaceStrokeDeferred) == null ? void 0 : _b2.promise);
  }
  buildTransformTranslateMessage(i2, r2, s2) {
    return { type: "transform", transformationType: "TRANSLATE", strokeIds: i2, tx: r2, ty: s2 };
  }
  async transformTranslate(i2, r2, s2) {
    var _a, _b2;
    return this.transformStrokeDeferred = new DeferredPromise(), 0 === i2.length ? (this.transformStrokeDeferred.resolve(), (_a = this.transformStrokeDeferred) == null ? void 0 : _a.promise) : (await this.send(this.buildTransformTranslateMessage(i2, r2, s2)), (_b2 = this.transformStrokeDeferred) == null ? void 0 : _b2.promise);
  }
  buildTransformRotateMessage(i2, r2, s2 = 0, n2 = 0) {
    return { type: "transform", transformationType: "ROTATE", strokeIds: i2, angle: r2, x0: s2, y0: n2 };
  }
  async transformRotate(i2, r2, s2 = 0, n2 = 0) {
    var _a, _b2;
    return this.transformStrokeDeferred = new DeferredPromise(), 0 === i2.length ? (this.transformStrokeDeferred.resolve(), (_a = this.transformStrokeDeferred) == null ? void 0 : _a.promise) : (await this.send(this.buildTransformRotateMessage(i2, r2, s2, n2)), (_b2 = this.transformStrokeDeferred) == null ? void 0 : _b2.promise);
  }
  buildTransformScaleMessage(i2, r2, s2, n2 = 0, a2 = 0) {
    return { type: "transform", transformationType: "SCALE", strokeIds: i2, scaleX: r2, scaleY: s2, x0: n2, y0: a2 };
  }
  async transformScale(i2, r2, s2, n2 = 0, a2 = 0) {
    var _a, _b2;
    return this.transformStrokeDeferred = new DeferredPromise(), 0 === i2.length ? (this.transformStrokeDeferred.resolve(), (_a = this.transformStrokeDeferred) == null ? void 0 : _a.promise) : (await this.send(this.buildTransformScaleMessage(i2, r2, s2, n2, a2)), (_b2 = this.transformStrokeDeferred) == null ? void 0 : _b2.promise);
  }
  buildTransformMatrixMessage(i2, r2) {
    return { type: "transform", transformationType: "MATRIX", strokeIds: i2, ...r2 };
  }
  async transformMatrix(i2, r2) {
    var _a, _b2;
    return this.transformStrokeDeferred = new DeferredPromise(), 0 === i2.length ? (this.transformStrokeDeferred.resolve(), (_a = this.transformStrokeDeferred) == null ? void 0 : _a.promise) : (await this.send(this.buildTransformMatrixMessage(i2, r2)), (_b2 = this.transformStrokeDeferred) == null ? void 0 : _b2.promise);
  }
  buildEraseStrokesMessage(i2) {
    return { type: "eraseStrokes", strokeIds: i2 };
  }
  async eraseStrokes(i2) {
    var _a, _b2;
    return this.eraseStrokeDeferred = new DeferredPromise(), 0 === i2.length ? (this.eraseStrokeDeferred.resolve(), (_a = this.eraseStrokeDeferred) == null ? void 0 : _a.promise) : (await this.send(this.buildEraseStrokesMessage(i2)), (_b2 = this.eraseStrokeDeferred) == null ? void 0 : _b2.promise);
  }
  async recognizeGesture(i2) {
    if (!i2) return;
    this.contextlessGestureDeferred.set(i2.id, new DeferredPromise());
    const r2 = 25.4 / 96;
    return await this.send({ type: "contextlessGesture", scaleX: r2, scaleY: r2, stroke: i2.formatToSend() }), this.contextlessGestureDeferred.get(i2.id).promise;
  }
  async waitForIdle() {
    var _a;
    this.waitForIdleDeferred && !this.waitForIdleDeferred.isFullFilled || (this.waitForIdleDeferred = new DeferredPromise());
    return await this.send({ type: "waitForIdle" }), (_a = this.waitForIdleDeferred) == null ? void 0 : _a.promise;
  }
  buildUndoRedoChanges(i2) {
    var _a, _b2, _c2, _d6, _e2, _f2, _g2;
    const r2 = [];
    return ((_a = i2.added) == null ? void 0 : _a.length) && r2.push(this.buildAddStrokesMessage(i2.added, false)), ((_b2 = i2.erased) == null ? void 0 : _b2.length) && r2.push(this.buildEraseStrokesMessage(i2.erased.map((i3) => i3.id))), ((_c2 = i2.replaced) == null ? void 0 : _c2.newStrokes.length) && r2.push(this.buildReplaceStrokesMessage(i2.replaced.oldStrokes.map((i3) => i3.id), i2.replaced.newStrokes)), ((_d6 = i2.matrix) == null ? void 0 : _d6.strokes.length) && r2.push(this.buildTransformMatrixMessage(i2.matrix.strokes.map((i3) => i3.id), i2.matrix.matrix)), ((_e2 = i2.translate) == null ? void 0 : _e2.length) && i2.translate.forEach((i3) => {
      r2.push(this.buildTransformTranslateMessage(i3.strokes.map((i4) => i4.id), i3.tx, i3.ty));
    }), ((_f2 = i2.rotate) == null ? void 0 : _f2.length) && i2.rotate.forEach((i3) => {
      r2.push(this.buildTransformRotateMessage(i3.strokes.map((i4) => i4.id), i3.angle, i3.center.x, i3.center.y));
    }), ((_g2 = i2.scale) == null ? void 0 : _g2.length) && i2.scale.forEach((i3) => {
      r2.push(this.buildTransformScaleMessage(i3.strokes.map((i4) => i4.id), i3.scaleX, i3.scaleY, i3.origin.x, i3.origin.y));
    }), r2;
  }
  async undo(i2) {
    var _a;
    const r2 = this.buildUndoRedoChanges(i2);
    if (0 === r2.length) return;
    this.undoDeferred = new DeferredPromise();
    const s2 = { type: "undo", changes: r2 };
    return await this.send(s2), (_a = this.undoDeferred) == null ? void 0 : _a.promise;
  }
  async redo(i2) {
    var _a;
    const r2 = this.buildUndoRedoChanges(i2);
    if (0 === r2.length) return;
    this.redoDeferred = new DeferredPromise();
    const s2 = { type: "redo", changes: r2 };
    return await this.send(s2), (_a = this.redoDeferred) == null ? void 0 : _a.promise;
  }
  async export(i2) {
    const r2 = i2 || this.mimeTypes.slice();
    await Promise.all(r2.map((i3) => {
      var _a;
      return (_a = this.exportDeferredMap.get(i3)) == null ? void 0 : _a.promise;
    })), r2.forEach((i3) => {
      this.exportDeferredMap.set(i3, new DeferredPromise());
    });
    const s2 = { type: "export", partId: this.currentPartId, mimeTypes: r2 };
    await this.send(s2);
    const n2 = await Promise.all(r2.map((i3) => this.exportDeferredMap.get(i3).promise));
    return Object.assign({}, ...n2);
  }
  async clear() {
    var _a;
    return this.clearDeferred = new DeferredPromise(), await this.send({ type: "clear" }), (_a = this.clearDeferred) == null ? void 0 : _a.promise;
  }
  async close(i2, r2) {
    this.resetAllDeferred(), this.closeDeferred = new DeferredPromise(), this.socket.readyState === this.socket.OPEN || this.socket.readyState === this.socket.CONNECTING ? this.socket.close(i2, r2) : this.closeDeferred.resolve(), await this.closeDeferred.promise;
  }
  async destroy() {
    this.socket && await this.close(1e3, "Recognizer destroyed");
  }
};
_t7 = new WeakMap();
_RecognizerWebSocket_instances = new WeakSet();
a_fn = async function(i2) {
  if (!this.socket) throw new Error("Recognizer must be initilized");
  if (this.socket.readyState !== this.socket.OPEN) throw new Error(`Can not send message: ${i2.type}, connection not ready, state: ${this.socket.readyState}`);
  this.socket.send(JSON.stringify(i2));
};
var ce = { export: B, math: j, renderer: H, text: W, type: "TEXT", lang: "en_US" };
var ue = { server: R, recognition: ce };
var RecognizerWebSocketSSRConfiguration = class {
  constructor(i2) {
    __publicField(this, "recognition");
    __publicField(this, "server");
    var _a, _b2, _c2, _d6;
    this.server = mergeDeep({}, ue.server, i2 == null ? void 0 : i2.server), this.recognition = mergeDeep({}, ue.recognition, i2 == null ? void 0 : i2.recognition), ((_b2 = (_a = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _a.text) == null ? void 0 : _b2.mimeTypes) && (this.recognition.text.mimeTypes = i2.recognition.text.mimeTypes), this.recognition.text.mimeTypes = [...new Set(this.recognition.text.mimeTypes)], ((_d6 = (_c2 = i2 == null ? void 0 : i2.recognition) == null ? void 0 : _c2.math) == null ? void 0 : _d6.mimeTypes) && (this.recognition.math.mimeTypes = i2.recognition.math.mimeTypes), this.recognition.math.mimeTypes = [...new Set(this.recognition.math.mimeTypes)], this.server.version && (isVersionSuperiorOrEqual(this.server.version, "2.3.0") || delete this.recognition.convert, isVersionSuperiorOrEqual(this.server.version, "3.2.0") || delete this.recognition.export.jiix.text.lines);
  }
};
var _t8;
var RecognizerWebSocketSSR = class {
  constructor(i2) {
    __privateAdd(this, _t8, LoggerManager.getLogger(d.RECOGNIZER));
    __publicField(this, "socket");
    __publicField(this, "pingCount", 0);
    __publicField(this, "reconnectionCount", 0);
    __publicField(this, "viewSizeHeight");
    __publicField(this, "viewSizeWidth");
    __publicField(this, "sessionId");
    __publicField(this, "currentPartId");
    __publicField(this, "currentErrorCode");
    __publicField(this, "penStyle");
    __publicField(this, "penStyleClasses");
    __publicField(this, "theme");
    __publicField(this, "connected");
    __publicField(this, "ackDeferred");
    __publicField(this, "addStrokeDeferred");
    __publicField(this, "exportDeferred");
    __publicField(this, "convertDeferred");
    __publicField(this, "importDeferred");
    __publicField(this, "resizeDeferred");
    __publicField(this, "undoDeferred");
    __publicField(this, "redoDeferred");
    __publicField(this, "clearDeferred");
    __publicField(this, "importPointEventsDeferred");
    __publicField(this, "waitForIdleDeferred");
    __publicField(this, "configuration");
    __publicField(this, "initialized");
    __publicField(this, "url");
    __publicField(this, "event");
    __privateGet(this, _t8).info("constructor", { config: i2 }), this.configuration = new RecognizerWebSocketSSRConfiguration(i2);
    const r2 = "https" === this.configuration.server.scheme ? "wss" : "ws";
    this.url = `${r2}://${this.configuration.server.host}/api/v4.0/iink/document?applicationKey=${this.configuration.server.applicationKey}`, this.event = new RecognizerEvent(), this.initialized = new DeferredPromise();
  }
  get mimeTypes() {
    switch (this.configuration.recognition.type.toLocaleLowerCase()) {
      case "text":
        return this.configuration.recognition.text.mimeTypes;
      case "math":
        return this.configuration.recognition.math.mimeTypes;
      default:
        throw new Error(`Unauthorized recognition type: "${this.configuration.recognition.type}"`);
    }
  }
  infinitePing() {
    this.pingCount++, this.configuration.server.websocket.maxPingLostCount < this.pingCount ? this.socket.close(1e3, "MAXIMUM_PING_REACHED") : this.socket.readyState <= 1 && setTimeout(() => {
      this.socket.readyState <= 1 && (this.socket.send(JSON.stringify({ type: "ping" })), this.infinitePing());
    }, this.configuration.server.websocket.pingDelay);
  }
  openCallback() {
    var _a;
    (_a = this.connected) == null ? void 0 : _a.resolve();
    const i2 = { type: this.sessionId ? "restoreIInkSession" : "newContentPackage", iinkSessionId: this.sessionId, applicationKey: this.configuration.server.applicationKey, xDpi: 96, yDpi: 96, viewSizeHeight: this.viewSizeHeight, viewSizeWidth: this.viewSizeWidth };
    isVersionSuperiorOrEqual(this.configuration.server.version, "2.0.4") && (i2["myscript-client-name"] = "iink-ts", i2["myscript-client-version"] = "3.0.1"), this.send(i2);
  }
  rejectDeferredPending(i2) {
    var _a, _b2, _c2, _d6, _e2, _f2, _g2, _h2, _i2, _j, _k2, _l2, _m5, _n2, _o2, _p2, _q2, _r4, _s2, _t35, _u2, _v2;
    ((_a = this.connected) == null ? void 0 : _a.isPending) && ((_b2 = this.connected) == null ? void 0 : _b2.reject(i2)), this.initialized.isPending && this.initialized.reject(i2), ((_c2 = this.addStrokeDeferred) == null ? void 0 : _c2.isPending) && ((_d6 = this.addStrokeDeferred) == null ? void 0 : _d6.reject(i2)), ((_e2 = this.exportDeferred) == null ? void 0 : _e2.isPending) && ((_f2 = this.exportDeferred) == null ? void 0 : _f2.reject(i2)), ((_g2 = this.importPointEventsDeferred) == null ? void 0 : _g2.isPending) && ((_h2 = this.importPointEventsDeferred) == null ? void 0 : _h2.reject(i2)), ((_i2 = this.convertDeferred) == null ? void 0 : _i2.isPending) && ((_j = this.convertDeferred) == null ? void 0 : _j.reject(i2)), ((_k2 = this.importDeferred) == null ? void 0 : _k2.isPending) && ((_l2 = this.importDeferred) == null ? void 0 : _l2.reject(i2)), ((_m5 = this.resizeDeferred) == null ? void 0 : _m5.isPending) && ((_n2 = this.resizeDeferred) == null ? void 0 : _n2.reject(i2)), ((_o2 = this.waitForIdleDeferred) == null ? void 0 : _o2.isPending) && ((_p2 = this.waitForIdleDeferred) == null ? void 0 : _p2.reject(i2)), ((_q2 = this.undoDeferred) == null ? void 0 : _q2.isPending) && ((_r4 = this.undoDeferred) == null ? void 0 : _r4.reject(i2)), ((_s2 = this.redoDeferred) == null ? void 0 : _s2.isPending) && ((_t35 = this.redoDeferred) == null ? void 0 : _t35.reject(i2)), ((_u2 = this.clearDeferred) == null ? void 0 : _u2.isPending) && this.clearDeferred.reject(i2), ((_v2 = this.waitForIdleDeferred) == null ? void 0 : _v2.isPending) && this.waitForIdleDeferred.reject(i2);
  }
  closeCallback(i2) {
    let r2 = "";
    if (!this.currentErrorCode) switch (i2.code) {
      case 1e3:
        break;
      case 1001:
        r2 = Q.GOING_AWAY;
        break;
      case 1002:
        r2 = Q.PROTOCOL_ERROR;
        break;
      case 1003:
        r2 = Q.UNSUPPORTED_DATA;
        break;
      case 1006:
        r2 = Q.ABNORMAL_CLOSURE;
        break;
      case 1007:
        r2 = Q.INVALID_FRAME_PAYLOAD;
        break;
      case 1008:
        r2 = Q.POLICY_VIOLATION;
        break;
      case 1009:
        r2 = Q.MESSAGE_TOO_BIG;
        break;
      case 1011:
        r2 = Q.INTERNAL_ERROR;
        break;
      case 1012:
        r2 = Q.SERVICE_RESTART;
        break;
      case 1013:
        r2 = Q.TRY_AGAIN;
        break;
      case 1014:
        r2 = Q.BAD_GATEWAY;
        break;
      case 1015:
        r2 = Q.TLS_HANDSHAKE;
        break;
      default:
        __privateGet(this, _t8).warn("closeCallback", "unknow CloseEvent.code", { evt: i2 }), r2 = Q.CANT_ESTABLISH;
    }
    if (!this.currentErrorCode && 1e3 !== i2.code) {
      const s2 = new Error(r2 || i2.reason);
      this.rejectDeferredPending(s2), this.event.emitError(s2);
    }
  }
  async manageAckMessage(i2) {
    var _a;
    __privateGet(this, _t8).info("manageAckMessage", { websocketMessage: i2 });
    const r2 = i2;
    r2.hmacChallenge && this.send({ type: "hmac", hmac: await computeHmac(r2.hmacChallenge, this.configuration.server.applicationKey, this.configuration.server.hmacKey) }), r2.iinkSessionId && (this.sessionId = r2.iinkSessionId), isVersionSuperiorOrEqual(this.configuration.server.version, "2.3.0") || delete this.configuration.recognition.convert, isVersionSuperiorOrEqual(this.configuration.server.version, "3.2.0") || delete this.configuration.recognition.export.jiix.text.lines, this.send({ ...this.configuration.recognition, type: "configuration" }), (_a = this.ackDeferred) == null ? void 0 : _a.resolve();
  }
  async manageContentPackageDescriptionMessage() {
    var _a;
    this.reconnectionCount = 0, await ((_a = this.ackDeferred) == null ? void 0 : _a.promise), __privateGet(this, _t8).info("manageContentPackageDescriptionMessage"), this.currentPartId ? this.send({ type: "openContentPart", id: this.currentPartId, mimeTypes: this.mimeTypes }) : this.send({ type: "newContentPart", contentType: this.configuration.recognition.type, mimeTypes: this.mimeTypes });
  }
  managePartChangeMessage(i2) {
    __privateGet(this, _t8).info("managePartChangeMessage", { websocketMessage: i2 });
    const r2 = i2;
    this.currentPartId = r2.partId, this.initialized.resolve();
  }
  manageExportMessage(i2) {
    var _a, _b2, _c2, _d6, _e2, _f2, _g2, _h2;
    __privateGet(this, _t8).info("manageExportMessage", { websocketMessage: i2 });
    const r2 = i2;
    r2.exports["application/vnd.myscript.jiix"] && (r2.exports["application/vnd.myscript.jiix"] = JSON.parse(r2.exports["application/vnd.myscript.jiix"].toString())), this.initialized.resolve(), (_a = this.addStrokeDeferred) == null ? void 0 : _a.resolve(r2.exports), (_b2 = this.exportDeferred) == null ? void 0 : _b2.resolve(r2.exports), (_c2 = this.convertDeferred) == null ? void 0 : _c2.resolve(r2.exports), (_d6 = this.importDeferred) == null ? void 0 : _d6.resolve(r2.exports), (_e2 = this.undoDeferred) == null ? void 0 : _e2.resolve(r2.exports), (_f2 = this.redoDeferred) == null ? void 0 : _f2.resolve(r2.exports), (_g2 = this.clearDeferred) == null ? void 0 : _g2.resolve(r2.exports), (_h2 = this.importPointEventsDeferred) == null ? void 0 : _h2.resolve(r2.exports), this.event.emitExported(r2.exports);
  }
  async manageWaitForIdle() {
    var _a;
    this.event.emitIdle(true), (_a = this.waitForIdleDeferred) == null ? void 0 : _a.resolve();
  }
  manageErrorMessage(i2) {
    var _a, _b2;
    const r2 = i2;
    this.currentErrorCode = ((_a = r2.data) == null ? void 0 : _a.code) || r2.code;
    let s2 = ((_b2 = r2.data) == null ? void 0 : _b2.message) || r2.message || Q.UNKNOW;
    switch (this.currentErrorCode) {
      case "no.activity":
        s2 = Q.NO_ACTIVITY;
        break;
      case "access.not.granted":
        s2 = Q.WRONG_CREDENTIALS;
        break;
      case "session.too.old":
        s2 = Q.TOO_OLD;
    }
    const n2 = new Error(s2);
    this.rejectDeferredPending(n2), this.event.emitError(n2);
  }
  manageContentChangeMessage(i2) {
    __privateGet(this, _t8).info("manageContentChangeMessage", { websocketMessage: i2 });
    const r2 = i2, s2 = { canRedo: r2.canRedo, canUndo: r2.canUndo, empty: r2.empty, stackIndex: r2.undoStackIndex, possibleUndoCount: r2.possibleUndoCount };
    this.event.emitContentChanged(s2);
  }
  manageSVGPatchMessage(i2) {
    var _a;
    __privateGet(this, _t8).info("manageSVGPatchMessage", { websocketMessage: i2 }), (_a = this.resizeDeferred) == null ? void 0 : _a.resolve();
    const r2 = i2;
    this.event.emitSVGPatch(r2);
  }
  messageCallback(i2) {
    __privateGet(this, _t8).debug("messageCallback", { message: i2 }), this.currentErrorCode = void 0;
    const r2 = JSON.parse(i2.data);
    if ("pong" !== r2.type) switch (this.pingCount = 0, r2.type) {
      case "ack":
        this.manageAckMessage(r2);
        break;
      case "contentPackageDescription":
        this.manageContentPackageDescriptionMessage();
        break;
      case "partChanged":
        this.managePartChangeMessage(r2);
        break;
      case "newPart":
        this.initialized.resolve();
        break;
      case "contentChanged":
        this.manageContentChangeMessage(r2);
        break;
      case "exported":
        this.manageExportMessage(r2);
        break;
      case "svgPatch":
        this.manageSVGPatchMessage(r2);
        break;
      case "error":
        this.manageErrorMessage(r2);
        break;
      case "idle":
        this.manageWaitForIdle();
        break;
      default:
        __privateGet(this, _t8).warn("messageCallback", `Message type unknow: "${r2.type}".`);
    }
  }
  async init(i2, r2) {
    try {
      this.event.emitStartInitialization(), __privateGet(this, _t8).info("init", { height: i2, width: r2 }), this.destroy(), this.configuration.server.version || (this.configuration.server.version = (await getApiInfos(this.configuration)).version), this.connected = new DeferredPromise(), this.initialized = new DeferredPromise(), this.ackDeferred = new DeferredPromise(), this.viewSizeHeight = i2, this.viewSizeWidth = r2, this.pingCount = 0, this.socket = new WebSocket(this.url), this.configuration.server.websocket.pingEnabled && this.infinitePing(), this.socket.addEventListener("open", this.openCallback.bind(this)), this.socket.addEventListener("close", this.closeCallback.bind(this)), this.socket.addEventListener("message", this.messageCallback.bind(this)), this.event.emitEndtInitialization(), await this.connected.promise, await this.initialized.promise;
    } catch (i3) {
      return this.rejectDeferredPending(i3), this.initialized.promise;
    }
  }
  async send(i2) {
    var _a;
    return this.socket ? (await ((_a = this.connected) == null ? void 0 : _a.promise), this.socket.readyState === this.socket.OPEN ? (__privateGet(this, _t8).debug("send", { message: i2 }), this.socket.send(JSON.stringify(i2)), Promise.resolve()) : this.socket.readyState != this.socket.CONNECTING && this.configuration.server.websocket.autoReconnect ? (this.reconnectionCount++, this.configuration.server.websocket.maxRetryCount >= this.reconnectionCount ? (__privateGet(this, _t8).debug("send", `try to reconnect number: ${this.reconnectionCount}.`), await this.init(this.viewSizeHeight, this.viewSizeWidth), await this.setPenStyle(this.penStyle), await this.setPenStyleClasses(this.penStyleClasses), await this.setTheme(this.theme), this.send(i2)) : Promise.reject(new Error("Unable to send message. The maximum number of connection attempts has been reached."))) : void 0) : Promise.reject(new Error("Recognizer must be initilized"));
  }
  async addStrokes(i2) {
    var _a;
    return __privateGet(this, _t8).info("addStrokes", { strokes: i2 }), await this.initialized.promise, this.addStrokeDeferred = new DeferredPromise(), 0 === i2.length ? this.addStrokeDeferred.resolve({}) : await this.send({ type: "addStrokes", strokes: i2.map((i3) => i3.formatToSend()) }), (_a = this.addStrokeDeferred) == null ? void 0 : _a.promise;
  }
  async setPenStyle(i2) {
    __privateGet(this, _t8).info("setPenStyle", { penStyle: i2 }), await this.initialized.promise, this.penStyle = i2;
    const r2 = { type: "setPenStyle", style: v.penStyleToCSS(i2) };
    return this.send(r2);
  }
  async setPenStyleClasses(i2) {
    await this.initialized.promise, this.penStyleClasses = i2, __privateGet(this, _t8).info("setPenStyleClasses", { penStyleClasses: i2 });
    const r2 = { type: "setPenStyleClasses", styleClasses: i2 };
    return this.send(r2);
  }
  async setTheme(i2) {
    __privateGet(this, _t8).info("setTheme", { theme: i2 }), await this.initialized.promise, this.theme = i2;
    const r2 = { type: "setTheme", theme: v.themeToCSS(i2) };
    return this.send(r2);
  }
  async export(i2, r2) {
    var _a;
    __privateGet(this, _t8).info("export", { model: i2, requestedMimeTypes: r2 }), await this.initialized.promise, this.exportDeferred = new DeferredPromise();
    const s2 = i2.clone();
    let n2 = r2 || [];
    if (!n2.length) switch (this.configuration.recognition.type) {
      case "MATH":
        n2 = this.configuration.recognition.math.mimeTypes;
        break;
      case "TEXT":
        n2 = this.configuration.recognition.text.mimeTypes;
        break;
      default:
        throw new Error(`Recognition type "${this.configuration.recognition.type}" is unknown.
 Possible types are:
 -MATH
 -TEXT`);
    }
    if (!n2.length) return Promise.reject(new Error(`Export failed, no mimeTypes define in recognition ${this.configuration.recognition.type} configuration`));
    const a2 = { type: "export", partId: this.currentPartId, mimeTypes: n2 };
    await this.send(a2);
    const l2 = await ((_a = this.exportDeferred) == null ? void 0 : _a.promise);
    return s2.updatePositionReceived(), s2.mergeExport(l2), __privateGet(this, _t8).debug("export", { model: s2 }), s2;
  }
  async import(i2, r2, s2) {
    var _a;
    __privateGet(this, _t8).info("import", { data: r2, mimeType: s2 }), await this.initialized.promise;
    const n2 = i2.clone(), a2 = this.configuration.server.websocket.fileChunkSize, l2 = Math.random().toString(10).substring(2, 6);
    this.importDeferred = new DeferredPromise();
    const readBlob = (i3) => {
      const r3 = new FileReader();
      return new Promise((s3, n3) => {
        r3.onloadend = (i4) => {
          var _a2;
          return s3((_a2 = i4.target) == null ? void 0 : _a2.result);
        }, r3.onerror = () => n3(), r3.readAsText(i3);
      });
    }, d2 = { type: "importFile", importFileId: l2, mimeType: s2 };
    await this.send(d2);
    for (let i3 = 0; i3 < r2.size; i3 += a2) {
      const s3 = r2.slice(i3, i3 + a2, r2.type), n3 = { type: "fileChunk", importFileId: l2, data: await readBlob(s3), lastChunk: i3 + a2 > r2.size };
      await this.send(n3);
    }
    const h2 = await ((_a = this.importDeferred) == null ? void 0 : _a.promise);
    return this.importDeferred = void 0, n2.mergeExport(h2), n2;
  }
  async resize(i2) {
    var _a;
    __privateGet(this, _t8).info("resize", { model: i2 }), await this.initialized.promise, this.resizeDeferred = new DeferredPromise();
    const r2 = i2.clone();
    this.viewSizeHeight = r2.height, this.viewSizeWidth = r2.width;
    const s2 = { type: "changeViewSize", height: this.viewSizeHeight, width: this.viewSizeWidth };
    return await this.send(s2), await ((_a = this.resizeDeferred) == null ? void 0 : _a.promise), r2;
  }
  async importPointEvents(i2) {
    var _a;
    __privateGet(this, _t8).info("importPointsEvents", { strokes: i2 }), await this.initialized.promise, this.importPointEventsDeferred = new DeferredPromise();
    const r2 = { type: "pointerEvents", events: i2.map((i3) => i3.formatToSend()) };
    return await this.send(r2), (_a = this.importPointEventsDeferred) == null ? void 0 : _a.promise;
  }
  async convert(i2, r2) {
    var _a;
    __privateGet(this, _t8).info("convert", { model: i2, conversionState: r2 }), await this.initialized.promise, this.convertDeferred = new DeferredPromise();
    const s2 = i2.clone(), n2 = { type: "convert", conversionState: r2 };
    await this.send(n2);
    const a2 = await ((_a = this.convertDeferred) == null ? void 0 : _a.promise);
    return s2.updatePositionReceived(), s2.mergeConvert(a2), __privateGet(this, _t8).debug("convert", { model: s2 }), s2;
  }
  async waitForIdle() {
    var _a;
    await this.initialized.promise, this.waitForIdleDeferred = new DeferredPromise();
    return await this.send({ type: "waitForIdle" }), (_a = this.waitForIdleDeferred) == null ? void 0 : _a.promise;
  }
  async undo(i2) {
    var _a;
    __privateGet(this, _t8).info("undo", { model: i2 }), await this.initialized.promise;
    const r2 = i2.clone();
    this.undoDeferred = new DeferredPromise();
    await this.send({ type: "undo" });
    const s2 = await ((_a = this.undoDeferred) == null ? void 0 : _a.promise);
    return r2.updatePositionReceived(), r2.mergeExport(s2), __privateGet(this, _t8).debug("undo", { model: r2 }), this.undoDeferred = void 0, r2;
  }
  async redo(i2) {
    var _a;
    __privateGet(this, _t8).info("redo", { model: i2 }), await this.initialized.promise;
    const r2 = i2.clone();
    this.redoDeferred = new DeferredPromise();
    await this.send({ type: "redo" });
    const s2 = await ((_a = this.redoDeferred) == null ? void 0 : _a.promise);
    return r2.updatePositionReceived(), r2.mergeExport(s2), __privateGet(this, _t8).debug("redo", { model: s2 }), this.redoDeferred = void 0, r2;
  }
  async clear(i2) {
    var _a;
    __privateGet(this, _t8).info("clear", { model: i2 }), await this.initialized.promise;
    const r2 = i2.clone();
    r2.modificationDate = Date.now(), this.clearDeferred = new DeferredPromise();
    await this.send({ type: "clear" });
    const s2 = await ((_a = this.clearDeferred) == null ? void 0 : _a.promise);
    return r2.updatePositionReceived(), r2.mergeExport(s2), this.clearDeferred = void 0, __privateGet(this, _t8).info("clear", { model: r2 }), r2;
  }
  close(i2, r2) {
    this.socket.readyState !== this.socket.OPEN && this.socket.readyState !== this.socket.CONNECTING || (__privateGet(this, _t8).info("close", { code: i2, reason: r2 }), this.socket.removeEventListener("close", this.closeCallback), this.socket.removeEventListener("message", this.messageCallback), this.socket.removeEventListener("open", this.openCallback), this.socket.close(i2, r2));
  }
  destroy() {
    __privateGet(this, _t8).info("destroy"), this.connected = void 0, this.ackDeferred = void 0, this.addStrokeDeferred = void 0, this.exportDeferred = void 0, this.convertDeferred = void 0, this.importDeferred = void 0, this.importPointEventsDeferred = void 0, this.waitForIdleDeferred = void 0, this.resizeDeferred = void 0, this.undoDeferred = void 0, this.redoDeferred = void 0, this.clearDeferred = void 0, this.socket && (this.socket.removeEventListener("close", this.closeCallback), this.socket.removeEventListener("message", this.messageCallback), this.socket.removeEventListener("open", this.openCallback), this.close(1e3, "Recognizer destroyed"));
  }
};
_t8 = new WeakMap();
var _t9;
var CanvasRendererShape = class {
  constructor() {
    __privateAdd(this, _t9, LoggerManager.getLogger(d.RENDERER));
    __publicField(this, "symbols", { table: "table", ellipse: "ellipse", line: "line" });
  }
  phi(i2) {
    let r2 = (i2 + Math.PI) % (2 * Math.PI) - Math.PI;
    return r2 < -Math.PI && (r2 += 2 * Math.PI), __privateGet(this, _t9).debug("phi", { angle: i2, returnedAngle: r2 }), r2;
  }
  drawEllipseArc(i2, r2) {
    __privateGet(this, _t9).debug("drawEllipseArc", { context2D: i2, shapeEllipse: r2 });
    const { centerPoint: s2, maxRadius: n2, minRadius: a2, orientation: l2, startAngle: d2, sweepAngle: h2 } = r2, c2 = Math.cos(l2) * n2, u2 = Math.cos(l2) * a2, p2 = Math.sin(l2) * n2, g2 = Math.sin(l2) * a2, m2 = Math.floor(Math.abs(h2) / 0.02), y2 = [];
    i2.save();
    try {
      i2.beginPath();
      for (let r3 = 0; r3 <= m2; r3++) {
        const l3 = d2 + r3 / m2 * h2, b2 = Math.atan2(Math.sin(l3) / a2, Math.cos(l3) / n2), f2 = Math.cos(b2), x2 = Math.sin(b2), S2 = s2.x + c2 * f2 - g2 * x2, w2 = s2.y + u2 * x2 + p2 * f2;
        0 === r3 ? i2.moveTo(S2, w2) : i2.lineTo(S2, w2), 0 !== r3 && r3 !== m2 || y2.push({ x: S2, y: w2 });
      }
      i2.stroke();
    } catch (i3) {
      __privateGet(this, _t9).error("drawEllipseArc", { error: i3 });
    } finally {
      i2.restore();
    }
    return y2;
  }
  drawLine(i2, r2, s2) {
    __privateGet(this, _t9).debug("drawLine", { context2D: i2, p1: r2, p2: s2 }), i2.save();
    try {
      i2.beginPath(), i2.moveTo(r2.x, r2.y), i2.lineTo(s2.x, s2.y), i2.stroke();
    } catch (i3) {
      __privateGet(this, _t9).error("drawLine", { error: i3 });
    } finally {
      i2.restore();
    }
  }
  drawArrowHead(i2, r2, s2, n2) {
    __privateGet(this, _t9).debug("drawArrowHead", { context2D: i2, headPoint: r2, angle: s2, length: n2 });
    const a2 = this.phi(s2 + Math.PI * (7 / 8)), l2 = this.phi(s2 - Math.PI * (7 / 8));
    i2.save();
    try {
      i2.fillStyle = i2.strokeStyle, i2.moveTo(r2.x, r2.y), i2.beginPath(), i2.lineTo(r2.x + n2 * Math.cos(a2), r2.y + n2 * Math.sin(a2)), i2.lineTo(r2.x + n2 * Math.cos(l2), r2.y + n2 * Math.sin(l2)), i2.lineTo(r2.x, r2.y), i2.fill();
    } catch (i3) {
      __privateGet(this, _t9).error("drawArrowHead", { error: i3 });
    } finally {
      i2.restore();
    }
  }
  drawShapeEllipse(i2, r2) {
    __privateGet(this, _t9).debug("drawShapeEllipse", { context2D: i2, shapeEllipse: r2 });
    const s2 = this.drawEllipseArc(i2, r2);
    "ARROW_HEAD" === (r2 == null ? void 0 : r2.beginDecoration) && this.drawArrowHead(i2, s2[0], r2.beginTangentAngle, 12), "ARROW_HEAD" === (r2 == null ? void 0 : r2.endDecoration) && this.drawArrowHead(i2, s2[1], r2.endTangentAngle, 12);
  }
  drawShapeLine(i2, r2) {
    __privateGet(this, _t9).debug("drawShapeLine", { context2D: i2, shapeLine: r2 }), this.drawLine(i2, r2.firstPoint, r2.lastPoint), "ARROW_HEAD" === r2.beginDecoration && this.drawArrowHead(i2, r2.firstPoint, r2.beginTangentAngle, 12), "ARROW_HEAD" === r2.endDecoration && this.drawArrowHead(i2, r2.lastPoint, r2.endTangentAngle, 12);
  }
  draw(i2, r2) {
    switch (__privateGet(this, _t9).info("draw", { context2D: i2, symbol: r2 }), i2.save(), i2.lineWidth = r2.style.width, i2.strokeStyle = r2.style.color, r2.type) {
      case this.symbols.table:
        r2.lines.forEach((r3) => this.drawLine(i2, r3.p1, r3.p2));
        break;
      case this.symbols.ellipse:
        this.drawShapeEllipse(i2, r2);
        break;
      case this.symbols.line:
        this.drawShapeLine(i2, r2);
        break;
      default:
        __privateGet(this, _t9).warn("draw", `${r2.type} not implemented`);
    }
  }
};
_t9 = new WeakMap();
var _t10;
var CanvasRendererStroke = class {
  constructor() {
    __privateAdd(this, _t10, LoggerManager.getLogger(d.RENDERER));
  }
  renderArc(i2, r2, s2) {
    __privateGet(this, _t10).debug("renderArc", { context2d: i2, center: r2, radius: s2 }), i2.arc(r2.x, r2.y, s2, 0, 2 * Math.PI, true);
  }
  renderLine(i2, r2, s2, n2) {
    __privateGet(this, _t10).debug("renderLine", { context2d: i2, begin: r2, end: s2, width: n2 });
    const a2 = computeLinksPointers(r2, computeAngleAxeRadian(r2, s2), n2), l2 = computeLinksPointers(s2, computeAngleAxeRadian(r2, s2), n2);
    i2.moveTo(a2[0].x, a2[0].y), i2.lineTo(l2[0].x, l2[0].y), i2.lineTo(l2[1].x, l2[1].y), i2.lineTo(a2[1].x, a2[1].y);
  }
  renderFinal(i2, r2, s2, n2) {
    __privateGet(this, _t10).debug("renderFinal", { context2d: i2, begin: r2, end: s2, width: n2 });
    const a2 = computeAngleAxeRadian(r2, s2), l2 = computeLinksPointers(s2, a2, n2);
    i2.moveTo(l2[0].x, l2[0].y);
    for (let r3 = 1; r3 <= 6; r3++) {
      const l3 = a2 - r3 * Math.PI / 6;
      i2.lineTo(s2.x - s2.p * n2 * Math.sin(l3), s2.y + s2.p * n2 * Math.cos(l3));
    }
  }
  renderQuadratic(i2, r2, s2, n2, a2) {
    __privateGet(this, _t10).debug("renderQuadratic", { context2d: i2, begin: r2, end: s2, ctrl: n2, width: a2 });
    const l2 = computeLinksPointers(r2, computeAngleAxeRadian(r2, n2), a2), d2 = computeLinksPointers(s2, computeAngleAxeRadian(n2, s2), a2), h2 = computeLinksPointers(n2, computeAngleAxeRadian(r2, s2), a2);
    i2.moveTo(l2[0].x, l2[0].y), i2.quadraticCurveTo(h2[0].x, h2[0].y, d2[0].x, d2[0].y), i2.lineTo(d2[1].x, d2[1].y), i2.quadraticCurveTo(h2[1].x, h2[1].y, l2[1].x, l2[1].y);
  }
  draw(i2, r2) {
    __privateGet(this, _t10).info("draw", { context2d: i2, stroke: r2 });
    const s2 = r2.pointers.length, n2 = s2 - 2, a2 = r2.style.width > 0 ? r2.style.width : i2.lineWidth, l2 = r2.style.color ? r2.style.color : i2.strokeStyle, d2 = r2.pointers[0];
    i2.save();
    try {
      if (i2.beginPath(), s2 < 3) this.renderArc(i2, d2, 0.6 * a2);
      else {
        this.renderArc(i2, d2, a2 * d2.p);
        const l3 = computeMiddlePointer(d2, r2.pointers[1]);
        this.renderLine(i2, d2, l3, a2);
        for (let s3 = 0; s3 < n2; s3++) {
          const n3 = computeMiddlePointer(r2.pointers[s3], r2.pointers[s3 + 1]), l4 = computeMiddlePointer(r2.pointers[s3 + 1], r2.pointers[s3 + 2]), d3 = r2.pointers[s3 + 1];
          this.renderQuadratic(i2, n3, l4, d3, a2);
        }
        const h2 = computeMiddlePointer(r2.pointers[s2 - 2], r2.pointers[s2 - 1]), c2 = r2.pointers[s2 - 1];
        this.renderLine(i2, h2, c2, a2);
        const u2 = r2.pointers[s2 - 2], p2 = r2.pointers[s2 - 1];
        this.renderFinal(i2, u2, p2, a2);
      }
      i2.closePath(), void 0 !== l2 && (i2.fillStyle = l2, i2.fill()), i2.save();
    } catch (i3) {
      __privateGet(this, _t10).error("draw", { error: i3 });
    } finally {
      i2.restore();
    }
  }
};
_t10 = new WeakMap();
var _t11;
var CanvasRendererText = class {
  constructor() {
    __privateAdd(this, _t11, LoggerManager.getLogger(d.RENDERER));
    __publicField(this, "symbols", { char: "char", string: "string", textLine: "textLine" });
  }
  drawUnderline(i2, r2, s2) {
    __privateGet(this, _t11).debug("#drawUnderline", { context2D: i2, textUnderline: r2, underline: s2 }), i2.save();
    try {
      const n2 = r2.data.width / r2.label.length, a2 = { x: r2.data.topLeftPoint.x + s2.data.firstCharacter * n2, y: r2.data.topLeftPoint.y + r2.data.height }, l2 = { x: r2.data.topLeftPoint.x + s2.data.lastCharacter * n2, y: r2.data.topLeftPoint.y + r2.data.height };
      i2.beginPath(), i2.moveTo(a2.x, a2.y), i2.lineTo(l2.x, l2.y), i2.stroke();
    } catch (i3) {
      __privateGet(this, _t11).error("#drawUnderline", { error: i3 });
    } finally {
      i2.restore();
    }
  }
  drawText(i2, r2) {
    __privateGet(this, _t11).debug("#drawText", { context2D: i2, text: r2 }), i2.save();
    try {
      i2.font = `${r2.data.textHeight}px serif`, i2.textAlign = "CENTER" === r2.data.justificationType ? "center" : "left", i2.textBaseline = "bottom", i2.fillStyle = i2.strokeStyle, i2.fillText(r2.label, r2.data.topLeftPoint.x, r2.data.topLeftPoint.y + r2.data.height);
    } catch (i3) {
      __privateGet(this, _t11).error("#drawText", { error: i3 });
    } finally {
      i2.restore();
    }
  }
  drawTextLine(i2, r2) {
    __privateGet(this, _t11).debug("#drawTextLine", { context2D: i2, textUnderline: r2 }), this.drawText(i2, r2), r2.underlineList.forEach((s2) => {
      this.drawUnderline(i2, r2, s2);
    });
  }
  draw(i2, r2) {
    switch (__privateGet(this, _t11).info("draw", { context2D: i2, symbol: r2 }), i2.lineWidth = r2.style.width, i2.strokeStyle = r2.style.color, r2.type) {
      case this.symbols.char:
      case this.symbols.string:
        this.drawText(i2, r2);
        break;
      case this.symbols.textLine:
        this.drawTextLine(i2, r2);
        break;
      default:
        __privateGet(this, _t11).warn("draw", `${r2.type} not implemented`);
    }
  }
};
_t11 = new WeakMap();
var _t12;
var CanvasRenderer = class {
  constructor(i2) {
    __privateAdd(this, _t12, LoggerManager.getLogger(d.RENDERER));
    __publicField(this, "configuration");
    __publicField(this, "strokeRenderer");
    __publicField(this, "shapeRenderer");
    __publicField(this, "textRenderer");
    __publicField(this, "context");
    __privateGet(this, _t12).info("constructor", { config: i2 }), this.configuration = i2, this.strokeRenderer = new CanvasRendererStroke(), this.shapeRenderer = new CanvasRendererShape(), this.textRenderer = new CanvasRendererText();
  }
  createCanvas(i2) {
    __privateGet(this, _t12).debug("createCanvas", { type: i2 });
    const r2 = document.createElement("canvas");
    return r2.id = i2, r2.classList.add(i2), r2.classList.add("ms-canvas"), r2;
  }
  resizeContent() {
    const i2 = window.devicePixelRatio;
    [this.context.renderingCanvas, this.context.capturingCanvas].forEach((r2) => {
      var _a;
      const s2 = r2.parentNode, n2 = Math.max(this.configuration.minWidth, s2.clientWidth), a2 = Math.max(this.configuration.minHeight, s2.clientHeight);
      r2.width = n2 * i2, r2.height = a2 * i2, (_a = r2.getContext("2d")) == null ? void 0 : _a.scale(i2, i2), r2.style.width = `${n2}px`, r2.style.height = `${a2}px`;
    });
  }
  drawSymbol(i2, r2) {
    if (__privateGet(this, _t12).debug("drawSymbol", { symbol: r2 }), "stroke" === r2.type) {
      const s2 = r2;
      "eraser" !== s2.pointerType && this.strokeRenderer.draw(i2, s2);
    } else Object.keys(this.textRenderer.symbols).includes(r2.type) ? this.textRenderer.draw(i2, r2) : Object.keys(this.shapeRenderer.symbols).includes(r2.type) ? this.shapeRenderer.draw(i2, r2) : __privateGet(this, _t12).warn("drawSymbol", `symbol type unknow: ${r2.type}`);
  }
  init(i2, r2) {
    __privateGet(this, _t12).info("init", { element: i2 });
    const s2 = this.createCanvas("ms-rendering-canvas");
    s2.setAttribute("data-layer", "MODEL"), r2 && (s2.style.backgroundSize = `${r2.x || 1}px ${r2.y || 1}px`), i2.appendChild(s2);
    const n2 = this.createCanvas("ms-capture-canvas");
    n2.setAttribute("data-layer", "CAPTURE"), i2.appendChild(n2), this.context = { parent: i2, renderingCanvas: s2, renderingCanvasContext: s2.getContext("2d"), capturingCanvas: n2, capturingCanvasContext: n2.getContext("2d") }, this.resizeContent();
  }
  drawModel(i2) {
    var _a;
    __privateGet(this, _t12).info("drawModel", { model: i2 }), (_a = this.context.renderingCanvasContext) == null ? void 0 : _a.clearRect(0, 0, this.context.renderingCanvas.width, this.context.renderingCanvas.height), i2.symbols.forEach((i3) => this.drawSymbol(this.context.renderingCanvasContext, i3)), this.context.capturingCanvasContext.clearRect(0, 0, this.context.capturingCanvas.width, this.context.capturingCanvas.height);
  }
  drawPendingStroke(i2) {
    __privateGet(this, _t12).info("drawPendingStroke", { stroke: i2 }), this.context.capturingCanvasContext.clearRect(0, 0, this.context.capturingCanvas.width, this.context.capturingCanvas.height), i2 && "eraser" !== (i2 == null ? void 0 : i2.pointerType) && this.strokeRenderer.draw(this.context.capturingCanvasContext, i2);
  }
  resize(i2) {
    __privateGet(this, _t12).info("resize", { model: i2 }), this.resizeContent(), this.drawModel(i2);
  }
  destroy() {
    __privateGet(this, _t12).info("destroy"), this.context.parent && (this.context.parent.innerHTML = "");
  }
};
_t12 = new WeakMap();
var pe = { arrowHeadStartMarker: "arrow-head-start", arrowHeadEndMaker: "arrow-head-end", selectionFilterId: "selection-filter", removalFilterId: "removal-filter", crossMarker: "cross-marker", noSelection: "pointer-events: none; -webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;" };
var ge = "http://www.w3.org/2000/svg";
var SVGBuilder = class {
  static createLayer(i2, r2 = {}) {
    const s2 = document.createElementNS(ge, "svg");
    return s2.setAttribute("width", `${i2.width}px`), s2.setAttribute("height", `${i2.height}px`), s2.setAttribute("viewBox", `${i2.x}, ${i2.y}, ${i2.width}, ${i2.height}`), Object.keys(r2).forEach((i3) => {
      s2.setAttribute(i3, r2[i3]);
    }), s2;
  }
  static createFilter(i2, r2 = {}) {
    const s2 = document.createElementNS(ge, "filter");
    return s2.id = i2, Object.keys(r2).forEach((i3) => {
      s2.setAttribute(i3, r2[i3]);
    }), s2;
  }
  static createDefs() {
    return document.createElementNS(ge, "defs");
  }
  static createMarker(i2, r2 = {}) {
    const s2 = document.createElementNS(ge, "marker");
    return s2.setAttribute("id", i2), Object.keys(r2).forEach((i3) => {
      s2.setAttribute(i3, r2[i3]);
    }), s2;
  }
  static createComponentTransfert() {
    return document.createElementNS(ge, "feComponentTransfer");
  }
  static createDropShadow({ dx: i2 = 0, dy: r2 = 0, deviation: s2 = 0, color: n2 = "#3e68ff", opacity: a2 = 1 }) {
    const l2 = document.createElementNS(ge, "feDropShadow");
    return l2.setAttribute("dx", i2.toString()), l2.setAttribute("dy", r2.toString()), l2.setAttribute("stdDeviation", s2.toString()), l2.setAttribute("flood-color", n2), l2.setAttribute("flood-opacity", a2.toString()), l2;
  }
  static createTransfertFunctionTable(i2, r2) {
    const s2 = document.createElementNS(ge, i2);
    return s2.setAttribute("type", "table"), s2.setAttribute("tableValues", r2), s2;
  }
  static createGroup(i2 = {}) {
    const r2 = document.createElementNS(ge, "g");
    return Object.keys(i2).forEach((s2) => {
      r2.setAttribute(s2, i2[s2]);
    }), r2;
  }
  static createLine(i2, r2, s2 = {}) {
    const n2 = document.createElementNS(ge, "line");
    return n2.setAttribute("x1", i2.x.toString()), n2.setAttribute("y1", i2.y.toString()), n2.setAttribute("x2", r2.x.toString()), n2.setAttribute("y2", r2.y.toString()), Object.keys(s2).forEach((i3) => {
      n2.setAttribute(i3, s2[i3]);
    }), n2;
  }
  static createCircle(i2, r2, s2 = {}) {
    const n2 = document.createElementNS(ge, "circle");
    return n2.setAttribute("cx", i2.x.toString()), n2.setAttribute("cy", i2.y.toString()), n2.setAttribute("r", r2.toString()), Object.keys(s2).forEach((i3) => {
      n2.setAttribute(i3, s2[i3]);
    }), n2;
  }
  static createPath(i2 = {}) {
    const r2 = document.createElementNS(ge, "path");
    return Object.keys(i2).forEach((s2) => {
      r2.setAttribute(s2, i2[s2]);
    }), r2;
  }
  static createPolygon(i2, r2 = {}) {
    const s2 = document.createElementNS(ge, "polygon");
    return s2.setAttribute("points", i2.join(",")), Object.keys(r2).forEach((i3) => {
      s2.setAttribute(i3, r2[i3]);
    }), s2;
  }
  static createRect(i2, r2 = {}) {
    const s2 = document.createElementNS(ge, "rect");
    return s2.setAttribute("x", i2.x.toString()), s2.setAttribute("y", i2.y.toString()), s2.setAttribute("width", i2.width.toString()), s2.setAttribute("height", i2.height.toString()), Object.keys(r2).forEach((i3) => {
      s2.setAttribute(i3, r2[i3]);
    }), s2;
  }
  static createTSpan(i2, r2 = {}) {
    const s2 = document.createElementNS(ge, "tspan");
    return s2.textContent = i2, Object.keys(r2).forEach((i3) => {
      s2.setAttribute(i3, r2[i3]);
    }), s2;
  }
  static createForeignObject(i2, r2, s2 = {}) {
    const n2 = document.createElementNS(ge, "foreignObject");
    return n2.setAttribute("x", i2.x.toString()), n2.setAttribute("y", i2.y.toString()), n2.setAttribute("width", i2.width.toString()), n2.setAttribute("height", i2.height.toString()), Object.keys(s2).forEach((i3) => {
      n2.setAttribute(i3, s2[i3]);
    }), n2.appendChild(r2), n2;
  }
  static createText(i2, r2, s2 = {}) {
    const n2 = document.createElementNS(ge, "text");
    return n2.textContent = r2, n2.setAttribute("x", i2.x.toString()), n2.setAttribute("y", i2.y.toString()), Object.keys(s2).forEach((i3) => {
      n2.setAttribute(i3, s2[i3]);
    }), n2;
  }
};
var IISVGRendererEdgeUtil = class _IISVGRendererEdgeUtil {
  static getLinePath(i2) {
    return `M ${i2.start.x} ${i2.start.y} L ${i2.end.x} ${i2.end.y}`;
  }
  static getPolyLinePath(i2) {
    return `M ${i2.vertices[0].x} ${i2.vertices[0].y} ${i2.vertices.map((i3) => `L ${i3.x} ${i3.y}`).join(" ")}`;
  }
  static getArcPath(i2) {
    return `M ${i2.vertices[0].x} ${i2.vertices[0].y} Q ${i2.vertices.map((i3) => `${i3.x} ${i3.y}`).join(" ")}`;
  }
  static getSVGPath(i2) {
    switch (i2.kind) {
      case I.Line:
        return _IISVGRendererEdgeUtil.getLinePath(i2);
      case I.PolyEdge:
        return _IISVGRendererEdgeUtil.getPolyLinePath(i2);
      case I.Arc:
        return _IISVGRendererEdgeUtil.getArcPath(i2);
      default:
        throw new Error(`Can't getSVGPath for edge cause kind is unknow: "${JSON.stringify(i2)}"`);
    }
  }
  static getSVGElement(i2) {
    const r2 = { id: i2.id, type: i2.type, kind: i2.kind, "vector-effect": "non-scaling-stroke", "stroke-linecap": "round", "stroke-linejoin": "round" };
    i2.selected && (r2.filter = `url(#${pe.selectionFilterId})`), i2.deleting && (r2.filter = `url(#${pe.removalFilterId})`);
    const s2 = SVGBuilder.createGroup(r2), n2 = { fill: "transparent", stroke: i2.style.color || y.color, "stroke-width": (i2.style.width || y.width).toString(), d: _IISVGRendererEdgeUtil.getSVGPath(i2) };
    return i2.style.opacity && (n2.opacity = i2.style.opacity.toString()), i2.startDecoration === C.Arrow && (n2["marker-start"] = `url(#${pe.arrowHeadStartMarker})`), i2.endDecoration === C.Arrow && (n2["marker-end"] = `url(#${pe.arrowHeadEndMaker})`), s2.appendChild(SVGBuilder.createPath(n2)), s2;
  }
};
var IISVGRendererEraserUtil = class _IISVGRendererEraserUtil {
  static getSVGPath(i2) {
    if (i2.pointers.length < 1) return "";
    const r2 = i2.pointers.at(0), s2 = `M ${r2.x} ${r2.y}`;
    if (1 === i2.pointers.length) {
      const n2 = i2.style.width || 4;
      return `${s2} L ${r2.x + n2 / 2} ${r2.y}`;
    }
    return i2.pointers.slice(1).reduce((i3, r3) => `${i3} L ${r3.x} ${r3.y}`, s2);
  }
  static getSVGElement(i2) {
    const r2 = { id: i2.id, type: "eraser", "stroke-width": "12", stroke: "grey", opacity: "0.2", shadowBlur: "5", "stroke-linecap": "round", fill: "transparent", d: _IISVGRendererEraserUtil.getSVGPath(i2) };
    return SVGBuilder.createPath(r2);
  }
};
var IISVGRendererDecoratorUtil = class {
  static getSVGElement(i2, r2) {
    const s2 = { id: i2.id, type: "decorator", kind: i2.kind, "vector-effect": "non-scaling-stroke", "stroke-linecap": "round", "stroke-linejoin": "round" };
    let n2;
    switch (i2.style.opacity && (s2.opacity = i2.style.opacity.toString()), r2.deleting && (s2.opacity = (0.5 * (i2.style.opacity || 1)).toString()), i2.kind) {
      case k.Highlight: {
        s2.opacity = r2.deleting ? "0.25" : "0.5", s2.stroke = "transparent", s2.fill = i2.style.color || y.color;
        const a2 = { x: r2.bounds.x - +(r2.style.width || y.width), y: r2.bounds.y - +(r2.style.width || y.width), height: r2.bounds.height + 2 * +(r2.style.width || y.width), width: r2.bounds.width + 2 * +(r2.style.width || y.width) };
        n2 = SVGBuilder.createRect(a2, s2);
        break;
      }
      case k.Surround: {
        s2.fill = "transparent", s2.stroke = i2.style.color || y.color, s2["stroke-width"] = (i2.style.width || y.width).toString();
        const a2 = { x: r2.bounds.x - +(r2.style.width || y.width), y: r2.bounds.y - +(r2.style.width || y.width), height: r2.bounds.height + 2 * +(r2.style.width || y.width), width: r2.bounds.width + 2 * +(r2.style.width || y.width) };
        n2 = SVGBuilder.createRect(a2, s2);
        break;
      }
      case k.Strikethrough: {
        s2.fill = "transparent", s2.stroke = i2.style.color || y.color, s2["stroke-width"] = (i2.style.width || y.width).toString();
        const a2 = { x: r2.bounds.xMin, y: r2.bounds.yMid }, l2 = { x: r2.bounds.xMax, y: r2.bounds.yMid };
        r2.type === E.Recognized && r2.kind === T.Text && (a2.y = r2.baseline - r2.xHeight / 2, l2.y = r2.baseline - r2.xHeight / 2), n2 = SVGBuilder.createLine(a2, l2, s2);
        break;
      }
      case k.Underline: {
        s2.fill = "transparent", s2.stroke = i2.style.color || y.color, s2["stroke-width"] = (i2.style.width || y.width).toString();
        const a2 = { x: r2.bounds.xMin, y: r2.bounds.yMax + +(r2.style.width || y.width) }, l2 = { x: r2.bounds.xMax, y: r2.bounds.yMax + +(r2.style.width || y.width) };
        r2.type === E.Recognized && r2.kind === T.Text && (a2.y = r2.baseline + r2.xHeight / 2, l2.y = r2.baseline + r2.xHeight / 2), n2 = SVGBuilder.createLine(a2, l2, s2);
        break;
      }
    }
    return n2;
  }
};
var IISVGRendererShapeUtil = class _IISVGRendererShapeUtil {
  static getPolygonePath(i2) {
    return `M ${i2.points[0].x} ${i2.points[0].y} ${i2.points.slice(1).map((i3) => `L ${i3.x} ${i3.y}`).join(" ")} Z`;
  }
  static getCirclePath(i2) {
    return `M ${i2.center.x - i2.radius} ${i2.center.y} a ${i2.radius} ${i2.radius} 0 1 1 ${2 * i2.radius} 0 a ${i2.radius} ${i2.radius} 0 1 1 -${2 * i2.radius} 0 Z`;
  }
  static getEllipsePath(i2) {
    return `M ${i2.center.x - i2.radiusX} ${i2.center.y} a ${i2.radiusX} ${i2.radiusY} 0 1 1 ${2 * i2.radiusX} 0 a ${i2.radiusX} ${i2.radiusY} 0 1 1 -${2 * i2.radiusX} 0 Z`;
  }
  static getSVGPath(i2) {
    switch (i2.kind) {
      case M.Polygon:
        return _IISVGRendererShapeUtil.getPolygonePath(i2);
      case M.Circle:
        return _IISVGRendererShapeUtil.getCirclePath(i2);
      case M.Ellipse:
        return _IISVGRendererShapeUtil.getEllipsePath(i2);
      default:
        throw new Error(`Can't getSVGPath for shape cause kind is unknow: "${JSON.stringify(i2)}"`);
    }
  }
  static getSVGElement(i2) {
    const r2 = { id: i2.id, type: i2.type, kind: i2.kind, "vector-effect": "non-scaling-stroke", "stroke-linecap": "round", "stroke-linejoin": "round" };
    i2.selected && (r2.filter = `url(#${pe.selectionFilterId})`), i2.deleting && (r2.filter = `url(#${pe.removalFilterId})`);
    const s2 = SVGBuilder.createGroup(r2), n2 = { fill: i2.style.fill || "transparent", stroke: i2.style.color || y.color, "stroke-width": (i2.style.width || y.width).toString(), d: _IISVGRendererShapeUtil.getSVGPath(i2) };
    return i2.style.opacity && (n2.opacity = i2.style.opacity.toString()), i2.kind === M.Ellipse && (n2.transform = `rotate(${convertRadianToDegree(i2.orientation)}, ${i2.center.x}, ${i2.center.y})`), s2.appendChild(SVGBuilder.createPath(n2)), s2;
  }
};
var IISVGRendererStrokeUtil = class _IISVGRendererStrokeUtil {
  static getArcPath(i2, r2) {
    return [`M ${i2.x} ${i2.y}`, `m ${-r2} 0`, `a ${r2} ${r2} 0 1 0 ${2 * r2} 0`, `a ${r2} ${r2} 0 1 0 ${-2 * r2} 0`].join(" ");
  }
  static getLinePath(i2, r2, s2) {
    const n2 = computeLinksPointers(i2, computeAngleAxeRadian(i2, r2), s2), a2 = computeLinksPointers(r2, computeAngleAxeRadian(i2, r2), s2);
    return [`M ${n2[0].x} ${n2[0].y}`, `L ${a2[0].x} ${a2[0].y}`, `L ${a2[1].x} ${a2[1].y}`, `L ${n2[1].x} ${n2[1].y}`].join(" ");
  }
  static getFinalPath(i2, r2, s2) {
    const n2 = computeAngleAxeRadian(i2, r2), a2 = computeLinksPointers(r2, n2, s2), l2 = [`M ${a2[0].x} ${a2[0].y}`];
    for (let i3 = 1; i3 <= 6; i3++) {
      const a3 = n2 - i3 * (Math.PI / 6), d2 = +(r2.x - r2.p * s2 * Math.sin(a3)).toFixed(3), h2 = +(r2.y + r2.p * s2 * Math.cos(a3)).toFixed(3);
      l2.push(`L ${d2} ${h2}`);
    }
    return l2.join(" ");
  }
  static getQuadraticPath(i2, r2, s2, n2) {
    const a2 = computeLinksPointers(i2, computeAngleAxeRadian(i2, s2), n2), l2 = computeLinksPointers(r2, computeAngleAxeRadian(s2, r2), n2), d2 = computeLinksPointers(s2, computeAngleAxeRadian(i2, r2), n2);
    return [`M ${a2[0].x} ${a2[0].y}`, `Q ${d2[0].x} ${d2[0].y} ${l2[0].x} ${l2[0].y}`, `L ${l2[1].x} ${l2[1].y}`, `Q ${d2[1].x} ${d2[1].y} ${a2[1].x} ${a2[1].y}`].join(" ");
  }
  static getSVGPath(i2) {
    const r2 = i2.pointers.length;
    if (!r2) return "";
    const s2 = i2.style.width, n2 = r2 - 2, a2 = i2.pointers[0], l2 = [];
    if (r2 < 3) l2.push(this.getArcPath(a2, 0.6 * s2));
    else {
      l2.push(this.getArcPath(a2, s2 * a2.p)), l2.push(this.getLinePath(a2, computeMiddlePointer(a2, i2.pointers[1]), s2));
      for (let r3 = 0; r3 < n2; r3++) {
        const n3 = computeMiddlePointer(i2.pointers[r3], i2.pointers[r3 + 1]), a3 = computeMiddlePointer(i2.pointers[r3 + 1], i2.pointers[r3 + 2]), d3 = i2.pointers[r3 + 1];
        l2.push(this.getQuadraticPath(n3, a3, d3, s2));
      }
      const d2 = i2.pointers[r2 - 2], h2 = i2.pointers[r2 - 1];
      l2.push(this.getLinePath(computeMiddlePointer(d2, h2), h2, s2)), l2.push(this.getFinalPath(d2, h2, s2));
    }
    return l2.join(" ");
  }
  static getSVGElement(i2) {
    const r2 = { id: i2.id, type: "stroke", "vector-effect": "non-scaling-stroke", "stroke-linecap": "round", "stroke-linejoin": "round" };
    i2.selected && (r2.filter = `url(#${pe.selectionFilterId})`), i2.deleting && (r2.filter = `url(#${pe.removalFilterId})`);
    const s2 = SVGBuilder.createGroup(r2), n2 = { fill: i2.style.color || y.color, "stroke-width": i2.style.width.toString(), d: _IISVGRendererStrokeUtil.getSVGPath(i2) };
    return i2.style.opacity && (n2.opacity = i2.style.opacity.toString()), s2.append(SVGBuilder.createPath(n2)), i2.decorators.forEach((r3) => {
      const n3 = IISVGRendererDecoratorUtil.getSVGElement(r3, i2);
      n3 && (r3.kind === k.Highlight ? s2.prepend(n3) : s2.append(n3));
    }), s2;
  }
};
var IISVGRendererTextUtil = class {
  static getSVGElement(i2) {
    const r2 = { id: i2.id, type: i2.type, "vector-effect": "non-scaling-stroke", "stroke-linecap": "round", "stroke-linejoin": "round", style: pe.noSelection };
    i2.style.opacity && (r2.opacity = i2.style.opacity.toString()), i2.rotation && (r2.transform = `rotate(${i2.rotation.degree}, ${i2.rotation.center.x}, ${i2.rotation.center.y})`), i2.selected && (r2.filter = `url(#${pe.selectionFilterId})`), i2.deleting && (r2.filter = `url(#${pe.removalFilterId})`);
    const s2 = SVGBuilder.createGroup(r2), n2 = SVGBuilder.createText(i2.point, "");
    return i2.chars.forEach((i3) => {
      const r3 = { id: i3.id, fill: i3.color, "font-size": `${i3.fontSize}px`, "font-weight": i3.fontWeight.toString() };
      n2.appendChild(SVGBuilder.createTSpan(i3.label, r3));
    }), s2.append(n2), i2.decorators.forEach((r3) => {
      const n3 = IISVGRendererDecoratorUtil.getSVGElement(r3, i2);
      n3 && (r3.kind === k.Highlight ? s2.prepend(n3) : s2.append(n3));
    }), s2;
  }
};
var IISVGRendererRecognizedUtil = class {
  static getSVGElement(i2) {
    const r2 = { id: i2.id, type: i2.type, kind: i2.kind, "vector-effect": "non-scaling-stroke", "stroke-linecap": "round", "stroke-linejoin": "round", fill: i2.style.color || y.color, "stroke-width": (i2.style.width || y.width).toString() };
    i2.style.opacity && (r2.opacity = i2.style.opacity.toString()), i2.selected && (r2.filter = `url(#${pe.selectionFilterId})`), i2.deleting && (r2.filter = `url(#${pe.removalFilterId})`);
    const s2 = SVGBuilder.createGroup(r2);
    return i2.strokes.forEach((i3) => {
      s2.append(IISVGRendererStrokeUtil.getSVGElement(i3));
    }), i2.kind === T.Text && i2.decorators.forEach((r3) => {
      const n2 = IISVGRendererDecoratorUtil.getSVGElement(r3, i2);
      n2 && (r3.kind === k.Highlight ? s2.prepend(n2) : s2.append(n2));
    }), s2;
  }
};
var IISVGRendererGroupUtil = class _IISVGRendererGroupUtil {
  static getChildElement(i2) {
    let r2;
    switch (i2.type) {
      case E.Stroke:
        r2 = IISVGRendererStrokeUtil.getSVGElement(i2);
        break;
      case E.Shape:
        r2 = IISVGRendererShapeUtil.getSVGElement(i2);
        break;
      case E.Edge:
        r2 = IISVGRendererEdgeUtil.getSVGElement(i2);
        break;
      case E.Text:
        r2 = IISVGRendererTextUtil.getSVGElement(i2);
        break;
      case E.Group:
        r2 = _IISVGRendererGroupUtil.getSVGElement(i2);
        break;
      case E.Recognized:
        r2 = IISVGRendererRecognizedUtil.getSVGElement(i2);
    }
    return r2;
  }
  static getSVGElement(i2) {
    const r2 = { id: i2.id, type: "group", "vector-effect": "non-scaling-stroke", "stroke-linecap": "round", "stroke-linejoin": "round", fill: i2.style.color || y.color, "stroke-width": (i2.style.width || y.width).toString() };
    i2.style.opacity && (r2.opacity = i2.style.opacity.toString()), i2.selected && (r2.filter = `url(#${pe.selectionFilterId})`), i2.deleting && (r2.filter = `url(#${pe.removalFilterId})`);
    const s2 = SVGBuilder.createGroup(r2);
    return i2.children.forEach((i3) => {
      s2.append(_IISVGRendererGroupUtil.getChildElement(i3));
    }), i2.decorators.forEach((r3) => {
      const n2 = IISVGRendererDecoratorUtil.getSVGElement(r3, i2);
      n2 && (r3.kind === k.Highlight ? s2.prepend(n2) : s2.append(n2));
    }), s2;
  }
};
var _t13;
var IISVGRenderer = class {
  constructor(i2) {
    __privateAdd(this, _t13, LoggerManager.getLogger(d.RENDERER));
    __publicField(this, "groupGuidesId", "guides-wrapper");
    __publicField(this, "configuration");
    __publicField(this, "parent");
    __publicField(this, "layer");
    __publicField(this, "definitionGroup");
    __publicField(this, "verticalGuides", []);
    __publicField(this, "horizontalGuides", []);
    __privateGet(this, _t13).info("constructor", { configuration: i2 }), this.configuration = i2;
  }
  initLayer() {
    const i2 = Math.max(this.configuration.minWidth, this.parent.clientWidth), r2 = Math.max(this.configuration.minHeight, this.parent.clientHeight);
    this.layer = SVGBuilder.createLayer({ x: 0, y: 0, width: i2, height: r2 }), this.layer.style.setProperty("height", "auto"), this.layer.style.setProperty("width", "auto"), this.layer.appendChild(this.createSVGTools()), this.parent.style.setProperty("overflow", "auto"), this.parent.appendChild(this.layer);
  }
  createDefs() {
    const i2 = SVGBuilder.createDefs(), r2 = 4, s2 = 2.5, n2 = { style: pe.noSelection, fill: "context-stroke", markerWidth: 5 .toString(), markerHeight: 5 .toString(), refX: r2.toString(), refY: s2.toString() }, a2 = SVGBuilder.createMarker(pe.arrowHeadStartMarker, { ...n2, orient: "auto-start-reverse" });
    a2.appendChild(SVGBuilder.createPolygon([0, 0, 5, s2, 0, 5], n2)), i2.appendChild(a2);
    const l2 = SVGBuilder.createMarker(pe.arrowHeadEndMaker, { ...n2, orient: "auto" });
    l2.appendChild(SVGBuilder.createPolygon([0, 0, 5, s2, 0, 5], n2)), i2.appendChild(l2);
    const d2 = { style: pe.noSelection, markerWidth: "5", markerHeight: "5", refX: "0", refY: "0", viewBox: "-5 -5 10 10" }, h2 = SVGBuilder.createMarker(pe.crossMarker, d2);
    return h2.appendChild(SVGBuilder.createPath({ d: "M -4,-4 L 4,4 M -4,4 L 4,-4", stroke: "white", "stroke-width": "3" })), h2.appendChild(SVGBuilder.createPath({ d: "M -4,-4 L 4,4 M -4,4 L 4,-4", stroke: "context-stroke", "stroke-width": "2" })), i2.appendChild(h2), i2;
  }
  createFilters() {
    const i2 = SVGBuilder.createGroup({ id: "definition-group" }), r2 = SVGBuilder.createFilter(pe.removalFilterId, { filterUnits: "userSpaceOnUse" }), s2 = SVGBuilder.createComponentTransfert(), n2 = SVGBuilder.createTransfertFunctionTable("feFuncA", "0 0.25");
    s2.appendChild(n2), r2.appendChild(s2), i2.appendChild(r2);
    const a2 = SVGBuilder.createFilter(pe.selectionFilterId, { filterUnits: "userSpaceOnUse" });
    return a2.appendChild(SVGBuilder.createDropShadow({ dx: -1, dy: -1, deviation: 1 })), i2.appendChild(a2), i2;
  }
  drawGuides() {
    var _a, _b2;
    this.verticalGuides = [], this.horizontalGuides = [];
    const i2 = Number((_a = this.layer.getAttribute("height")) == null ? void 0 : _a.replace("px", "")), r2 = Number((_b2 = this.layer.getAttribute("width")) == null ? void 0 : _b2.replace("px", "")), n2 = this.configuration.guides.gap, a2 = this.configuration.guides.gap / 5, l2 = { id: this.groupGuidesId, stroke: "grey", opacity: "0.5", style: pe.noSelection, role: s.Guide }, d2 = SVGBuilder.createGroup(l2);
    switch (this.configuration.guides.type) {
      case "line":
        for (let s2 = n2; s2 < i2; s2 += n2) {
          const i3 = { x: n2, y: s2 }, a3 = { x: r2 - n2, y: s2 };
          this.horizontalGuides.push(s2);
          const l3 = SVGBuilder.createLine(i3, a3, { "stroke-width": "1", style: pe.noSelection });
          d2.appendChild(l3);
        }
        break;
      case "grid":
        for (let s2 = 0; s2 < i2; s2 += n2) {
          const i3 = { x: 0, y: s2 }, l3 = { x: r2, y: s2 }, h2 = SVGBuilder.createLine(i3, l3, { "stroke-width": "1", style: pe.noSelection });
          d2.appendChild(h2), this.horizontalGuides.push(s2);
          for (let i4 = s2 + a2; i4 < s2 + n2; i4 += a2) {
            this.horizontalGuides.push(i4);
            const s3 = SVGBuilder.createLine({ x: 0, y: i4 }, { x: r2, y: i4 }, { "stroke-width": "0.25", style: pe.noSelection });
            d2.appendChild(s3);
          }
        }
        for (let s2 = 0; s2 < r2; s2 += n2) {
          const r3 = { x: s2, y: 0 }, l3 = { x: s2, y: i2 }, h2 = SVGBuilder.createLine(r3, l3, { "stroke-width": "1", style: pe.noSelection });
          d2.appendChild(h2), this.verticalGuides.push(s2);
          for (let r4 = s2 + a2; r4 < s2 + n2; r4 += a2) {
            this.verticalGuides.push(r4);
            const s3 = SVGBuilder.createLine({ x: r4, y: 0 }, { x: r4, y: i2 }, { "stroke-width": "0.25", style: pe.noSelection });
            d2.appendChild(s3);
          }
        }
        break;
      case "point":
        for (let s2 = n2; s2 < r2; s2 += n2) {
          this.verticalGuides.push(s2);
          for (let r3 = n2; r3 < i2; r3 += n2) {
            this.horizontalGuides.push(r3);
            const i3 = SVGBuilder.createCircle({ x: s2, y: r3 }, 1);
            d2.appendChild(i3);
          }
        }
        break;
      default:
        __privateGet(this, _t13).error("drawGuides", `Guide type unknow: ${this.configuration.guides.type}`);
    }
    this.horizontalGuides = [...new Set(this.horizontalGuides)], this.verticalGuides = [...new Set(this.verticalGuides)], this.definitionGroup.appendChild(d2);
  }
  removeGuides() {
    var _a;
    this.verticalGuides = [], this.horizontalGuides = [], (_a = this.layer.querySelector(`#${this.groupGuidesId}`)) == null ? void 0 : _a.remove();
  }
  createSVGTools() {
    return this.definitionGroup = SVGBuilder.createGroup({ id: "definition-group" }), this.definitionGroup.appendChild(this.createDefs()), this.definitionGroup.appendChild(this.createFilters()), this.configuration.guides.enable && this.drawGuides(), this.definitionGroup;
  }
  init(i2) {
    __privateGet(this, _t13).info("init", { element: i2 }), this.parent = i2, this.parent.oncontextmenu = () => false, this.initLayer();
  }
  getAttribute(i2, r2) {
    const s2 = this.layer.querySelector(`#${i2}`);
    return s2 == null ? void 0 : s2.getAttribute(r2);
  }
  setAttribute(i2, r2, s2) {
    const n2 = this.layer.querySelector(`#${i2}`);
    n2 == null ? void 0 : n2.setAttribute(r2, s2);
  }
  buildElementFromSymbol(i2) {
    let r2;
    switch (i2.type) {
      case E.Stroke:
        r2 = IISVGRendererStrokeUtil.getSVGElement(i2);
        break;
      case E.Eraser:
        r2 = IISVGRendererEraserUtil.getSVGElement(i2);
        break;
      case E.Shape:
        r2 = IISVGRendererShapeUtil.getSVGElement(i2);
        break;
      case E.Edge:
        r2 = IISVGRendererEdgeUtil.getSVGElement(i2);
        break;
      case E.Text:
        r2 = IISVGRendererTextUtil.getSVGElement(i2);
        break;
      case E.Group:
        r2 = IISVGRendererGroupUtil.getSVGElement(i2);
        break;
      case E.Recognized:
        r2 = IISVGRendererRecognizedUtil.getSVGElement(i2);
        break;
      default:
        __privateGet(this, _t13).error("buildElementFromSymbol", `symbol unknow: "${JSON.stringify(i2)}"`);
    }
    return r2;
  }
  prependElement(i2) {
    this.layer.prepend(i2);
  }
  changeOrderSymbol(i2, r2) {
    var _a, _b2;
    const s2 = this.layer.querySelector(`#${i2.id}`);
    if (s2) switch (r2) {
      case "first":
        this.definitionGroup.insertAdjacentElement("afterend", s2);
        break;
      case "last":
        this.layer.insertAdjacentElement("beforeend", s2);
        break;
      case "forward":
        (_a = s2.nextElementSibling) == null ? void 0 : _a.insertAdjacentElement("afterend", s2);
        break;
      case "backward":
        s2.previousElementSibling !== this.definitionGroup && ((_b2 = s2.previousElementSibling) == null ? void 0 : _b2.insertAdjacentElement("beforebegin", s2));
    }
  }
  appendElement(i2) {
    this.layer.appendChild(i2);
  }
  removeElement(i2) {
    __privateGet(this, _t13).debug("Element", { id: i2 });
    const r2 = this.layer.querySelector(`#${i2}`);
    r2 && r2.remove();
  }
  drawSymbol(i2) {
    __privateGet(this, _t13).debug("drawSymbol", { symbol: i2 });
    const r2 = this.layer.querySelector(`#${i2 == null ? void 0 : i2.id}`), s2 = this.buildElementFromSymbol(i2);
    return s2 && (r2 ? r2.replaceWith(s2) : this.layer.appendChild(s2)), s2;
  }
  replaceSymbol(i2, r2) {
    __privateGet(this, _t13).debug("drawSymbol", { symbols: r2 });
    const s2 = this.layer.querySelector(`#${i2}`), n2 = r2.map((i3) => this.buildElementFromSymbol(i3)).filter((i3) => !!i3);
    return n2.length && (s2 ? (n2.forEach((i3) => s2.insertAdjacentElement("beforebegin", i3)), s2.remove()) : n2.forEach((i3) => this.layer.appendChild(i3))), n2;
  }
  removeSymbol(i2) {
    __privateGet(this, _t13).debug("removeSymbol", { id: i2 }), this.removeElement(i2);
  }
  drawCircle(i2, r2, s2 = {}) {
    __privateGet(this, _t13).info("drawCircle", { point: i2, radius: r2, attrs: s2 }), this.layer.appendChild(SVGBuilder.createCircle(i2, r2, s2));
  }
  drawRect(i2, r2 = {}) {
    __privateGet(this, _t13).info("drawCircle", { box: i2, attrs: r2 }), this.layer.appendChild(SVGBuilder.createRect(i2, r2));
  }
  drawLine(i2, r2, s2 = {}) {
    __privateGet(this, _t13).info("drawLine", { p1: i2, p2: r2, attrs: s2 }), this.layer.appendChild(SVGBuilder.createLine(i2, r2, s2));
  }
  drawConnectionBetweenBox(i2, r2, s2, n2) {
    const a2 = new Box(r2).corners, l2 = new Box(s2).corners, { p1: d2, p2: h2 } = getClosestPoints(a2, l2), c2 = { id: i2, fill: "transparent", style: pe.noSelection, ...n2 };
    this.drawLine(d2, h2, c2);
  }
  resize(i2, r2) {
    __privateGet(this, _t13).info("resize", { height: i2, width: r2 }), this.layer.setAttribute("width", `${r2}px`), this.layer.setAttribute("height", `${i2}px`), this.layer.setAttribute("viewBox", `0, 0, ${r2}, ${i2}`), this.removeGuides(), this.configuration.guides.enable && this.drawGuides();
  }
  getElementById(i2) {
    return this.layer.querySelector(`#${i2}`);
  }
  getElements({ tagName: i2, attrs: r2 }) {
    __privateGet(this, _t13).info("getElements", { tagName: i2, attrs: r2 });
    let s2 = i2 || "*";
    return r2 && Object.keys(r2).forEach((i3) => {
      s2 += `[${i3}=${r2[i3]}]`;
    }), this.layer.querySelectorAll(s2);
  }
  clearElements({ tagName: i2, attrs: r2 }) {
    __privateGet(this, _t13).info("clearElements", { tagName: i2, attrs: r2 }), this.getElements({ tagName: i2, attrs: r2 }).forEach((i3) => i3.remove());
  }
  clear() {
    if (__privateGet(this, _t13).info("clear"), this.layer) {
      for (; this.layer.firstChild; ) this.layer.firstChild.remove();
      this.layer.appendChild(this.createSVGTools());
    }
  }
  destroy() {
    this.layer && this.layer.remove();
  }
};
_t13 = new WeakMap();
var SVGStroker = class {
  getArcPath(i2, r2) {
    return [`M ${i2.x},${i2.y}`, `m ${-r2},0`, `a ${r2},${r2} 0 1 0 ${2 * r2},0`, `a ${r2},${r2} 0 1 0 ${-2 * r2},0`].join(" ");
  }
  getLinePath(i2, r2, s2) {
    const n2 = computeLinksPointers(i2, computeAngleAxeRadian(i2, r2), s2), a2 = computeLinksPointers(r2, computeAngleAxeRadian(i2, r2), s2);
    return [`M ${n2[0].x},${n2[0].y}`, `L ${a2[0].x},${a2[0].y}`, `L ${a2[1].x},${a2[1].y}`, `L ${n2[1].x},${n2[1].y}`].join(" ");
  }
  getFinalPath(i2, r2, s2) {
    const n2 = computeAngleAxeRadian(i2, r2), a2 = computeLinksPointers(r2, n2, s2), l2 = [`M ${a2[0].x},${a2[0].y}`];
    for (let i3 = 1; i3 <= 6; i3++) {
      const a3 = n2 - i3 * (Math.PI / 6);
      l2.push(`L ${r2.x - r2.p * s2 * Math.sin(a3)},${r2.y + r2.p * s2 * Math.cos(a3)}`);
    }
    return l2.join(" ");
  }
  getQuadraticPath(i2, r2, s2, n2) {
    const a2 = computeLinksPointers(i2, computeAngleAxeRadian(i2, s2), n2), l2 = computeLinksPointers(r2, computeAngleAxeRadian(s2, r2), n2), d2 = computeLinksPointers(s2, computeAngleAxeRadian(i2, r2), n2);
    return [`M ${a2[0].x},${a2[0].y}`, `Q ${d2[0].x},${d2[0].y} ${l2[0].x},${l2[0].y}`, `L ${l2[1].x},${l2[1].y}`, `Q ${d2[1].x},${d2[1].y} ${a2[1].x},${a2[1].y}`].join(" ");
  }
  buildSVGPath(i2) {
    const r2 = i2.pointers.length, s2 = i2.style.width, n2 = r2 - 2, a2 = i2.pointers[0], l2 = [];
    if (r2 < 3) l2.push(this.getArcPath(a2, 0.6 * s2));
    else {
      l2.push(this.getArcPath(a2, s2 * a2.p)), l2.push(this.getLinePath(a2, computeMiddlePointer(a2, i2.pointers[1]), s2));
      for (let r3 = 0; r3 < n2; r3++) {
        const n3 = computeMiddlePointer(i2.pointers[r3], i2.pointers[r3 + 1]), a3 = computeMiddlePointer(i2.pointers[r3 + 1], i2.pointers[r3 + 2]), d3 = i2.pointers[r3 + 1];
        l2.push(this.getQuadraticPath(n3, a3, d3, s2));
      }
      const d2 = i2.pointers[r2 - 2], h2 = i2.pointers[r2 - 1];
      l2.push(this.getLinePath(computeMiddlePointer(d2, h2), h2, s2)), l2.push(this.getFinalPath(d2, h2, s2));
    }
    return l2.join(" ");
  }
  drawStroke(i2, r2, s2) {
    const n2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    n2.classList.add("pending-stroke"), n2.setAttribute("id", r2.id), n2.setAttribute("type", r2.pointerType), s2 == null ? void 0 : s2.forEach((i3) => {
      n2.setAttribute(i3.name, i3.value);
    });
    const a2 = this.buildSVGPath(r2);
    n2.setAttribute("d", `${a2}Z`), i2.appendChild(n2);
  }
};
var _t14;
var InteractiveInkSSRSVGRenderer = class {
  constructor(i2) {
    __privateAdd(this, _t14, LoggerManager.getLogger(d.RENDERER));
    __publicField(this, "config");
    __publicField(this, "stroker");
    __publicField(this, "context");
    __privateGet(this, _t14).info("constructor", { config: i2 }), this.config = i2, this.stroker = new SVGStroker();
  }
  init(i2) {
    __privateGet(this, _t14).info("init", { element: i2 }), i2.style.fontSize = "10px", this.context = { parent: i2 };
  }
  drawStroke(i2, r2) {
    let s2;
    "eraser" === r2.pointerType ? (r2.style.width = 12, s2 = "fill:grey;stroke:transparent;shadowBlur:5;opacity:0.2;") : s2 = `fill:${r2.style.color};stroke:transparent;`, this.stroker.drawStroke(i2, r2, [{ name: "style", value: s2 }]);
  }
  replaceAll(i2, r2) {
    const s2 = this.context.parent.querySelector(`svg[data-layer="${i2}"]`);
    s2 == null ? void 0 : s2.remove(), this.context.parent.insertAdjacentHTML("beforeend", r2.svg);
    const n2 = this.context.parent.querySelector(`svg[data-layer="${i2}"]`);
    if ("MODEL" === i2) {
      const i3 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      i3.id = "pendingStrokes", n2.appendChild(i3);
    }
  }
  replaceElement(i2) {
    const r2 = this.context.parent.querySelector(`#${i2.id}`);
    if (r2) {
      const s2 = r2.parentNode;
      r2 == null ? void 0 : r2.remove(), s2 == null ? void 0 : s2.insertAdjacentHTML("beforeend", i2.svg);
    }
  }
  appendChild(i2, r2) {
    const s2 = r2.parentId ? `#${r2.parentId}` : `svg[data-layer="${i2}"]`, n2 = this.context.parent.querySelector(s2);
    n2 == null ? void 0 : n2.insertAdjacentHTML("beforeend", r2.svg);
  }
  removeChild(i2) {
    var _a;
    (_a = this.context.parent.querySelector(`#${i2.parentId} > *:nth-child(${i2.index + 1})`)) == null ? void 0 : _a.remove();
  }
  removeElement(i2) {
    const r2 = this.context.parent.querySelector(`#${i2.id}`);
    r2 && (i2.id.includes("s") || i2.id.includes("MODEL") ? r2.remove() : (r2.setAttribute("class", "removed-stroke"), setTimeout(() => {
      r2 == null ? void 0 : r2.remove();
    }, 100)));
  }
  insertBefore(i2) {
    const r2 = this.context.parent.querySelector(`#${i2.refId}`);
    r2 == null ? void 0 : r2.insertAdjacentHTML("beforebegin", i2.svg);
  }
  setAttribute(i2) {
    const r2 = i2.id ? `#${i2.id}` : "svg", s2 = this.context.parent.querySelector(r2);
    s2 == null ? void 0 : s2.setAttribute(i2.name, i2.value);
  }
  removeAttribute(i2) {
    const r2 = i2.id ? `#${i2.id}` : "svg", s2 = this.context.parent.querySelector(r2);
    s2 == null ? void 0 : s2.removeAttribute(i2.name);
  }
  updateLayer(i2, r2) {
    switch (__privateGet(this, _t14).info("updateLayer", { layerName: i2, update: r2 }), r2.type) {
      case "REPLACE_ALL":
        this.replaceAll(i2, r2);
        break;
      case "REPLACE_ELEMENT":
        this.replaceElement(r2);
        break;
      case "APPEND_CHILD":
        this.appendChild(i2, r2);
        break;
      case "REMOVE_ELEMENT":
        this.removeElement(r2);
        break;
      case "REMOVE_CHILD":
        this.removeChild(r2);
        break;
      case "INSERT_BEFORE":
        this.insertBefore(r2);
        break;
      case "SET_ATTRIBUTE":
        this.setAttribute(r2);
        break;
      case "REMOVE_ATTRIBUTE":
        this.removeAttribute(r2);
        break;
      default:
        __privateGet(this, _t14).warn("updateLayer", `update.type unknow ${r2.type}`);
    }
  }
  updatesLayer(i2, r2) {
    __privateGet(this, _t14).info("updatesLayer", { layerName: i2, updates: r2 }), r2.forEach((r3) => this.updateLayer(i2, r3)), this.clearPendingStroke();
  }
  clearPendingStroke() {
    __privateGet(this, _t14).info("clearPendingStroke");
    const i2 = this.context.parent.querySelector("#pendingStrokes");
    i2 && (i2.innerHTML = "");
  }
  drawPendingStroke(i2) {
    if (__privateGet(this, _t14).info("drawPendingStroke", { stroke: i2 }), i2) {
      const r2 = this.context.parent.querySelector("#pendingStrokes");
      if (r2) {
        const s2 = r2.querySelector(`#${i2 == null ? void 0 : i2.id}`);
        s2 && s2.remove(), this.drawStroke(r2, i2);
      }
    }
  }
  clearErasingStrokes() {
    this.context.parent.querySelectorAll("[type=eraser]").forEach((i2) => {
      i2.remove();
    });
  }
  resize(i2) {
    __privateGet(this, _t14).info("resize", { model: i2 });
    const r2 = this.context.parent.getBoundingClientRect(), s2 = this.context.parent.querySelectorAll("svg"), n2 = Math.max(r2.width, i2.width), a2 = Math.max(r2.height, i2.height);
    s2.forEach((i3) => {
      i3.setAttribute("viewBox", `0 0 ${n2}, ${a2}`), i3.setAttribute("width", `${n2}px`), i3.setAttribute("height", `${a2}px`);
    });
  }
  destroy() {
    var _a;
    __privateGet(this, _t14).info("destroy", { context: this.context }), ((_a = this.context) == null ? void 0 : _a.parent) && this.context.parent.querySelectorAll("svg").forEach((i2) => i2.remove());
  }
};
_t14 = new WeakMap();
var me = { enable: true, gap: 50 };
var ye = { guides: me, minHeight: 100, minWidth: 100 };
var be = { guides: { enable: true, gap: 50, type: "point" }, minHeight: 100, minWidth: 100 };
var _t15;
var IIConversionManager = class {
  constructor(i2) {
    __privateAdd(this, _t15, LoggerManager.getLogger(d.CONVERTER));
    __publicField(this, "editor");
    __privateGet(this, _t15).info("constructor"), this.editor = i2;
  }
  get configuration() {
    return this.editor.configuration.fontStyle;
  }
  get model() {
    return this.editor.model;
  }
  get rowHeight() {
    return this.editor.configuration.rendering.guides.gap;
  }
  computeFontSize(i2) {
    if (i2.some((i3) => i3["bounding-box"])) {
      const r2 = convertMillimeterToPixel(computeAverage(i2.map((i3) => {
        var _a;
        return ((_a = i3["bounding-box"]) == null ? void 0 : _a.height) || 1;
      })));
      return 2 * Math.round(Math.round(r2 * this.rowHeight) / this.rowHeight / 2);
    }
    return Math.round(this.rowHeight / 2);
  }
  buildChar(i2, r2, s2) {
    const n2 = i2.grid.map((i3) => ({ x: convertMillimeterToPixel(i3.x), y: convertMillimeterToPixel(i3.y) }));
    let a2 = this.configuration.weight;
    "auto" === a2 && (a2 = (r2[0].style.width || 1) > 2 ? "bold" : "normal");
    const l2 = r2[0].style.color || "black";
    return { id: `text-char-${createUUID()}`, label: i2.label, color: l2, fontSize: s2, fontWeight: a2, bounds: Box.createFromPoints(n2) };
  }
  buildText(i2, r2, s2, n2) {
    const a2 = Box.createFromBoxes([convertBoundingBoxMillimeterToPixel(i2["bounding-box"])]), l2 = [], d2 = "auto" === n2 ? this.computeFontSize(r2) : n2;
    r2.forEach((i3) => {
      const r3 = s2.filter((r4) => {
        var _a;
        return (_a = i3.items) == null ? void 0 : _a.some((i4) => i4["full-id"] === r4.id);
      });
      r3.length && l2.push(this.buildChar(i3, r3, d2));
    });
    const h2 = { x: a2.xMin, y: a2.yMax }, c2 = new IIText(l2, h2, a2, s2[0].style), u2 = s2.flatMap((i3) => i3.decorators);
    if (s2.forEach((i3) => {
      const r3 = this.model.getRootSymbol(i3.id);
      if ((r3 == null ? void 0 : r3.type) === E.Recognized && r3.kind === T.Text || (r3 == null ? void 0 : r3.type) === E.Group) {
        const i4 = r3.decorators.find((i5) => i5.kind === k.Highlight);
        i4 && u2.push(i4);
        const s3 = r3.decorators.find((i5) => i5.kind === k.Strikethrough);
        s3 && u2.push(s3);
        const n3 = r3.decorators.find((i5) => i5.kind === k.Surround);
        n3 && u2.push(n3);
        const a3 = r3.decorators.find((i5) => i5.kind === k.Underline);
        a3 && u2.push(a3);
      }
    }), u2.length) {
      const i3 = u2.find((i4) => i4.kind === k.Highlight);
      i3 && c2.decorators.push(new IIDecorator(k.Highlight, i3.style));
      const r3 = u2.find((i4) => i4.kind === k.Strikethrough);
      r3 && c2.decorators.push(new IIDecorator(k.Strikethrough, r3.style));
      const s3 = u2.find((i4) => i4.kind === k.Surround);
      s3 && c2.decorators.push(new IIDecorator(k.Surround, s3.style));
      const n3 = u2.find((i4) => i4.kind === k.Underline);
      n3 && c2.decorators.push(new IIDecorator(k.Underline, n3.style));
    }
    return c2;
  }
  convertText(i2, r2, s2) {
    var _a, _b2;
    if (!i2.lines) throw new Error("You need to active configuration.recognition.export.jiix.text.lines = true");
    if (!i2.words) throw new Error("You need to active configuration.recognition.export.jiix.text.words = true");
    if (!i2.chars) throw new Error("You need to active configuration.recognition.export.jiix.text.chars = true");
    if (!i2.chars.some((i3) => i3.items)) throw new Error("You need to active configuration.recognition.export.jiix.strokes = true");
    const n2 = i2.words, a2 = i2.chars, l2 = [];
    let d2 = this.configuration.size;
    s2 && "auto" === d2 ? d2 = 2 * Math.round(this.computeFontSize(a2.filter((i3) => {
      var _a2;
      return (_a2 = i3.items) == null ? void 0 : _a2.length;
    })) / 2) : "auto" !== this.configuration.size && (d2 = this.configuration.size * this.rowHeight);
    let h2 = false, c2 = convertMillimeterToPixel(i2.lines[0]["baseline-y"]);
    const u2 = convertMillimeterToPixel(((_a = i2["bounding-box"]) == null ? void 0 : _a.x) || 0);
    let p2 = convertMillimeterToPixel(((_b2 = n2[0]["bounding-box"]) == null ? void 0 : _b2.x) || 0);
    return n2.forEach((i3) => {
      var _a2;
      if (" " === i3.label) return void (p2 += this.editor.texter.getSpaceWidth(((_a2 = l2.at(-1)) == null ? void 0 : _a2.symbol.chars[0].fontSize) || this.rowHeight / 2));
      const n3 = r2.filter((r3) => {
        var _a3;
        return (_a3 = i3.items) == null ? void 0 : _a3.some((i4) => i4["full-id"] === r3.id);
      });
      if (n3.length) {
        const r3 = a2.slice(i3["first-char"], (i3["last-char"] || 0) + 1), g2 = this.buildText(i3, r3, n3, d2);
        if (s2) {
          if (h2) {
            h2 = false;
            const i4 = Math.round((g2.point.y - c2) / this.rowHeight) || 1;
            c2 += i4 * this.rowHeight, p2 = Math.abs(g2.point.x - u2) < this.rowHeight ? u2 : g2.point.x;
          }
          g2.point.x = p2, g2.point.y = this.model.roundToLineGuide(c2);
        }
        this.editor.texter.setBounds(g2), p2 += g2.bounds.width, l2.push({ symbol: g2, strokes: n3 });
      }
      h2 = "\n" === i3.label;
    }), l2;
  }
  buildCircle(i2, r2) {
    var _a;
    const s2 = { x: convertMillimeterToPixel(i2.cx), y: convertMillimeterToPixel(i2.cy) };
    return new IIShapeCircle(s2, convertMillimeterToPixel(i2.r), (_a = r2[0]) == null ? void 0 : _a.style);
  }
  buildEllipse(i2, r2) {
    var _a;
    const s2 = { x: convertMillimeterToPixel(i2.cx), y: convertMillimeterToPixel(i2.cy) };
    return new IIShapeEllipse(s2, convertMillimeterToPixel(i2.rx), convertMillimeterToPixel(i2.ry), i2.orientation, (_a = r2[0]) == null ? void 0 : _a.style);
  }
  buildRectangle(i2, r2) {
    var _a;
    const s2 = convertMillimeterToPixel(i2.height), n2 = convertMillimeterToPixel(i2.width), a2 = convertMillimeterToPixel(i2.x), l2 = convertMillimeterToPixel(i2.y);
    return new IIShapePolygon([{ x: a2, y: l2 }, { x: a2 + n2, y: l2 }, { x: a2 + n2, y: l2 + s2 }, { x: a2, y: l2 + s2 }], (_a = r2[0]) == null ? void 0 : _a.style);
  }
  buildPolygon(i2, r2) {
    var _a;
    const s2 = [];
    for (let r3 = 0; r3 < i2.points.length; r3 += 2) s2.push({ x: convertMillimeterToPixel(i2.points[r3]), y: convertMillimeterToPixel(i2.points[r3 + 1]) });
    return new IIShapePolygon(s2, (_a = r2[0]) == null ? void 0 : _a.style);
  }
  buildRhombus(i2, r2) {
    var _a;
    const s2 = [];
    for (let r3 = 0; r3 < i2.points.length; r3 += 2) s2.push({ x: convertMillimeterToPixel(i2.points[r3]), y: convertMillimeterToPixel(i2.points[r3 + 1]) });
    return new IIShapePolygon(s2, (_a = r2[0]) == null ? void 0 : _a.style);
  }
  buildTriangle(i2, r2) {
    var _a;
    const s2 = [];
    for (let r3 = 0; r3 < i2.points.length; r3 += 2) s2.push({ x: convertMillimeterToPixel(i2.points[r3]), y: convertMillimeterToPixel(i2.points[r3 + 1]) });
    return new IIShapePolygon(s2, (_a = r2[0]) == null ? void 0 : _a.style);
  }
  buildParallelogram(i2, r2) {
    var _a;
    const s2 = [];
    for (let r3 = 0; r3 < i2.points.length; r3 += 2) s2.push({ x: convertMillimeterToPixel(i2.points[r3]), y: convertMillimeterToPixel(i2.points[r3 + 1]) });
    return new IIShapePolygon(s2, (_a = r2[0]) == null ? void 0 : _a.style);
  }
  convertNode(i2, r2) {
    const s2 = r2.filter((r3) => {
      var _a;
      return (_a = i2.items) == null ? void 0 : _a.some((i3) => i3["full-id"] === r3.id);
    });
    if (!s2.length) return;
    const n2 = s2.filter((i3, r3) => s2.findIndex((r4) => i3.id === r4.id) === r3);
    let a2;
    switch (i2.kind) {
      case g.Circle:
        a2 = this.buildCircle(i2, n2);
        break;
      case g.Ellipse:
        a2 = this.buildEllipse(i2, n2);
        break;
      case g.Rectangle:
        a2 = this.buildRectangle(i2, n2);
        break;
      case g.Triangle:
        a2 = this.buildTriangle(i2, n2);
        break;
      case g.Parallelogram:
        a2 = this.buildParallelogram(i2, n2);
        break;
      case g.Polygon:
        a2 = this.buildPolygon(i2, n2);
        break;
      case g.Rhombus:
        a2 = this.buildRhombus(i2, n2);
        break;
      default:
        return void __privateGet(this, _t15).warn("convertNode", `Conversion of Node with kind equal to ${JSON.stringify(i2)} is unknow`);
    }
    return { symbol: a2, strokes: n2 };
  }
  buildLine(i2, r2) {
    var _a;
    const s2 = { x: convertMillimeterToPixel(i2.x1), y: convertMillimeterToPixel(i2.y1) }, n2 = { x: convertMillimeterToPixel(i2.x2), y: convertMillimeterToPixel(i2.y2) }, a2 = computeAngleAxeRadian(s2, n2);
    return Math.abs(a2 % Math.PI) < 0.1 ? (s2.y = +((s2.y + n2.y) / 2).toFixed(3), n2.y = s2.y) : Math.abs(a2 % (Math.PI / 2)) < 0.1 && (s2.x = +((s2.x + n2.x) / 2).toFixed(3), n2.x = s2.x), new IIEdgeLine(s2, n2, i2.p1Decoration, i2.p2Decoration, (_a = r2[0]) == null ? void 0 : _a.style);
  }
  buildPolyEdge(i2, r2) {
    var _a;
    const s2 = { x: convertMillimeterToPixel(i2.edges[0].x1), y: convertMillimeterToPixel(i2.edges[0].y1) }, n2 = i2.edges.map((i3) => ({ x: convertMillimeterToPixel(i3.x2), y: convertMillimeterToPixel(i3.y2) }));
    n2.unshift(s2);
    for (let i3 = 0; i3 < n2.length - 1; i3++) {
      const r3 = n2[i3], s3 = n2[i3 + 1], a2 = computeAngleAxeRadian(r3, s3);
      Math.abs(a2 % Math.PI) < 0.1 ? (r3.y = +((r3.y + s3.y) / 2).toFixed(3), s3.y = r3.y) : Math.abs(a2 % (Math.PI / 2)) < 0.1 && (r3.x = +((r3.x + s3.x) / 2).toFixed(3), s3.x = r3.x);
    }
    return new IIEdgePolyLine(n2, i2.edges[0].p1Decoration, i2.edges.at(-1).p2Decoration, (_a = r2[0]) == null ? void 0 : _a.style);
  }
  buildArc(i2, r2) {
    var _a;
    const s2 = { x: convertMillimeterToPixel(i2.cx), y: convertMillimeterToPixel(i2.cy) }, n2 = convertMillimeterToPixel(i2.rx), a2 = convertMillimeterToPixel(i2.ry);
    return new IIEdgeArc(s2, i2.startAngle, i2.sweepAngle, n2, a2, i2.phi, i2.startDecoration, i2.endDecoration, (_a = r2[0]) == null ? void 0 : _a.style);
  }
  convertEdge(i2, r2) {
    switch (i2.kind) {
      case m.Line: {
        const s2 = r2.filter((r3) => {
          var _a;
          return (_a = i2.items) == null ? void 0 : _a.some((i3) => i3["full-id"] === r3.id);
        });
        if (!s2.length) return;
        const n2 = s2.filter((i3, r3) => s2.findIndex((r4) => i3.id === r4.id) === r3);
        return { symbol: this.buildLine(i2, n2), strokes: n2 };
      }
      case m.Arc: {
        const s2 = r2.filter((r3) => {
          var _a;
          return (_a = i2.items) == null ? void 0 : _a.some((i3) => i3["full-id"] === r3.id);
        });
        if (!s2.length) return;
        const n2 = s2.filter((i3, r3) => s2.findIndex((r4) => i3.id === r4.id) === r3);
        return { symbol: this.buildArc(i2, n2), strokes: n2 };
      }
      case m.PolyEdge: {
        const s2 = r2.filter((r3) => {
          var _a;
          return (_a = i2.edges.flatMap((i3) => i3.items)) == null ? void 0 : _a.some((i3) => i3["full-id"] === r3.id);
        });
        if (!s2.length) return;
        const n2 = s2.filter((i3, r3) => s2.findIndex((r4) => i3.id === r4.id) === r3);
        return { symbol: this.buildPolyEdge(i2, n2), strokes: n2 };
      }
      default:
        return void __privateGet(this, _t15).error("convertEdge", `Conversion of Edge with kind equal to ${JSON.stringify(i2)} is unknow`);
    }
  }
  async apply(i2 = []) {
    var _a, _b2, _c2, _d6;
    __privateGet(this, _t15).info("convert"), ((_a = this.model.exports) == null ? void 0 : _a["application/vnd.myscript.jiix"]) || await this.editor.export(["application/vnd.myscript.jiix"]), this.editor.selector.removeSelectedGroup();
    const r2 = (_b2 = this.model.exports) == null ? void 0 : _b2["application/vnd.myscript.jiix"];
    if ((_c2 = r2 == null ? void 0 : r2.elements) == null ? void 0 : _c2.length) {
      const s2 = this.editor.extractStrokesFromSymbols(i2.length ? i2 : this.model.symbols), n2 = !((_d6 = r2.elements) == null ? void 0 : _d6.some((i3) => "Text" !== i3.type)), a2 = [];
      r2.elements.forEach((i3) => {
        switch (i3.type) {
          case "Text": {
            const r3 = this.convertText(i3, s2, n2);
            r3 && a2.push(...r3);
            break;
          }
          case "Node": {
            const r3 = this.convertNode(i3, s2);
            r3 && a2.push(r3);
            break;
          }
          case "Edge": {
            const r3 = this.convertEdge(i3, s2);
            r3 && a2.push(r3);
            break;
          }
          default:
            __privateGet(this, _t15).warn("buildConversions", `Unknow jiix element type: ${i3.type}`);
        }
      }), this.editor.addSymbols(a2.map((i3) => i3.symbol), false), this.editor.removeSymbols(a2.flatMap((i3) => i3.strokes.map((i4) => i4.id)), false), this.editor.history.push(this.model, { added: a2.map((i3) => i3.symbol), erased: a2.flatMap((i3) => i3.strokes) });
    }
  }
};
_t15 = new WeakMap();
var _t16;
var IIResizeManager = class {
  constructor(i2) {
    __privateAdd(this, _t16, LoggerManager.getLogger(d.TRANSFORMER));
    __publicField(this, "editor");
    __publicField(this, "interactElementsGroup");
    __publicField(this, "direction");
    __publicField(this, "boundingBox");
    __publicField(this, "transformOrigin");
    __publicField(this, "keepRatio", false);
    __privateGet(this, _t16).info("constructor"), this.editor = i2;
  }
  get model() {
    return this.editor.model;
  }
  applyToStroke(i2, r2, s2, n2) {
    return __privateGet(this, _t16).debug("applyToStroke", { stroke: i2, origin: r2, scaleX: s2, scaleY: n2 }), i2.pointers.forEach((i3) => {
      i3.x = +(r2.x + s2 * (i3.x - r2.x)).toFixed(3), i3.y = +(r2.y + n2 * (i3.y - r2.y)).toFixed(3);
    }), i2;
  }
  applyToShape(i2, r2, s2, n2) {
    switch (__privateGet(this, _t16).debug("applyToShape", { shape: i2, origin: r2, scaleX: s2, scaleY: n2 }), i2.kind) {
      case M.Ellipse: {
        const a2 = Math.cos(i2.orientation), l2 = Math.sin(i2.orientation);
        return i2.center.x = +(i2.center.x + ((s2 - 1) * a2 + (n2 - 1) * l2) * (i2.center.x - r2.x)).toFixed(3), i2.center.y = +(i2.center.y + ((s2 - 1) * -l2 + (n2 - 1) * a2) * (i2.center.y - r2.y)).toFixed(3), i2.radiusX = +Math.abs(i2.radiusX * (s2 * a2 - n2 * l2)).toFixed(3), i2.radiusY = +Math.abs(i2.radiusY * (s2 * l2 + n2 * a2)).toFixed(3), i2;
      }
      case M.Circle:
        return i2.radius = +(i2.radius * (s2 + n2) / 2).toFixed(3), i2.center.x = +(r2.x + s2 * (i2.center.x - r2.x)).toFixed(3), i2.center.y = +(r2.y + n2 * (i2.center.y - r2.y)).toFixed(3), i2;
      case M.Polygon:
        return i2.points.forEach((i3) => {
          i3.x = +(r2.x + s2 * (i3.x - r2.x)).toFixed(3), i3.y = +(r2.y + n2 * (i3.y - r2.y)).toFixed(3);
        }), i2;
      default:
        throw new Error(`Can't apply resize on shape, kind unknow: ${JSON.stringify(i2)}`);
    }
  }
  applyToEdge(i2, r2, s2, n2) {
    switch (__privateGet(this, _t16).debug("applyToEdge", { edge: i2, origin: r2, scaleX: s2, scaleY: n2 }), i2.kind) {
      case I.Arc: {
        const a2 = Math.cos(i2.phi), l2 = Math.sin(i2.phi);
        return i2.center.x = +(i2.center.x + ((s2 - 1) * a2 + (n2 - 1) * l2) * (i2.center.x - r2.x)).toFixed(3), i2.center.y = +(i2.center.y + ((s2 - 1) * -l2 + (n2 - 1) * a2) * (i2.center.y - r2.y)).toFixed(3), i2.radiusX = +(i2.radiusX * Math.abs(s2 * a2 + n2 * l2)).toFixed(3), i2.radiusY = +(i2.radiusY * Math.abs(s2 * l2 + n2 * a2)).toFixed(3), s2 < 0 ? (i2.startAngle = +(Math.PI - i2.startAngle).toFixed(3), i2.sweepAngle *= -1) : n2 < 0 && (i2.sweepAngle *= -1), i2;
      }
      case I.Line:
        return i2.start.x = +(r2.x + s2 * (i2.start.x - r2.x)).toFixed(3), i2.start.y = +(r2.y + n2 * (i2.start.y - r2.y)).toFixed(3), i2.end.x = +(r2.x + s2 * (i2.end.x - r2.x)).toFixed(3), i2.end.y = +(r2.y + n2 * (i2.end.y - r2.y)).toFixed(3), i2;
      case I.PolyEdge:
        return i2.points.forEach((i3) => (i3.x = +(r2.x + s2 * (i3.x - r2.x)).toFixed(3), i3.y = +(r2.y + n2 * (i3.y - r2.y)).toFixed(3), i3)), i2;
      default:
        throw new Error(`Can't apply resize on edge, kind unknow: ${JSON.stringify(i2)}`);
    }
  }
  applyOnText(i2, r2, s2, n2) {
    return i2.point.x = +(r2.x + s2 * (i2.point.x - r2.x)).toFixed(3), i2.point.y = +(r2.y + n2 * (i2.point.y - r2.y)).toFixed(3), i2.chars.forEach((i3) => {
      i3.fontSize = +(i3.fontSize * (s2 + n2) / 2).toFixed(3);
    }), this.editor.texter.updateBounds(i2);
  }
  applyOnGroup(i2, r2, s2, n2) {
    return i2.children.forEach((i3) => this.applyToSymbol(i3, r2, s2, n2)), i2;
  }
  applyOnRecognizedSymbol(i2, r2, s2, n2) {
    return i2.strokes.forEach((i3) => this.applyToStroke(i3, r2, s2, n2)), i2.kind === T.Text && (i2.xHeight *= n2), i2;
  }
  applyToSymbol(i2, r2, s2, n2) {
    switch (__privateGet(this, _t16).info("applyToSymbol", { symbol: i2, scaleX: s2, scaleY: n2 }), i2.type) {
      case E.Stroke:
        return this.applyToStroke(i2, r2, s2, n2);
      case E.Shape:
        return this.applyToShape(i2, r2, s2, n2);
      case E.Edge:
        return this.applyToEdge(i2, r2, s2, n2);
      case E.Text:
        return this.applyOnText(i2, r2, s2, n2);
      case E.Group:
        return this.applyOnGroup(i2, r2, s2, n2);
      case E.Recognized:
        return this.applyOnRecognizedSymbol(i2, r2, s2, n2);
      default:
        throw new Error(`Can't apply resize on symbol, type unknow: ${JSON.stringify(i2)}`);
    }
  }
  setTransformOrigin(i2, r2, s2) {
    this.editor.renderer.setAttribute(i2, "transform-origin", `${r2}px ${s2}px`);
  }
  scaleElement(i2, r2, s2) {
    __privateGet(this, _t16).info("scaleElement", { id: i2, sx: r2, sy: s2 }), this.editor.renderer.setAttribute(i2, "transform", `scale(${r2},${s2})`);
  }
  start(i2, r2) {
    __privateGet(this, _t16).info("start", { target: i2 }), this.interactElementsGroup = i2.closest(`[role=${s.InteractElementsGroup}]`), this.direction = i2.getAttribute("resize-direction"), this.keepRatio = this.model.symbolsSelected.some((i3) => i3.type === E.Text || i3.type === E.Shape && i3.kind === M.Circle), this.transformOrigin = r2, this.boundingBox = Box.createFromPoints(this.model.symbolsSelected.flatMap((i3) => i3.vertices)), this.setTransformOrigin(this.interactElementsGroup.id, this.transformOrigin.x, this.transformOrigin.y), this.model.symbolsSelected.forEach((i3) => {
      this.setTransformOrigin(i3.id, this.transformOrigin.x, this.transformOrigin.y);
    });
  }
  continue(i2) {
    if (__privateGet(this, _t16).info("continue", { point: i2 }), !this.interactElementsGroup) throw new Error("Can't resize, you must call start before");
    const r2 = i2, s2 = ["e-resize", "ne-resize", "se-resize", "w-resize", "nw-resize", "sw-resize"].includes(this.direction), n2 = ["n-resize", "ne-resize", "nw-resize", "s-resize", "se-resize", "sw-resize"].includes(this.direction), { x: a2, y: l2 } = this.editor.snaps.snapResize(i2, s2, n2);
    r2.x = a2, r2.y = l2;
    let d2 = 0, h2 = 0;
    ["e-resize", "ne-resize", "se-resize"].includes(this.direction) ? d2 = r2.x - this.boundingBox.xMax : ["w-resize", "nw-resize", "sw-resize"].includes(this.direction) && (d2 = this.boundingBox.xMin - r2.x), ["n-resize", "ne-resize", "nw-resize"].includes(this.direction) ? h2 = this.boundingBox.yMin - r2.y : ["s-resize", "se-resize", "sw-resize"].includes(this.direction) && (h2 = r2.y - this.boundingBox.yMax);
    let c2 = this.boundingBox.width ? 1 + d2 / this.boundingBox.width : 1, u2 = this.boundingBox.height ? 1 + h2 / this.boundingBox.height : 1;
    return this.keepRatio && (["n-resize", "s-resize"].includes(this.direction) ? c2 = u2 : (["e-resize", "w-resize"].includes(this.direction) || (c2 = Math.max(c2, u2)), u2 = c2)), this.scaleElement(this.interactElementsGroup.id, c2, u2), this.model.symbolsSelected.forEach((i3) => {
      this.scaleElement(i3.id, c2, u2);
    }), { scaleX: c2, scaleY: u2 };
  }
  async end(i2) {
    __privateGet(this, _t16).info("end", { point: i2 });
    const { scaleX: r2, scaleY: s2 } = this.continue(i2);
    this.editor.snaps.clearSnapToElementLines();
    const n2 = this.model.symbolsSelected.map((i3) => i3.clone());
    this.model.symbolsSelected.forEach((i3) => {
      this.applyToSymbol(i3, this.transformOrigin, r2, s2), this.editor.renderer.drawSymbol(i3), this.model.updateSymbol(i3);
    });
    const a2 = this.editor.extractStrokesFromSymbols(this.model.symbolsSelected);
    this.editor.recognizer.transformScale(a2.map((i3) => i3.id), r2, s2, this.transformOrigin.x, this.transformOrigin.y), this.editor.history.push(this.model, { scale: [{ symbols: n2, origin: { ...this.transformOrigin }, scaleX: r2, scaleY: s2 }] }), this.interactElementsGroup = void 0, this.editor.svgDebugger.apply();
  }
};
_t16 = new WeakMap();
var _t17;
var IIRotationManager = class {
  constructor(i2) {
    __privateAdd(this, _t17, LoggerManager.getLogger(d.TRANSFORMER));
    __publicField(this, "editor");
    __publicField(this, "interactElementsGroup");
    __publicField(this, "center");
    __publicField(this, "origin");
    __privateGet(this, _t17).info("constructor"), this.editor = i2;
  }
  get model() {
    return this.editor.model;
  }
  applyToStroke(i2, r2, s2) {
    return i2.pointers.forEach((i3) => {
      const { x: n2, y: a2 } = computeRotatedPoint(i3, r2, s2);
      i3.x = n2, i3.y = a2;
    }), i2;
  }
  applyToShape(i2, r2, s2) {
    switch (i2.kind) {
      case M.Ellipse:
        return i2.center = computeRotatedPoint(i2.center, r2, s2), i2.orientation = (i2.orientation + s2) % (2 * Math.PI), i2;
      case M.Circle:
        return i2.center = computeRotatedPoint(i2.center, r2, s2), i2;
      case M.Polygon:
        return i2.points.forEach((i3) => {
          const { x: n2, y: a2 } = computeRotatedPoint(i3, r2, s2);
          i3.x = n2, i3.y = a2;
        }), i2;
      default:
        throw new Error(`Can't apply rotate on shape, kind unknow: ${JSON.stringify(i2)}`);
    }
  }
  applyToEdge(i2, r2, s2) {
    switch (i2.kind) {
      case I.Arc:
        return i2.phi = (i2.phi - s2) % (2 * Math.PI), i2.center = computeRotatedPoint(i2.center, r2, s2), i2;
      case I.Line:
        return i2.start = computeRotatedPoint(i2.start, r2, s2), i2.end = computeRotatedPoint(i2.end, r2, s2), i2;
      case I.PolyEdge:
        return i2.points = i2.points.map((i3) => computeRotatedPoint(i3, r2, s2)), i2;
      default:
        throw new Error(`Can't apply rotate on edge, kind unknow: ${JSON.stringify(i2)}`);
    }
  }
  applyOnText(i2, r2, s2) {
    var _a;
    return i2.rotation = { degree: convertRadianToDegree(s2) + (((_a = i2.rotation) == null ? void 0 : _a.degree) || 0), center: r2 }, this.editor.texter.updateBounds(i2);
  }
  applyOnGroup(i2, r2, s2) {
    return i2.children.forEach((i3) => this.applyToSymbol(i3, r2, s2)), i2;
  }
  applyOnRecognizedSymbol(i2, r2, s2) {
    return i2.strokes.forEach((i3) => this.applyToStroke(i3, r2, s2)), i2;
  }
  applyToSymbol(i2, r2, s2) {
    switch (i2.type) {
      case E.Stroke:
        return this.applyToStroke(i2, r2, s2);
      case E.Shape:
        return this.applyToShape(i2, r2, s2);
      case E.Edge:
        return this.applyToEdge(i2, r2, s2);
      case E.Text:
        return this.applyOnText(i2, r2, s2);
      case E.Group:
        return this.applyOnGroup(i2, r2, s2);
      case E.Recognized:
        return this.applyOnRecognizedSymbol(i2, r2, s2);
      default:
        throw new Error(`Can't apply rotate on symbol, type unknow: ${JSON.stringify(i2)}`);
    }
  }
  setTransformOrigin(i2, r2, s2) {
    this.editor.renderer.setAttribute(i2, "transform-origin", `${r2}px ${s2}px`);
  }
  rotateElement(i2, r2) {
    __privateGet(this, _t17).info("rotateElement", { id: i2, degree: r2 }), this.editor.renderer.setAttribute(i2, "transform", `rotate(${r2})`);
  }
  start(i2, r2) {
    __privateGet(this, _t17).info("start", { target: i2 }), this.interactElementsGroup = i2.closest(`[role=${s.InteractElementsGroup}]`);
    const n2 = Box.createFromPoints(this.model.symbolsSelected.flatMap((i3) => i3.vertices));
    this.center = { x: n2.xMin + n2.width / 2, y: n2.yMid }, this.origin = r2, this.setTransformOrigin(this.interactElementsGroup.id, this.center.x, this.center.y), this.model.symbolsSelected.forEach((i3) => {
      this.setTransformOrigin(i3.id, this.center.x, this.center.y);
    });
  }
  continue(i2) {
    if (__privateGet(this, _t17).info("continue", { point: i2 }), !this.interactElementsGroup) throw new Error("Can't rotate, you must call start before");
    let r2 = Math.round(convertRadianToDegree(computeAngleRadian(this.origin, this.center, i2)));
    return r2 = this.editor.snaps.snapRotation(r2), i2.x - this.center.x < 0 && (r2 = 360 - r2), this.rotateElement(this.interactElementsGroup.id, r2), this.model.symbolsSelected.forEach((i3) => {
      this.rotateElement(i3.id, r2);
    }), r2;
  }
  async end(i2) {
    __privateGet(this, _t17).info("end", { point: i2 });
    const r2 = convertDegreeToRadian(this.continue(i2)) % (2 * Math.PI), s2 = this.model.symbolsSelected.map((i3) => i3.clone());
    this.model.symbolsSelected.forEach((i3) => {
      this.applyToSymbol(i3, this.center, r2), this.editor.renderer.drawSymbol(i3), this.model.updateSymbol(i3);
    });
    const n2 = this.editor.extractStrokesFromSymbols(this.model.symbolsSelected);
    this.editor.recognizer.transformRotate(n2.map((i3) => i3.id), r2, this.center.x, this.center.y), this.editor.history.push(this.model, { rotate: [{ symbols: s2, angle: r2, center: { ...this.center } }] }), this.interactElementsGroup = void 0, this.editor.svgDebugger.apply();
  }
};
_t17 = new WeakMap();
var fe = { capture: false, passive: true };
var xe = { listenerOptions: fe, xyFloatPrecision: 0, timestampFloatPrecision: 0, delayLongTouch: 500 };
var _t18;
var PointerEventGrabber = class {
  constructor(i2) {
    __privateAdd(this, _t18, LoggerManager.getLogger(d.GRABBER));
    __publicField(this, "configuration");
    __publicField(this, "layerCapture");
    __publicField(this, "capturing", false);
    __publicField(this, "pointerType");
    __publicField(this, "prevent", (i2) => i2.preventDefault());
    __publicField(this, "onPointerDown");
    __publicField(this, "onPointerMove");
    __publicField(this, "onPointerUp");
    __publicField(this, "onContextMenu");
    __publicField(this, "pointerDownHandler", (i2) => {
      const r2 = this.getPointerInfos(i2);
      __privateGet(this, _t18).debug("pointerDownHandler", r2), 0 === r2.button && 1 === i2.buttons && (this.capturing = true, this.pointerType = i2.pointerType, __privateGet(this, _t18).level === l.INFO && __privateGet(this, _t18).info("pointerDownHandler", r2), this.onPointerDown && this.onPointerDown(r2));
    });
    __publicField(this, "pointerMoveHandler", (i2) => {
      const r2 = this.getPointerInfos(i2);
      __privateGet(this, _t18).debug("pointerMoveHandler", r2), this.capturing && this.pointerType === i2.pointerType && (__privateGet(this, _t18).level === l.INFO && __privateGet(this, _t18).info("pointerMoveHandler", r2), this.onPointerMove && this.onPointerMove(r2));
    });
    __publicField(this, "pointerUpHandler", (i2) => {
      const r2 = this.getPointerInfos(i2);
      __privateGet(this, _t18).debug("pointerUpHandler", r2), this.capturing && this.pointerType === i2.pointerType && (__privateGet(this, _t18).level === l.INFO && __privateGet(this, _t18).info("pointerUpHandler", r2), this.pointerType = void 0, this.capturing = false, this.onPointerUp && this.onPointerUp(r2));
    });
    __publicField(this, "pointerOutHandler", (i2) => {
      const r2 = this.getPointerInfos(i2);
      __privateGet(this, _t18).debug("pointerOutHandler", r2), this.capturing && this.pointerType === i2.pointerType && !this.layerCapture.contains(i2.target) && (__privateGet(this, _t18).level === l.INFO && __privateGet(this, _t18).info("pointerOutHandler", r2), this.pointerType = void 0, this.capturing = false, this.onPointerUp && this.onPointerUp(r2));
    });
    __publicField(this, "contextMenuHandler", (i2) => {
      const r2 = this.getPointerInfos(i2);
      __privateGet(this, _t18).debug("contextMenuHandler", r2), i2.target && this.onContextMenu && (__privateGet(this, _t18).level === l.INFO && __privateGet(this, _t18).info("contextMenuHandler", r2), this.onContextMenu(r2));
    });
    __privateGet(this, _t18).info("constructor", { configuration: i2 }), this.configuration = i2;
  }
  roundFloat(i2, r2) {
    if (r2 >= 0) {
      const s2 = Math.pow(10, r2);
      return Math.round(i2 / s2) * s2;
    }
    return __privateGet(this, _t18).debug("roundFloat", { oneFloat: i2, requestedFloatPrecision: r2 }), i2;
  }
  extractPointer(i2) {
    let r2, s2;
    ({ clientX: r2, clientY: s2 } = "changedTouches" in i2 ? i2.changedTouches[0] : i2);
    const n2 = this.layerCapture.getBoundingClientRect(), a2 = { x: this.roundFloat(r2 - n2.left - this.layerCapture.clientLeft + this.layerCapture.scrollLeft, this.configuration.xyFloatPrecision), y: this.roundFloat(s2 - n2.top - this.layerCapture.clientTop + this.layerCapture.scrollTop, this.configuration.xyFloatPrecision), t: this.roundFloat(Date.now(), this.configuration.timestampFloatPrecision), p: i2.pressure };
    return __privateGet(this, _t18).debug("extractPointer", { event: i2, pointer: a2 }), a2;
  }
  getPointerInfos(i2) {
    return { clientX: i2.clientX, clientY: i2.clientY, isPrimary: i2.isPrimary, type: i2.type, target: i2.target, pointerType: i2.pointerType, pointer: this.extractPointer(i2), button: i2.button, buttons: i2.buttons };
  }
  stopPointerEvent() {
    this.capturing = false, this.pointerType = void 0;
  }
  attach(i2) {
    __privateGet(this, _t18).info("attach", { domElement: i2 }), this.layerCapture && this.detach(), this.layerCapture = i2, this.layerCapture.style.setProperty("touch-action", "none"), this.layerCapture.addEventListener("pointerdown", this.pointerDownHandler, this.configuration.listenerOptions), this.layerCapture.addEventListener("pointermove", this.pointerMoveHandler, this.configuration.listenerOptions), this.layerCapture.addEventListener("pointerup", this.pointerUpHandler, this.configuration.listenerOptions), this.layerCapture.addEventListener("pointercancel", this.pointerUpHandler, this.configuration.listenerOptions), this.layerCapture.addEventListener("pointerleave", this.pointerUpHandler, this.configuration.listenerOptions), this.layerCapture.addEventListener("pointerout", this.pointerOutHandler, this.configuration.listenerOptions), this.layerCapture.addEventListener("contextmenu", this.contextMenuHandler);
  }
  detach() {
    var _a, _b2, _c2, _d6, _e2, _f2, _g2, _h2;
    __privateGet(this, _t18).info("detach"), (_a = this.layerCapture) == null ? void 0 : _a.style.removeProperty("touch-action"), (_b2 = this.layerCapture) == null ? void 0 : _b2.removeEventListener("pointerdown", this.pointerDownHandler, this.configuration.listenerOptions), (_c2 = this.layerCapture) == null ? void 0 : _c2.removeEventListener("pointermove", this.pointerMoveHandler, this.configuration.listenerOptions), (_d6 = this.layerCapture) == null ? void 0 : _d6.removeEventListener("pointerup", this.pointerUpHandler, this.configuration.listenerOptions), (_e2 = this.layerCapture) == null ? void 0 : _e2.removeEventListener("pointerleave", this.pointerUpHandler, this.configuration.listenerOptions), (_f2 = this.layerCapture) == null ? void 0 : _f2.removeEventListener("pointercancel", this.pointerUpHandler, this.configuration.listenerOptions), (_g2 = this.layerCapture) == null ? void 0 : _g2.removeEventListener("pointerout", this.pointerOutHandler, this.configuration.listenerOptions), (_h2 = this.layerCapture) == null ? void 0 : _h2.removeEventListener("contextmenu", this.contextMenuHandler);
  }
};
_t18 = new WeakMap();
var _t19, _l;
var IISelectionManager = class {
  constructor(i2) {
    __privateAdd(this, _t19, LoggerManager.getLogger(d.SELECTION));
    __publicField(this, "grabber");
    __publicField(this, "editor");
    __privateAdd(this, _l, "selecting-rect");
    __publicField(this, "startSelectionPoint");
    __publicField(this, "endSelectionPoint");
    __publicField(this, "selectedGroup");
    __privateGet(this, _t19).info("constructor"), this.editor = i2, this.grabber = new PointerEventGrabber(i2.configuration.grabber), this.grabber.onPointerDown = this.start.bind(this), this.grabber.onPointerMove = this.continue.bind(this), this.grabber.onPointerUp = this.end.bind(this), this.grabber.onContextMenu = this.onContextMenu.bind(this);
  }
  get model() {
    return this.editor.model;
  }
  get renderer() {
    return this.editor.renderer;
  }
  get rotator() {
    return this.editor.rotator;
  }
  get translator() {
    return this.editor.translator;
  }
  get resizer() {
    return this.editor.resizer;
  }
  get selectionBox() {
    if (this.startSelectionPoint && this.endSelectionPoint) return Box.createFromPoints([this.startSelectionPoint, this.endSelectionPoint]);
  }
  attach(i2) {
    this.removeSelectedGroup(), this.grabber.attach(i2);
  }
  detach() {
    this.removeSelectedGroup(), this.grabber.detach();
  }
  drawSelectingRect(i2) {
    this.clearSelectingRect();
    const r2 = { id: __privateGet(this, _l), fill: "transparent", stroke: "grey", opacity: "0.25" };
    this.renderer.appendElement(SVGBuilder.createRect(i2, r2));
  }
  clearSelectingRect() {
    this.renderer.clearElements({ attrs: { id: __privateGet(this, _l) } });
  }
  getPoint(i2) {
    const { clientLeft: r2, scrollLeft: s2, clientTop: n2, scrollTop: a2 } = this.renderer.parent, l2 = this.renderer.parent.getBoundingClientRect();
    return { x: i2.clientX - l2.left - r2 + s2, y: i2.clientY - l2.top - n2 + a2 };
  }
  createTranslateRect(i2) {
    const r2 = { role: s.Translate, style: "cursor:move", fill: "transparent", stroke: "transparent" }, n2 = { height: i2.height, width: i2.width, x: i2.x, y: i2.y }, a2 = SVGBuilder.createRect(n2, r2), handler = (i3) => {
      i3.preventDefault(), i3.stopPropagation(), this.translator.continue(this.getPoint(i3));
    }, endHandler = (i3) => {
      i3.preventDefault(), i3.stopPropagation(), this.translator.end(this.getPoint(i3)), this.renderer.layer.removeEventListener("pointermove", handler), this.renderer.layer.removeEventListener("pointercancel", endHandler), this.renderer.layer.removeEventListener("pointerleave", endHandler), this.renderer.layer.removeEventListener("pointerup", endHandler), this.renderer.layer.style.cursor = "", this.resetSelectedGroup(this.model.symbolsSelected);
    };
    return a2.addEventListener("pointerdown", (i3) => {
      0 === i3.button && 1 === i3.buttons && (i3.preventDefault(), i3.stopPropagation(), this.hideInteractElements(), this.translator.start(i3.target, this.getPoint(i3)), this.renderer.layer.addEventListener("pointermove", handler), this.renderer.layer.addEventListener("pointercancel", endHandler), this.renderer.layer.addEventListener("pointerleave", endHandler), this.renderer.layer.addEventListener("pointerup", endHandler), this.renderer.layer.style.cursor = "move");
    }), a2;
  }
  createRotateGroup(i2) {
    const r2 = SVGBuilder.createGroup({ role: s.Rotate, "vector-effect": "non-scaling-size", style: "cursor:pointer;", opacity: "1" }), n2 = { x: i2.x + i2.width / 2, y: i2.y - 40 }, l2 = { role: s.Rotate, "stroke-width": "2", stroke: "black", fill: "white" };
    r2.appendChild(SVGBuilder.createCircle(n2, 8, l2));
    const d2 = { role: s.Rotate, fill: "black" };
    r2.appendChild(SVGBuilder.createCircle(n2, 4, d2));
    const h2 = { role: s.Rotate, stroke: "black", "stroke-width": "2" };
    r2.appendChild(SVGBuilder.createLine({ x: n2.x, y: n2.y + 8 }, { x: n2.x, y: i2.y - a }, h2));
    const handler = (i3) => {
      i3.preventDefault(), i3.stopPropagation(), this.rotator.continue(this.getPoint(i3));
    }, endHandler = (i3) => {
      i3.preventDefault(), i3.stopPropagation(), this.rotator.end(this.getPoint(i3)), this.renderer.layer.removeEventListener("pointermove", handler), this.renderer.layer.removeEventListener("pointercancel", endHandler), this.renderer.layer.removeEventListener("pointerleave", endHandler), this.renderer.layer.removeEventListener("pointerup", endHandler), this.resetSelectedGroup(this.model.symbolsSelected);
    };
    return r2.addEventListener("pointerdown", (i3) => {
      0 === i3.button && 1 === i3.buttons && (i3.preventDefault(), i3.stopPropagation(), this.hideInteractElements(), this.rotator.start(i3.target, this.getPoint(i3)), this.renderer.layer.addEventListener("pointermove", handler), this.renderer.layer.addEventListener("pointercancel", endHandler), this.renderer.layer.addEventListener("pointerleave", endHandler), this.renderer.layer.addEventListener("pointerup", endHandler));
    }), r2;
  }
  createResizeGroup(i2) {
    const r2 = SVGBuilder.createGroup({ role: s.Resize, "vector-effect": "non-scaling-size", "stroke-width": "4", stroke: "#3e68ff" }), n2 = { x: i2.x - a, y: i2.y - a }, l2 = { x: i2.x + i2.width + a, y: i2.y - a }, d2 = { x: i2.x + i2.width + a, y: i2.y + i2.height + a }, h2 = { x: i2.x - a, y: i2.y + i2.height + a }, bindEl = (i3, r3, s2) => {
      const handler = (i4) => {
        i4.preventDefault(), i4.stopPropagation(), this.resizer.continue(this.getPoint(i4));
      }, endHandler = (i4) => {
        i4.preventDefault(), i4.stopPropagation(), this.resizer.end(this.getPoint(i4)), this.renderer.layer.removeEventListener("pointermove", handler), this.renderer.layer.removeEventListener("pointercancel", endHandler), this.renderer.layer.removeEventListener("pointerleave", endHandler), this.renderer.layer.removeEventListener("pointerup", endHandler), this.renderer.layer.style.cursor = "", this.resetSelectedGroup(this.model.symbolsSelected);
      };
      i3.addEventListener("pointerdown", (i4) => {
        0 === i4.button && 1 === i4.buttons && (i4.preventDefault(), i4.stopPropagation(), this.hideInteractElements(), this.renderer.layer.style.cursor = s2, this.resizer.start(i4.target, r3), this.renderer.layer.addEventListener("pointermove", handler), this.renderer.layer.addEventListener("pointercancel", endHandler), this.renderer.layer.addEventListener("pointerleave", endHandler), this.renderer.layer.addEventListener("pointerup", endHandler));
      });
    };
    [{ direction: "n-resize", p1: n2, p2: l2, transformOrigin: { x: i2.x + i2.width / 2, y: i2.y + i2.height } }, { direction: "e-resize", p1: l2, p2: d2, transformOrigin: { x: i2.x, y: i2.y + i2.height / 2 } }, { direction: "s-resize", p1: h2, p2: d2, transformOrigin: { x: i2.x + i2.width / 2, y: i2.y } }, { direction: "w-resize", p1: n2, p2: h2, transformOrigin: { x: i2.x + i2.width, y: i2.y + i2.height / 2 } }].forEach((i3) => {
      const n3 = { role: s.Resize, "resize-direction": i3.direction, "transform-origin": JSON.stringify(i3.transformOrigin), style: `cursor:${i3.direction};` }, a2 = SVGBuilder.createLine(i3.p1, i3.p2, n3);
      bindEl(a2, i3.transformOrigin, i3.direction), r2.appendChild(a2);
    });
    return [{ direction: "nw-resize", p: n2, transformOrigin: { x: i2.x + i2.width, y: i2.y + i2.height } }, { direction: "ne-resize", p: l2, transformOrigin: { x: i2.x, y: i2.y + i2.height } }, { direction: "se-resize", p: d2, transformOrigin: { x: i2.x, y: i2.y } }, { direction: "sw-resize", p: h2, transformOrigin: { x: i2.x + i2.width, y: i2.y } }].forEach((i3) => {
      const n3 = { "stroke-width": "4", role: s.Resize, "resize-direction": i3.direction, "transform-origin": JSON.stringify(i3.transformOrigin), transform: "scale(1, 1)", fill: "white", style: `cursor:${i3.direction};` }, a2 = SVGBuilder.createCircle(i3.p, 5, n3);
      bindEl(a2, i3.transformOrigin, i3.direction), r2.appendChild(a2);
    }), r2;
  }
  createInteractElementsGroup(i2) {
    if (__privateGet(this, _t19).info("createInteractElementsGroup", { symbols: i2 }), !i2.length) return;
    const r2 = i2.map((i3) => ({ symbol: i3, element: this.renderer.getElementById(i3.id) })), n2 = Box.createFromBoxes(i2.map((i3) => ({ x: i3.bounds.x - (i3.style.width || 1), y: i3.bounds.y - (i3.style.width || 1), height: i3.bounds.height + 2 * (i3.style.width || 1), width: i3.bounds.width + 2 * (i3.style.width || 1) }))), a2 = Box.createFromPoints(i2.flatMap((i3) => i3.vertices)), l2 = Box.createFromBoxes([n2, a2]), d2 = { id: `selected-${Date.now()}`, role: s.InteractElementsGroup }, h2 = SVGBuilder.createGroup(d2);
    h2.appendChild(this.createTranslateRect(l2)), h2.appendChild(this.createResizeGroup(l2)), h2.appendChild(this.createRotateGroup(l2));
    const c2 = { style: "pointer-events: none", fill: "transparent", stroke: "#3e68ff", "stroke-width": "1", "stroke-dasharray": "4", "vector-effect": "non-scaling-size", transform: "rotate(0, 0, 0)" };
    return r2.forEach((i3) => {
      var _a, _b2, _c2;
      if (i3.element) {
        const r3 = { x: i3.symbol.bounds.x - (i3.symbol.style.width || 1), y: i3.symbol.bounds.y - (i3.symbol.style.width || 1), height: i3.symbol.bounds.height + 2 * (i3.symbol.style.width || 1), width: i3.symbol.bounds.width + 2 * (i3.symbol.style.width || 1) };
        if (i3.symbol.type === E.Text) {
          const r4 = i3.symbol;
          c2.transform = `rotate(${((_a = r4.rotation) == null ? void 0 : _a.degree) || 0}, ${((_b2 = r4.rotation) == null ? void 0 : _b2.center.x) || 0}, ${((_c2 = r4.rotation) == null ? void 0 : _c2.center.y) || 0})`;
        } else c2.transform = "rotate(0, 0, 0)";
        h2.prepend(SVGBuilder.createRect(r3, c2));
      }
    }), h2;
  }
  createEdgeResizeGroup(i2) {
    const r2 = SVGBuilder.createGroup({ role: s.Resize, "vector-effect": "non-scaling-size", "stroke-width": "4", stroke: "#3e68ff" }), n2 = { role: s.Resize, "stroke-width": "4", stroke: "#3e68ff", fill: "white", style: "cursor:grab;" }, bindEl = (r3, s2) => {
      const handler = (r4) => {
        r4.preventDefault(), r4.stopPropagation();
        const n3 = this.getPoint(r4), { x: a2, y: l2 } = this.editor.snaps.snapResize(n3);
        i2.vertices[s2].x = a2, i2.vertices[s2].y = l2, this.model.updateSymbol(i2), this.renderer.drawSymbol(i2);
      }, endHandler = (r4) => {
        r4.preventDefault(), r4.stopPropagation();
        const n3 = this.getPoint(r4), { x: a2, y: l2 } = this.editor.snaps.snapResize(n3);
        i2.vertices[s2].x = a2, i2.vertices[s2].y = l2, this.renderer.layer.style.cursor = "", this.editor.updateSymbol(i2), this.renderer.layer.removeEventListener("pointermove", handler), this.renderer.layer.removeEventListener("pointercancel", endHandler), this.renderer.layer.removeEventListener("pointerleave", endHandler), this.renderer.layer.removeEventListener("pointerup", endHandler), this.editor.snaps.clearSnapToElementLines(), this.resetSelectedGroup(this.model.symbolsSelected);
      };
      r3.addEventListener("pointerdown", (i3) => {
        0 === i3.button && 1 === i3.buttons && (this.renderer.layer.style.cursor = "grabbing", this.hideInteractElements(), i3.preventDefault(), i3.stopPropagation(), this.renderer.layer.addEventListener("pointermove", handler), this.renderer.layer.addEventListener("pointercancel", endHandler), this.renderer.layer.addEventListener("pointerleave", endHandler), this.renderer.layer.addEventListener("pointerup", endHandler));
      });
    };
    return i2.vertices.forEach((i3, s2) => {
      const a2 = SVGBuilder.createCircle(i3, 5, n2);
      bindEl(a2, s2), r2.appendChild(a2);
    }), r2;
  }
  createInteractEdgeGroup(i2) {
    __privateGet(this, _t19).info("createInteractEdgeGroup", { edge: i2 });
    const r2 = { id: `selected-${Date.now()}`, role: s.InteractElementsGroup }, n2 = SVGBuilder.createGroup(r2);
    return n2.appendChild(this.createTranslateRect(i2.bounds)), n2.appendChild(this.createEdgeResizeGroup(i2.clone())), n2;
  }
  drawSelectedGroup(i2) {
    if (i2.length) {
      if (1 === i2.length && i2[0].type === E.Edge ? this.selectedGroup = this.createInteractEdgeGroup(i2[0]) : this.selectedGroup = this.createInteractElementsGroup(i2), this.selectedGroup) {
        this.renderer.layer.appendChild(this.selectedGroup);
        const i3 = this.selectedGroup.getBBox();
        this.editor.menu.context.position.x = i3.x + i3.width / 2 - this.renderer.parent.clientLeft, this.editor.menu.context.position.y = i3.y + i3.height - this.renderer.parent.clientTop, this.editor.menu.context.show();
      }
      this.editor.menu.update();
    }
  }
  resetSelectedGroup(i2) {
    __privateGet(this, _t19).info("resetSelectedGroup", { symbols: i2 }), this.removeSelectedGroup(), this.drawSelectedGroup(i2);
  }
  removeSelectedGroup() {
    var _a;
    __privateGet(this, _t19).info("removeSelectedGroup"), this.editor.menu.context.hide(), (_a = this.selectedGroup) == null ? void 0 : _a.remove(), this.selectedGroup = void 0;
  }
  hideInteractElements() {
    var _a;
    this.editor.menu.context.hide();
    const i2 = `[role=${s.Resize}],[role=${s.Rotate}],[role=${s.Translate}]`;
    (_a = this.selectedGroup) == null ? void 0 : _a.querySelectorAll(i2).forEach((i3) => {
      i3.setAttribute("visibility", "hidden");
    });
  }
  start(i2) {
    this.removeSelectedGroup(), this.startSelectionPoint = i2.pointer, this.endSelectionPoint = i2.pointer, this.drawSelectingRect(this.selectionBox);
  }
  continue(i2) {
    if (!this.startSelectionPoint) throw new Error("You need to call startSelectionByBox before");
    this.endSelectionPoint = i2.pointer;
    const r2 = [];
    return this.model.symbols.forEach((i3) => {
      i3.selected !== i3.overlaps(this.selectionBox) && (i3.selected = i3.overlaps(this.selectionBox), r2.push(i3), this.renderer.drawSymbol(i3));
    }), this.drawSelectingRect(this.selectionBox), r2;
  }
  end(i2) {
    const r2 = this.continue(i2);
    return this.startSelectionPoint = void 0, this.endSelectionPoint = void 0, this.clearSelectingRect(), this.drawSelectedGroup(this.model.symbolsSelected), this.editor.event.emitSelected(this.model.symbolsSelected), this.editor.menu.style.update(), r2;
  }
  async onContextMenu(i2) {
    let r2 = false, s2 = i2.target;
    const n2 = [E.Edge.toString(), E.Shape.toString(), E.Stroke.toString(), E.Text.toString()];
    for (; s2 && "svg" !== s2.tagName && !r2; ) n2.includes(s2.getAttribute("type")) ? r2 = true : s2 = s2.parentElement;
    this.editor.unselectAll(), (s2 == null ? void 0 : s2.id) ? (this.model.selectSymbol(s2.id), this.renderer.drawSymbol(this.model.symbolsSelected[0]), this.drawSelectedGroup(this.model.symbolsSelected), this.editor.updateLayerUI()) : (this.editor.menu.context.position.x = i2.pointer.x + this.renderer.parent.clientLeft, this.editor.menu.context.position.y = i2.pointer.y + this.renderer.parent.clientTop, this.editor.menu.context.show());
  }
};
_t19 = new WeakMap();
_l = new WeakMap();
var _t20;
var IITextManager = class {
  constructor(i2) {
    __privateAdd(this, _t20, LoggerManager.getLogger(d.CONVERTER));
    __publicField(this, "editor");
    __privateGet(this, _t20).info("constructor"), this.editor = i2;
  }
  get renderer() {
    return this.editor.renderer;
  }
  get rowHeight() {
    return this.editor.configuration.rendering.guides.gap;
  }
  get model() {
    return this.editor.model;
  }
  drawSymbolHidden(i2) {
    var _a;
    const r2 = i2.clone();
    r2.id = "text-to-measure", r2.chars.forEach((i3) => i3.id += "-to-measure"), r2.decorators = [], (_a = this.renderer.layer.querySelector(`#${r2.id}`)) == null ? void 0 : _a.remove();
    const s2 = this.renderer.buildElementFromSymbol(r2);
    return s2.setAttribute("visibility", "hidden"), this.renderer.prependElement(s2), s2;
  }
  setCharsBounds(i2, r2) {
    const s2 = r2.querySelector("text");
    if (s2) for (let r3 = 0; r3 < s2.getNumberOfChars(); r3++) {
      const n2 = i2.chars.at(r3);
      if (n2) {
        const i3 = s2.getExtentOfChar(r3);
        n2.bounds = new Box(i3);
      }
    }
    return i2;
  }
  setBounds(i2) {
    const r2 = this.drawSymbolHidden(i2);
    i2.bounds = this.getElementBoundingBox(r2), this.setCharsBounds(i2, r2);
  }
  getElementBoundingBox(i2) {
    return new Box(i2.querySelector("text").getBBox({ stroke: true, markers: true, clipped: true, fill: true }));
  }
  getBoundingBox(i2) {
    const r2 = this.drawSymbolHidden(i2);
    return this.getElementBoundingBox(r2);
  }
  getSpaceWidth(i2) {
    var _a;
    const r2 = new Box({ height: 0, width: 0, x: 0, y: 0 }), s2 = { id: "text-char-space", label: "-", color: "", fontSize: i2, fontWeight: "normal", bounds: r2 };
    return (_a = this.getBoundingBox(new IIText([s2], { x: 0, y: 0 }, r2))) == null ? void 0 : _a.width;
  }
  updateBounds(i2) {
    return this.setBounds(i2), this.model.updateSymbol(i2), i2;
  }
  moveTextAfter(i2, r2) {
    const s2 = this.model.getSymbolsByRowOrdered().find((r3) => r3.rowIndex === this.model.getSymbolRowIndex(i2));
    if (s2) {
      const n2 = s2.symbols.filter((r3) => r3.type === E.Text && r3.bounds.xMid > i2.bounds.xMid);
      return n2.forEach((i3) => {
        i3.point.x += r2, this.updateBounds(i3), this.model.updateSymbol(i3), this.renderer.drawSymbol(i3);
      }), n2;
    }
  }
};
_t20 = new WeakMap();
var _t21;
var IITranslateManager = class {
  constructor(i2) {
    __privateAdd(this, _t21, LoggerManager.getLogger(d.TRANSFORMER));
    __publicField(this, "editor");
    __publicField(this, "interactElementsGroup");
    __publicField(this, "transformOrigin");
    __privateGet(this, _t21).info("constructor"), this.editor = i2;
  }
  get model() {
    return this.editor.model;
  }
  applyToStroke(i2, r2, s2) {
    return i2.pointers.forEach((i3) => {
      i3.x += r2, i3.y += s2;
    }), i2;
  }
  applyToShape(i2, r2, s2) {
    switch (i2.kind) {
      case M.Ellipse:
      case M.Circle:
        return i2.center.x += r2, i2.center.y += s2, i2;
      case M.Polygon:
        return i2.points.forEach((i3) => {
          i3.x += r2, i3.y += s2;
        }), i2;
      default:
        throw new Error(`Can't apply translate on shape, kind unknow: ${JSON.stringify(i2)}`);
    }
  }
  applyToEdge(i2, r2, s2) {
    switch (i2.kind) {
      case I.Arc:
        return i2.center.x += r2, i2.center.y += s2, i2;
      case I.Line:
        return i2.start.x += r2, i2.start.y += s2, i2.end.x += r2, i2.end.y += s2, i2;
      case I.PolyEdge:
        return i2.points.forEach((i3) => {
          i3.x += r2, i3.y += s2;
        }), i2;
    }
    return i2;
  }
  applyOnText(i2, r2, s2) {
    return i2.rotation && (i2.rotation.center = { x: i2.rotation.center.x + r2, y: i2.rotation.center.y + s2 }), i2.point.x += r2, i2.point.y += s2, this.editor.texter.updateBounds(i2);
  }
  applyOnGroup(i2, r2, s2) {
    return i2.children.forEach((i3) => this.applyToSymbol(i3, r2, s2)), i2;
  }
  applyOnRecognizedSymbol(i2, r2, s2) {
    return i2.strokes.forEach((i3) => this.applyToStroke(i3, r2, s2)), i2.kind === T.Text && (i2.baseline += s2), i2;
  }
  applyToSymbol(i2, r2, s2) {
    switch (__privateGet(this, _t21).info("applyToSymbol", { symbol: i2, tx: r2, ty: s2 }), i2.type) {
      case E.Stroke:
        return this.applyToStroke(i2, r2, s2);
      case E.Shape:
        return this.applyToShape(i2, r2, s2);
      case E.Edge:
        return this.applyToEdge(i2, r2, s2);
      case E.Text:
        return this.applyOnText(i2, r2, s2);
      case E.Group:
        return this.applyOnGroup(i2, r2, s2);
      case E.Recognized:
        return this.applyOnRecognizedSymbol(i2, r2, s2);
      default:
        throw new Error(`Can't apply translate on symbol, type unknow: ${JSON.stringify(i2)}`);
    }
  }
  translate(i2, r2, s2, n2 = true) {
    __privateGet(this, _t21).info("translate", { symbols: i2, tx: r2, ty: s2 }), i2.forEach((i3) => {
      this.applyToSymbol(i3, r2, s2), this.model.updateSymbol(i3), this.editor.renderer.drawSymbol(i3);
    }), n2 && this.editor.history.push(this.model, { translate: [{ symbols: this.model.symbolsSelected, tx: r2, ty: s2 }] });
    const a2 = this.editor.extractStrokesFromSymbols(i2);
    return this.editor.recognizer.transformTranslate(a2.map((i3) => i3.id), r2, s2);
  }
  translateElement(i2, r2, s2) {
    __privateGet(this, _t21).info("translateElement", { id: i2, tx: r2, ty: s2 }), this.editor.renderer.setAttribute(i2, "transform", `translate(${r2},${s2})`);
  }
  start(i2, r2) {
    __privateGet(this, _t21).info("start", { origin: r2 }), this.interactElementsGroup = i2.closest(`[role=${s.InteractElementsGroup}]`), this.transformOrigin = r2;
  }
  continue(i2) {
    if (__privateGet(this, _t21).info("continue", { point: i2 }), !this.interactElementsGroup) throw new Error("Can't translate, you must call start before");
    let r2 = i2.x - this.transformOrigin.x, s2 = i2.y - this.transformOrigin.y;
    const n2 = this.editor.snaps.snapTranslate(r2, s2);
    return r2 = n2.x, s2 = n2.y, this.translateElement(this.interactElementsGroup.id, r2, s2), this.model.symbolsSelected.forEach((i3) => {
      this.translateElement(i3.id, r2, s2);
    }), { tx: r2, ty: s2 };
  }
  async end(i2) {
    __privateGet(this, _t21).info("end", { point: i2 });
    const { tx: r2, ty: s2 } = this.continue(i2);
    this.editor.snaps.clearSnapToElementLines(), this.translate(this.model.symbolsSelected, r2, s2), this.interactElementsGroup = void 0, this.editor.svgDebugger.apply();
  }
};
_t21 = new WeakMap();
var _t22, _d;
var IIWriteManager = class {
  constructor(i2) {
    __privateAdd(this, _t22, LoggerManager.getLogger(d.WRITE));
    __publicField(this, "grabber");
    __publicField(this, "editor");
    __privateAdd(this, _d, r.Pencil);
    __publicField(this, "detectGesture", true);
    __publicField(this, "currentSymbolOrigin");
    __privateGet(this, _t22).info("constructor"), this.editor = i2, this.grabber = new PointerEventGrabber(i2.configuration.grabber);
  }
  get tool() {
    return __privateGet(this, _d);
  }
  set tool(i2) {
    __privateSet(this, _d, i2), i2 !== r.Pencil ? this.editor.layers.root.classList.add("shape") : this.editor.layers.root.classList.remove("shape"), this.editor.unselectAll();
  }
  get model() {
    return this.editor.model;
  }
  get renderer() {
    return this.editor.renderer;
  }
  get history() {
    return this.editor.history;
  }
  get gestureManager() {
    return this.editor.gesture;
  }
  get snaps() {
    return this.editor.snaps;
  }
  get recognizer() {
    return this.editor.recognizer;
  }
  attach(i2) {
    this.grabber.attach(i2), this.grabber.onPointerDown = this.start.bind(this), this.grabber.onPointerMove = this.continue.bind(this), this.grabber.onPointerUp = this.end.bind(this);
  }
  detach() {
    this.grabber.detach();
  }
  needContextLessGesture(i2) {
    const r2 = this.editor.getSymbolsBounds([i2], 20);
    return this.detectGesture && this.model.symbols.some((i3) => {
      switch (i3.type) {
        case E.Recognized:
        case E.Stroke:
          return false;
        case E.Group:
          return !i3.containsOnlyStroke() && i3.bounds.overlaps(r2);
        default:
          return i3.bounds.overlaps(r2);
      }
    });
  }
  createCurrentSymbol(i2, s2, n2) {
    switch (__privateGet(this, _t22).debug("createCurrentSymbol", { pointer: i2, style: s2, pointerType: n2 }), this.tool) {
      case r.Pencil:
        this.model.currentSymbol = new IIStroke(s2, n2);
        break;
      case r.Rectangle:
        this.model.currentSymbol = IIShapePolygon.createRectangleBetweenPoints(i2, i2, s2);
        break;
      case r.Triangle:
        this.model.currentSymbol = IIShapePolygon.createTriangleBetweenPoints(i2, i2, s2);
        break;
      case r.Parallelogram:
        this.model.currentSymbol = IIShapePolygon.createParallelogramBetweenPoints(i2, i2, s2);
        break;
      case r.Rhombus:
        this.model.currentSymbol = IIShapePolygon.createRhombusBetweenPoints(i2, i2, s2);
        break;
      case r.Circle:
        this.model.currentSymbol = IIShapeCircle.createBetweenPoints(i2, i2, s2);
        break;
      case r.Ellipse:
        this.model.currentSymbol = IIShapeEllipse.createBetweenPoints(i2, i2, s2);
        break;
      case r.Line:
      case r.Arrow:
      case r.DoubleArrow: {
        let n3, a2;
        this.tool === r.Arrow ? a2 = C.Arrow : this.tool === r.DoubleArrow && (n3 = C.Arrow, a2 = C.Arrow), this.model.currentSymbol = new IIEdgeLine(i2, i2, n3, a2, s2);
        break;
      }
      default:
        throw new Error(`Can't create symbol, tool is unknow: "${this.tool}"`);
    }
    return this.updateCurrentSymbol(i2);
  }
  updateCurrentSymbolShape(i2) {
    switch (this.tool) {
      case r.Rectangle:
        IIShapePolygon.updateRectangleBetweenPoints(this.model.currentSymbol, this.currentSymbolOrigin, i2);
        break;
      case r.Triangle:
        IIShapePolygon.updateTriangleBetweenPoints(this.model.currentSymbol, this.currentSymbolOrigin, i2);
        break;
      case r.Parallelogram:
        IIShapePolygon.updateParallelogramBetweenPoints(this.model.currentSymbol, this.currentSymbolOrigin, i2);
        break;
      case r.Rhombus:
        IIShapePolygon.updateRhombusBetweenPoints(this.model.currentSymbol, this.currentSymbolOrigin, i2);
        break;
      case r.Circle:
        IIShapeCircle.updateBetweenPoints(this.model.currentSymbol, this.currentSymbolOrigin, i2);
        break;
      case r.Ellipse:
        IIShapeEllipse.updateBetweenPoints(this.model.currentSymbol, this.currentSymbolOrigin, i2);
    }
  }
  updateCurrentSymbolEdge(i2) {
    const r2 = this.model.currentSymbol;
    if (r2.kind === I.Line) r2.end = i2;
  }
  updateCurrentSymbol(i2) {
    if (__privateGet(this, _t22).debug("updateCurrentSymbol", { pointer: i2 }), !this.model.currentSymbol) throw new Error("Can't update current symbol because currentSymbol is undefined");
    switch (this.model.currentSymbol.type) {
      case E.Stroke:
        this.model.currentSymbol.addPointer(i2);
        break;
      case E.Shape:
        this.updateCurrentSymbolShape(i2);
        break;
      case E.Edge:
        this.updateCurrentSymbolEdge(i2);
    }
    return this.model.currentSymbol;
  }
  start(i2) {
    __privateGet(this, _t22).info("startWriting", { info: i2 });
    const s2 = i2.pointer;
    if (this.tool !== r.Pencil) {
      const { x: i3, y: r2 } = this.snaps.snapResize(s2);
      s2.x = i3, s2.y = r2;
    }
    this.currentSymbolOrigin = s2, this.createCurrentSymbol(s2, this.editor.penStyle, i2.pointerType), this.renderer.drawSymbol(this.model.currentSymbol);
  }
  continue(i2) {
    __privateGet(this, _t22).info("continueWriting", { info: i2 });
    const s2 = i2.pointer;
    if (this.tool !== r.Pencil) {
      const { x: i3, y: r2 } = this.snaps.snapResize(s2);
      s2.x = i3, s2.y = r2;
    }
    this.updateCurrentSymbol(s2), this.renderer.drawSymbol(this.model.currentSymbol);
  }
  async interactWithBackend(i2) {
    const r2 = i2.clone();
    let s2;
    if (this.needContextLessGesture(i2) && (s2 = await this.gestureManager.getGestureFromContextLess(r2)), s2) this.history.pop(), this.recognizer.addStrokes([r2], this.detectGesture), await this.gestureManager.apply(r2, s2);
    else {
      const i3 = await this.recognizer.addStrokes([r2], this.detectGesture);
      i3 && (this.history.pop(), await this.gestureManager.apply(r2, i3));
    }
  }
  async end(i2) {
    __privateGet(this, _t22).info("finishWriting", { info: i2 });
    const s2 = i2.pointer;
    if (this.tool !== r.Pencil) {
      const { x: i3, y: r2 } = this.snaps.snapResize(s2);
      s2.x = i3, s2.y = r2;
    }
    const n2 = this.updateCurrentSymbol(s2);
    this.model.currentSymbol = void 0, this.currentSymbolOrigin = void 0, this.snaps.clearSnapToElementLines(), this.renderer.drawSymbol(n2), this.model.addSymbol(n2), this.history.push(this.model, { added: [n2] }), n2.type === E.Stroke && await this.interactWithBackend(n2);
  }
};
_t22 = new WeakMap();
_d = new WeakMap();
var _t23;
var IIEraseManager = class {
  constructor(i2) {
    __privateAdd(this, _t23, LoggerManager.getLogger(d.WRITE));
    __publicField(this, "grabber");
    __publicField(this, "editor");
    __publicField(this, "currentEraser");
    __privateGet(this, _t23).info("constructor"), this.editor = i2, this.grabber = new PointerEventGrabber(i2.configuration.grabber);
  }
  get model() {
    return this.editor.model;
  }
  get renderer() {
    return this.editor.renderer;
  }
  attach(i2) {
    this.grabber.attach(i2), this.grabber.onPointerDown = this.start.bind(this), this.grabber.onPointerMove = this.continue.bind(this), this.grabber.onPointerUp = this.end.bind(this);
  }
  detach() {
    this.grabber.detach();
  }
  start(i2) {
    __privateGet(this, _t23).info("startErase", { info: i2 }), this.currentEraser = new IIEraser(), this.currentEraser.pointers.push(i2.pointer), this.renderer.drawSymbol(this.currentEraser);
  }
  continue(i2) {
    if (__privateGet(this, _t23).info("continueErase", { info: i2 }), !this.currentEraser) throw new Error("Can't update current eraser because currentEraser is undefined");
    this.currentEraser.pointers.push(i2.pointer), this.renderer.drawSymbol(this.currentEraser);
    const r2 = { p1: this.currentEraser.pointers.at(-1), p2: this.currentEraser.pointers.at(-2) };
    this.model.symbols.forEach((i3) => {
      i3.isIntersected(r2) && (i3.deleting = true);
    }), this.model.symbolsToDelete.map((i3) => this.renderer.drawSymbol(i3));
  }
  async end(i2) {
    __privateGet(this, _t23).info("finishErasing", { info: i2 }), this.continue(i2), this.renderer.removeSymbol(this.currentEraser.id), this.editor.removeSymbols(this.model.symbolsToDelete.map((i3) => i3.id)), this.currentEraser = void 0;
  }
};
_t23 = new WeakMap();
var _t24, _h, _c, _u, _p, _g;
var IIDebugSVGManager = class {
  constructor(i2) {
    __privateAdd(this, _t24, LoggerManager.getLogger(d.SVGDEBUG));
    __privateAdd(this, _h, false);
    __privateAdd(this, _c, false);
    __privateAdd(this, _u, false);
    __privateAdd(this, _p, false);
    __privateAdd(this, _g, false);
    __publicField(this, "editor");
    __privateGet(this, _t24).info("constructor"), this.editor = i2;
  }
  get model() {
    return this.editor.model;
  }
  get renderer() {
    return this.editor.renderer;
  }
  get snapPointsVisibility() {
    return __privateGet(this, _h);
  }
  set snapPointsVisibility(i2) {
    __privateSet(this, _h, i2), this.debugSnapPoints();
  }
  get verticesVisibility() {
    return __privateGet(this, _c);
  }
  set verticesVisibility(i2) {
    __privateSet(this, _c, i2), this.debugVertices();
  }
  get boundingBoxVisibility() {
    return __privateGet(this, _u);
  }
  set boundingBoxVisibility(i2) {
    __privateSet(this, _u, i2), __privateGet(this, _u) ? this.showBoundingBox() : this.hideBoundingBox();
  }
  get recognitionBoxVisibility() {
    return __privateGet(this, _p);
  }
  set recognitionBoxVisibility(i2) {
    __privateSet(this, _p, i2), this.debugRecognitionBox();
  }
  get recognitionItemBoxVisibility() {
    return __privateGet(this, _g);
  }
  set recognitionItemBoxVisibility(i2) {
    __privateSet(this, _g, i2), this.debugRecognitionItemBox();
  }
  showSnapPoints() {
    __privateGet(this, _t24).info("showSnapPoints"), this.model.currentSymbol && this.model.currentSymbol.snapPoints.forEach((i2) => this.renderer.drawCircle(i2, 2, { fill: "blue", debug: "snap-points" })), this.model.symbols.forEach((i2) => i2.snapPoints.forEach((i3) => this.renderer.drawCircle(i3, 2, { fill: "blue", debug: "snap-points" })));
  }
  hideSnapPoints() {
    __privateGet(this, _t24).info("hideSnapPoints"), this.renderer.clearElements({ attrs: { debug: "snap-points" } });
  }
  debugSnapPoints() {
    this.hideSnapPoints(), this.snapPointsVisibility && this.showSnapPoints();
  }
  showVertices() {
    __privateGet(this, _t24).info("showVertices"), this.model.currentSymbol && this.model.currentSymbol.vertices.forEach((i2) => this.renderer.drawCircle(i2, 2, { fill: "red", debug: "vertices" })), this.model.symbols.forEach((i2) => i2.vertices.forEach((i3) => this.renderer.drawCircle(i3, 2, { fill: "red", debug: "vertices" })));
  }
  hideVertices() {
    __privateGet(this, _t24).info("hideVertices"), this.renderer.clearElements({ attrs: { debug: "vertices" } });
  }
  debugVertices() {
    this.hideVertices(), this.verticesVisibility && this.showVertices();
  }
  drawBoundingBox(i2) {
    const r2 = { style: "pointer-events: none", fill: "transparent", stroke: "red", "stroke-width": "1", "stroke-dasharray": "5 5", "vector-effect": "non-scaling-stroke", debug: "bounding-box" }, s2 = { style: "pointer-events: none", fill: "transparent", stroke: "orange", "stroke-width": "1", "stroke-dasharray": "0 5 0", "vector-effect": "non-scaling-stroke", debug: "bounding-box" };
    i2.forEach((i3) => {
      const n2 = this.renderer.getElementById(i3.id);
      if (n2) if (i3.type === E.Text) {
        const a2 = i3;
        let l2 = "";
        a2.rotation && (l2 = `rotate(${a2.rotation.degree}, ${a2.rotation.center.x}, ${a2.rotation.center.y})`), a2.chars.forEach((i4) => {
          const r3 = { ...s2, char: i4.label, transform: l2 };
          n2.insertAdjacentElement("beforebegin", SVGBuilder.createRect(i4.bounds, r3));
        });
        const d2 = { ...r2, symbol: i3.id, transform: l2 };
        n2.insertAdjacentElement("beforebegin", SVGBuilder.createRect(i3.bounds, d2));
      } else {
        const s3 = { ...r2, symbol: i3.id };
        n2.insertAdjacentElement("beforebegin", SVGBuilder.createRect(i3.bounds, s3));
      }
    });
  }
  showBoundingBox() {
    __privateGet(this, _t24).info("showBoundingBox"), this.model.currentSymbol && this.drawBoundingBox([this.model.currentSymbol]), this.drawBoundingBox(this.model.symbols);
  }
  hideBoundingBox() {
    __privateGet(this, _t24).info("hideBoundingBox"), this.renderer.clearElements({ attrs: { debug: "bounding-box" } });
  }
  debugBoundingBox() {
    this.hideBoundingBox(), this.boundingBoxVisibility && this.showBoundingBox();
  }
  drawRecognitionBox(i2, r2) {
    const s2 = "green", n2 = SVGBuilder.createGroup({ debug: "recognition-box" }), a2 = SVGBuilder.createRect(i2, { fill: "transparent", stroke: s2, style: pe.noSelection });
    n2.appendChild(a2);
    const l2 = SVGBuilder.createGroup({ id: `infos-group-${createUUID()}` }), d2 = i2.x + i2.width;
    let h2 = i2.y + 10;
    r2 == null ? void 0 : r2.forEach((i3) => {
      l2.appendChild(SVGBuilder.createText({ x: d2, y: h2 }, i3, { stroke: s2, style: pe.noSelection })), h2 += 20;
    }), n2.appendChild(l2), this.renderer.layer.appendChild(n2);
    const c2 = l2.getBBox(), u2 = { width: c2.width + 10, height: c2.height + 10, x: c2.x - 5, y: c2.y - 5 }, p2 = SVGBuilder.createRect(u2, { fill: "white", style: "cursor:move", stroke: s2 });
    l2.prepend(p2);
    const translateEl = (r3) => {
      r3.preventDefault(), r3.stopPropagation();
      const n3 = Number(this.renderer.getAttribute(l2.id, "originX")), a3 = Number(this.renderer.getAttribute(l2.id, "originY")), d3 = r3.clientX - n3, h3 = r3.clientY - a3;
      this.renderer.setAttribute(l2.id, "transform", `translate(${d3},${h3})`);
      const c3 = { width: u2.width, height: u2.height, x: u2.x + d3, y: u2.y + h3 };
      this.renderer.removeSymbol(`connection-${l2.id}`), this.renderer.drawConnectionBetweenBox(`connection-${l2.id}`, i2, c3, { stroke: s2, debug: "recognition-box-link" });
    };
    p2.addEventListener("pointerdown", (i3) => {
      i3.preventDefault(), i3.stopPropagation(), this.renderer.getAttribute(l2.id, "originX") || (this.renderer.setAttribute(l2.id, "originX", i3.clientX.toString()), this.renderer.setAttribute(l2.id, "originY", i3.clientY.toString())), this.renderer.layer.addEventListener("pointermove", translateEl), this.renderer.layer.addEventListener("pointerup", () => this.renderer.layer.removeEventListener("pointermove", translateEl)), this.renderer.layer.addEventListener("pointerleave", () => this.renderer.layer.removeEventListener("pointermove", translateEl)), this.renderer.layer.addEventListener("pointercancel", () => this.renderer.layer.removeEventListener("pointermove", translateEl));
    });
  }
  async showRecognitionBox() {
    var _a, _b2;
    __privateGet(this, _t24).info("showRecognitionBox"), await this.editor.export(["application/vnd.myscript.jiix"]);
    const i2 = (_a = this.model.exports) == null ? void 0 : _a["application/vnd.myscript.jiix"];
    if (__privateGet(this, _t24).debug("showRecognitionBox", { jiix: i2 }), i2) {
      if (!i2["bounding-box"]) return void __privateGet(this, _t24).warn("drawRecognitionBox", 'You must to enabled configuration.recognition.exports["bounding-box"]');
      (_b2 = i2.elements) == null ? void 0 : _b2.forEach((i3) => {
        var _a2;
        switch (i3.type) {
          case "Node":
            if (i3["bounding-box"]) {
              const r2 = convertBoundingBoxMillimeterToPixel(i3["bounding-box"]), s2 = ["bounding-box", "items", "id"], n2 = Object.keys(i3).filter((i4) => !s2.includes(i4)).map((r3) => `${r3}: ${JSON.stringify(i3[r3])}`);
              this.drawRecognitionBox(r2, n2);
            }
            break;
          case "Text":
            (_a2 = i3.words) == null ? void 0 : _a2.forEach((r2) => {
              if (r2 == null ? void 0 : r2["bounding-box"]) {
                const s2 = convertBoundingBoxMillimeterToPixel(r2["bounding-box"]);
                this.drawRecognitionBox(s2, [`type: ${i3.type}`, `candidates: ${JSON.stringify(r2.candidates || [])}`]);
              }
            });
            break;
          case "Edge":
            if (i3.kind === m.PolyEdge) {
              const r2 = [`type: ${i3.type}`, `kind: ${i3.kind}`];
              i3.edges.forEach((i4, s3) => {
                let n2 = `edge-${s3}: [{ x1: ${i4.x1}, y2: ${i4.y1} },{ x2: ${i4.x2}, y2: ${i4.y2} }]`;
                i4.p1Decoration && (n2 += `, p1Decoration: ${i4.p1Decoration}`), i4.p2Decoration && (n2 += `, p2Decoration: ${i4.p2Decoration}`), r2.push(n2);
              });
              const s2 = convertBoundingBoxMillimeterToPixel(Box.createFromBoxes(i3.edges.map((i4) => i4["bounding-box"])));
              this.drawRecognitionBox(s2, r2);
            } else if (i3["bounding-box"]) {
              const r2 = convertBoundingBoxMillimeterToPixel(i3["bounding-box"]), s2 = ["bounding-box", "items", "id", "ports", "connected"], n2 = Object.keys(i3).filter((i4) => !s2.includes(i4)).map((r3) => `${r3}: ${JSON.stringify(i3[r3])}`);
              this.drawRecognitionBox(r2, n2);
            }
            break;
          default:
            __privateGet(this, _t24).warn("drawRecognitionBox", `Unknow jiix element type: ${i3.type}`);
        }
      });
    }
  }
  clearRecognitionBox() {
    __privateGet(this, _t24).info("clearRecognitionBox"), this.renderer.clearElements({ attrs: { debug: "recognition-box" } }), this.renderer.clearElements({ attrs: { debug: "recognition-box-link" } });
  }
  async debugRecognitionBox() {
    this.clearRecognitionBox(), __privateGet(this, _p) && this.showRecognitionBox();
  }
  drawRecognitionItemBox(i2, r2, s2) {
    const n2 = "blue", a2 = SVGBuilder.createGroup({ debug: "recognition-item-box" }), l2 = SVGBuilder.createRect(i2, { fill: "transparent", stroke: n2, style: pe.noSelection });
    a2.appendChild(l2);
    const d2 = i2.x;
    let h2 = i2.y - 14;
    const c2 = SVGBuilder.createGroup({ id: `chars-group-${createUUID()}` });
    r2 && c2.appendChild(SVGBuilder.createText({ x: d2, y: h2 }, `label: ${r2}`, { fill: n2, "font-size": 14 .toString(), style: pe.noSelection })), (s2 == null ? void 0 : s2.length) && (h2 += 14, c2.appendChild(SVGBuilder.createText({ x: d2, y: h2 }, `[${s2.join(", ")}]`, { fill: n2, "font-size": 14 .toString(), style: pe.noSelection }))), a2.appendChild(c2), this.renderer.layer.appendChild(a2);
    const u2 = c2.getBBox(), p2 = { width: u2.width + 10, height: u2.height + 10, x: u2.x - 5, y: u2.y - 5 }, g2 = SVGBuilder.createRect(p2, { fill: "white", style: "cursor:move", stroke: n2 });
    c2.prepend(g2);
    const translateEl = (r3) => {
      r3.preventDefault(), r3.stopPropagation();
      const s3 = Number(this.renderer.getAttribute(c2.id, "originX")), a3 = Number(this.renderer.getAttribute(c2.id, "originY")), l3 = r3.clientX - s3, d3 = r3.clientY - a3;
      this.renderer.setAttribute(c2.id, "transform", `translate(${l3},${d3})`);
      const h3 = { width: p2.width, height: p2.height, x: p2.x + l3, y: p2.y + d3 };
      this.renderer.removeSymbol(`connection-${c2.id}`), this.renderer.drawConnectionBetweenBox(`connection-${c2.id}`, i2, h3, { stroke: n2, debug: "recognition-item-box-link" });
    };
    g2.addEventListener("pointerdown", (i3) => {
      i3.preventDefault(), i3.stopPropagation(), this.renderer.getAttribute(c2.id, "originX") || (this.renderer.setAttribute(c2.id, "originX", i3.clientX.toString()), this.renderer.setAttribute(c2.id, "originY", i3.clientY.toString())), this.renderer.layer.addEventListener("pointermove", translateEl);
    }), this.renderer.layer.addEventListener("pointerup", () => this.renderer.layer.removeEventListener("pointermove", translateEl)), this.renderer.layer.addEventListener("pointerleave", () => this.renderer.layer.removeEventListener("pointermove", translateEl)), this.renderer.layer.addEventListener("pointercancel", () => this.renderer.layer.removeEventListener("pointermove", translateEl));
  }
  async showRecognitionItemBox() {
    var _a, _b2;
    __privateGet(this, _t24).info("showRecognitionBoxItem"), await this.editor.export(["application/vnd.myscript.jiix"]);
    const i2 = (_a = this.model.exports) == null ? void 0 : _a["application/vnd.myscript.jiix"];
    __privateGet(this, _t24).debug("showRecognitionBoxItem", { jiix: i2 }), i2 && ((_b2 = i2.elements) == null ? void 0 : _b2.forEach((i3) => {
      var _a2;
      switch (i3.type) {
        case "Text":
          (_a2 = i3.chars) == null ? void 0 : _a2.forEach((i4) => {
            if (i4 == null ? void 0 : i4["bounding-box"]) {
              const r2 = convertBoundingBoxMillimeterToPixel(i4["bounding-box"]);
              this.drawRecognitionItemBox(r2, i4.label, i4.candidates);
            }
          });
          break;
        case "Node":
          if (i3 == null ? void 0 : i3["bounding-box"]) {
            const r2 = convertBoundingBoxMillimeterToPixel(i3["bounding-box"]);
            this.drawRecognitionItemBox(r2, i3.kind);
          }
          break;
        case "Edge":
          if (i3.kind === m.PolyEdge) i3.edges.forEach((i4) => {
            const r2 = convertBoundingBoxMillimeterToPixel(i4["bounding-box"]);
            this.drawRecognitionItemBox(r2, i4.kind);
          });
          else if (i3["bounding-box"]) {
            const r2 = convertBoundingBoxMillimeterToPixel(i3["bounding-box"]);
            this.drawRecognitionItemBox(r2, i3.kind);
          }
          break;
        default:
          __privateGet(this, _t24).warn("drawRecognitionBoxItem", `Unknow jiix element type: ${i3.type}`);
      }
    }));
  }
  clearRecognitionItemBox() {
    __privateGet(this, _t24).info("clearRecognitionBoxItem"), this.renderer.clearElements({ attrs: { debug: "recognition-item-box" } }), this.renderer.clearElements({ attrs: { debug: "recognition-item-box-link" } });
  }
  async debugRecognitionItemBox() {
    this.clearRecognitionItemBox(), __privateGet(this, _g) && this.showRecognitionItemBox();
  }
  apply() {
    this.debugBoundingBox(), this.debugVertices(), this.debugSnapPoints(), this.debugRecognitionBox(), this.debugRecognitionItemBox();
  }
};
_t24 = new WeakMap();
_h = new WeakMap();
_c = new WeakMap();
_u = new WeakMap();
_p = new WeakMap();
_g = new WeakMap();
var IIMoveManager = class {
  constructor(i2) {
    __publicField(this, "grabber");
    __publicField(this, "editor");
    __publicField(this, "origin");
    this.editor = i2, this.grabber = new PointerEventGrabber(i2.configuration.grabber);
  }
  get renderer() {
    return this.editor.renderer;
  }
  attach(i2) {
    this.grabber.attach(i2), this.grabber.onPointerDown = this.start.bind(this), this.grabber.onPointerMove = this.continue.bind(this), this.grabber.onPointerUp = this.end.bind(this);
  }
  detach() {
    this.grabber.detach();
  }
  start(i2) {
    this.origin = { left: this.renderer.parent.scrollLeft, top: this.renderer.parent.scrollTop, x: i2.clientX, y: i2.clientY };
  }
  continue(i2) {
    if (!this.origin) throw new Error("Can't move cause origin is undefined");
    const r2 = i2.clientX - this.origin.x, s2 = i2.clientY - this.origin.y;
    this.renderer.parent.scrollTop = this.origin.top - s2, this.renderer.parent.scrollLeft = this.origin.left - r2;
  }
  end(i2) {
    this.continue(i2), this.origin = void 0;
  }
};
var getInitialHistoryContext = () => ({ stackIndex: 0, possibleUndoCount: 0, canRedo: false, canUndo: false, empty: true });
var _t25;
var HistoryManager = class {
  constructor(i2, r2) {
    __privateAdd(this, _t25, LoggerManager.getLogger(d.HISTORY));
    __publicField(this, "configuration");
    __publicField(this, "event");
    __publicField(this, "context");
    __publicField(this, "stack");
    __privateGet(this, _t25).info("constructor", { configuration: i2 }), this.configuration = i2, this.event = r2, this.context = { stackIndex: 0, possibleUndoCount: 0, canRedo: false, canUndo: false, empty: true }, this.stack = [];
  }
  updateContext() {
    this.context.canRedo = this.stack.length - 1 > this.context.stackIndex, this.context.canUndo = this.context.stackIndex > 0, this.context.empty = 0 === this.stack[this.context.stackIndex].symbols.length;
  }
  push(i2) {
    __privateGet(this, _t25).info("push", { model: i2 }), this.context.stackIndex + 1 < this.stack.length && this.stack.splice(this.context.stackIndex + 1), this.stack.push(i2.clone()), this.context.stackIndex = this.stack.length - 1, this.stack.length > this.configuration.maxStackSize && (this.stack.shift(), this.context.stackIndex--), this.updateContext(), this.event.emitChanged(this.context);
  }
  updateStack(i2) {
    __privateGet(this, _t25).info("updateStack", { model: i2 });
    const r2 = this.stack.findIndex((r3) => r3.modificationDate === i2.modificationDate);
    r2 > -1 && this.stack.splice(r2, 1, i2.clone()), this.updateContext(), this.event.emitChanged(this.context);
  }
  undo() {
    __privateGet(this, _t25).info("undo"), this.context.canUndo && (this.context.stackIndex--, this.updateContext(), this.event.emitChanged(this.context));
    const i2 = this.stack[this.context.stackIndex].clone();
    return __privateGet(this, _t25).debug("undo", i2), i2;
  }
  redo() {
    __privateGet(this, _t25).info("redo"), this.context.canRedo && (this.context.stackIndex++, this.updateContext(), this.event.emitChanged(this.context));
    const i2 = this.stack[this.context.stackIndex].clone();
    return __privateGet(this, _t25).debug("redo", i2), i2;
  }
};
_t25 = new WeakMap();
var _t26;
var IIHistoryManager = class {
  constructor(i2, r2) {
    __privateAdd(this, _t26, LoggerManager.getLogger(d.HISTORY));
    __publicField(this, "configuration");
    __publicField(this, "event");
    __publicField(this, "context");
    __publicField(this, "stack");
    __privateGet(this, _t26).info("constructor", { configuration: i2 }), this.configuration = i2, this.event = r2, this.context = { stackIndex: 0, possibleUndoCount: 0, canRedo: false, canUndo: false, empty: true }, this.stack = [];
  }
  updateContext() {
    this.context.canRedo = this.stack.length - 1 > this.context.stackIndex, this.context.canUndo = this.context.stackIndex > 0, this.context.empty = 0 === this.stack[this.context.stackIndex].model.symbols.length;
  }
  isChangesEmpty(i2) {
    var _a, _b2, _c2, _d6, _e2, _f2, _g2, _h2, _i2, _j, _k2, _l2, _m5, _n2, _o2;
    return !(((_a = i2.added) == null ? void 0 : _a.length) || ((_b2 = i2.updated) == null ? void 0 : _b2.length) || ((_c2 = i2.erased) == null ? void 0 : _c2.length) || ((_d6 = i2.replaced) == null ? void 0 : _d6.oldSymbols.length) || ((_e2 = i2.matrix) == null ? void 0 : _e2.symbols.length) || ((_f2 = i2.translate) == null ? void 0 : _f2.length) || ((_g2 = i2.rotate) == null ? void 0 : _g2.length) || ((_h2 = i2.scale) == null ? void 0 : _h2.length) || ((_j = (_i2 = i2.style) == null ? void 0 : _i2.symbols) == null ? void 0 : _j.length) || ((_l2 = (_k2 = i2.order) == null ? void 0 : _k2.symbols) == null ? void 0 : _l2.length) || ((_m5 = i2.decorator) == null ? void 0 : _m5.length) || ((_n2 = i2.group) == null ? void 0 : _n2.symbols.length) || ((_o2 = i2.ungroup) == null ? void 0 : _o2.group));
  }
  init(i2) {
    this.stack.push({ model: i2.clone(), changes: {} }), this.event.emitChanged(this.context);
  }
  push(i2, r2) {
    __privateGet(this, _t26).info("push", { model: i2, changes: r2 }), this.isChangesEmpty(r2) || (this.context.stackIndex + 1 < this.stack.length && this.stack.splice(this.context.stackIndex + 1), this.stack.push({ model: i2.clone(), changes: r2 }), this.context.stackIndex = this.stack.length - 1, this.stack.length > this.configuration.maxStackSize && (this.stack.shift(), this.context.stackIndex--), this.updateContext(), this.event.emitChanged(this.context));
  }
  update(i2) {
    __privateGet(this, _t26).info("pop");
    const r2 = this.stack.findIndex((r3) => r3.model.modificationDate === i2.modificationDate);
    r2 > -1 && (this.stack[r2].model = i2, this.updateContext());
  }
  pop() {
    __privateGet(this, _t26).info("pop"), this.stack.pop(), this.context.stackIndex = this.stack.length - 1, this.updateContext();
  }
  reverseChanges(i2) {
    var _a, _b2, _c2;
    const r2 = {};
    return i2.added && (r2.erased = i2.added), i2.erased && (r2.added = i2.erased), i2.replaced && (r2.replaced = { newSymbols: i2.replaced.oldSymbols, oldSymbols: i2.replaced.newSymbols }), i2.matrix && (r2.matrix = { symbols: i2.matrix.symbols, matrix: new MatrixTransform(i2.matrix.matrix.xx, i2.matrix.matrix.yx, i2.matrix.matrix.xy, i2.matrix.matrix.yy, i2.matrix.matrix.tx, i2.matrix.matrix.ty).invert() }), ((_a = i2.translate) == null ? void 0 : _a.length) && (r2.translate = i2.translate.map((i3) => ({ symbols: i3.symbols, tx: -i3.tx, ty: -i3.ty }))), ((_b2 = i2.rotate) == null ? void 0 : _b2.length) && (r2.rotate = i2.rotate.map((i3) => ({ symbols: i3.symbols, angle: 2 * Math.PI - i3.angle, center: i3.center }))), ((_c2 = i2.scale) == null ? void 0 : _c2.length) && (r2.scale = i2.scale.map((i3) => ({ symbols: i3.symbols, origin: i3.origin, scaleX: 1 / i3.scaleX, scaleY: 1 / i3.scaleY }))), r2;
  }
  undo() {
    __privateGet(this, _t26).info("undo");
    const i2 = this.stack[this.context.stackIndex];
    this.context.canUndo && (this.context.stackIndex--, this.updateContext(), this.event.emitChanged(this.context));
    const r2 = this.stack[this.context.stackIndex];
    return __privateGet(this, _t26).debug("undo", r2), { model: r2.model, changes: this.reverseChanges(i2.changes) };
  }
  redo() {
    __privateGet(this, _t26).info("redo"), this.context.canRedo && (this.context.stackIndex++, this.updateContext(), this.event.emitChanged(this.context));
    const i2 = this.stack[this.context.stackIndex];
    return __privateGet(this, _t26).debug("redo", i2), i2;
  }
  clear() {
    this.context = { stackIndex: 0, possibleUndoCount: 0, canRedo: false, canUndo: false, empty: true }, this.stack = [];
  }
};
_t26 = new WeakMap();
var Se = { maxStackSize: 100 };
var we = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path d="M6 9L12 15L18 9" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n</svg>\n';
var IIMenu = class {
  constructor() {
    __publicField(this, "thicknessList", [{ label: "S", value: 1 }, { label: "M", value: 2 }, { label: "L", value: 4 }, { label: "XL", value: 8 }]);
    __publicField(this, "fontSizeList", [{ label: "Auto", value: "auto" }, { label: "S", value: 0.5 }, { label: "M", value: 0.75 }, { label: "L", value: 1 }]);
    __publicField(this, "fontWeightList", [{ label: "Auto", value: "auto" }, { label: "Normal", value: "normal" }, { label: "Bold", value: "bold" }]);
    __publicField(this, "colors", ["#000000", "#808080", "#ffffff", "transparent", "#ff0000", "#ff6400", "#ffc800", "#ffff00", "#0000ff", "#0064ff", "#00c8ff", "#00ffff", "#008000", "#00af00", "#00e100", "#00ff00"]);
  }
  createWrapCollapsible(i2, r2) {
    const s2 = document.createElement("div");
    s2.classList.add("collapsible-wrapper");
    const n2 = document.createElement("div");
    n2.classList.add("collapsible-header"), n2.textContent = r2;
    const a2 = document.createElement("span");
    a2.classList.add("collapsible-header-icon"), a2.innerHTML = we, n2.appendChild(a2), n2.style.setProperty("pointer", "cursor");
    const l2 = document.createElement("div");
    return l2.classList.add("collapsible-content"), n2.addEventListener("pointerup", () => s2.classList.toggle("active")), s2.appendChild(n2), l2.appendChild(i2), s2.appendChild(l2), s2;
  }
  createMenuItemBoolean(i2) {
    const r2 = document.createElement("div");
    r2.classList.add("ms-menu-item", i2.type);
    const s2 = document.createElement("span");
    s2.textContent = i2.label, r2.appendChild(s2);
    const n2 = document.createElement("input");
    return n2.id = i2.id, n2.setAttribute("type", "checkbox"), i2.disabled && (n2.disabled = true), "indeterminate" === i2.initValue ? n2.indeterminate = true : n2.checked = i2.initValue, n2.addEventListener("change", (r3) => i2.callback(r3.target.checked)), r2.appendChild(n2), r2;
  }
  createMenuItemSelect(i2) {
    const r2 = document.createElement("div");
    r2.classList.add("ms-menu-item", i2.type);
    const s2 = document.createElement("span");
    s2.textContent = i2.label, r2.appendChild(s2);
    const n2 = document.createElement("select");
    return n2.id = i2.id, i2.disabled && (n2.disabled = true), i2.values.forEach((r3) => {
      const s3 = r3.value === i2.initValue, a2 = new Option(r3.label, r3.value.toString(), s3, s3);
      n2.appendChild(a2);
    }), n2.addEventListener("change", (r3) => i2.callback(r3.target.value)), r2.appendChild(n2), r2;
  }
  createMenuItemButton(i2) {
    const r2 = document.createElement("button");
    return r2.classList.add("ms-menu-item", "ms-menu-button"), r2.innerHTML = i2.icon || i2.label, r2.addEventListener("pointerup", i2.callback), r2;
  }
  createMenuItemButtonList(i2) {
    const r2 = document.createElement("div");
    r2.classList.add("ms-menu-item", i2.type), r2.id = i2.id;
    const s2 = document.createElement("span");
    return s2.textContent = i2.label, r2.appendChild(s2), i2.values.forEach((s3) => {
      const n2 = document.createElement("button");
      i2.disabled && (n2.disabled = true), n2.id = `${i2.id}-${s3.value}-btn`, i2.initValue === s3.value && n2.classList.add("active"), n2.textContent = s3.label, n2.addEventListener("pointerup", () => {
        i2.callback(s3.value), r2.querySelectorAll("*").forEach((i3) => i3.classList.remove("active")), n2.classList.add("active");
      }), r2.appendChild(n2);
    }), r2;
  }
  createMenuItemColorList(i2) {
    const r2 = document.createElement("div");
    r2.classList.add("ms-menu-item", i2.type), r2.id = i2.id;
    const s2 = document.createElement("span");
    return s2.textContent = i2.label, r2.appendChild(s2), r2.appendChild(this.createColorList(i2)), r2;
  }
  createColorList(i2) {
    const r2 = document.createElement("div");
    return r2.id = `${i2.id}-list`, r2.classList.add("ms-menu-row", "color-list"), i2.values.forEach((s2) => {
      const n2 = document.createElement("button");
      i2.disabled && (n2.disabled = true), n2.id = `${i2.id}-${s2.replace("#", "")}-btn`, n2.classList.add("ms-menu-button", "square");
      const a2 = document.createElement("div");
      a2.classList.add("color"), i2.fill ? (a2.style.setProperty("background-color", s2), a2.style.setProperty("border", "1px solid lightgrey")) : (a2.style.setProperty("background-color", "transparent"), a2.style.setProperty("border", `3px solid ${s2}`)), "#ffffff" === s2 && a2.style.setProperty("border", "1px solid black"), "transparent" === s2 && a2.style.setProperty("background-image", "linear-gradient(45deg, #AAA 10%, transparent 20%, #AAA 30%, transparent 40%, #AAA 50%, transparent 60%, #AAA 70%, transparent 80%, #AAA 90%, transparent 100%)"), i2.initValue === s2 && n2.classList.add("active"), n2.appendChild(a2), n2.addEventListener("pointerup", (a3) => {
        a3.preventDefault(), a3.stopPropagation(), i2.callback(s2), r2.querySelectorAll("*").forEach((i3) => i3.classList.remove("active")), n2.classList.add("active");
      }), r2.appendChild(n2);
    }), r2;
  }
  createMenuItem(i2) {
    switch (i2.type) {
      case "checkbox":
        return this.createMenuItemBoolean(i2);
      case "select":
        return this.createMenuItemSelect(i2);
      case "list":
        return this.createMenuItemButtonList(i2);
      case "colors":
        return this.createMenuItemColorList(i2);
      default:
        return this.createMenuItemButton(i2);
    }
  }
};
var ve;
var ke;
var Ee;
!function(i2) {
  i2.Select = "select", i2.Surround = "surround", i2.Highlight = "highlight";
}(ve || (ve = {})), function(i2) {
  i2.Erase = "erase", i2.Draw = "draw";
}(ke || (ke = {})), function(i2) {
  i2.LineBreak = "line-break", i2.Insert = "insert";
}(Ee || (Ee = {}));
var Ie = { surround: ve.Select, strikeThrough: ke.Draw, insert: Ee.LineBreak };
var _t27;
var IIGestureManager = class {
  constructor(i2, r2) {
    __privateAdd(this, _t27, LoggerManager.getLogger(d.GESTURE));
    __publicField(this, "insertAction", Ee.LineBreak);
    __publicField(this, "surroundAction", ve.Select);
    __publicField(this, "strikeThroughAction", ke.Draw);
    __publicField(this, "editor");
    __privateGet(this, _t27).info("constructor"), this.editor = i2, this.surroundAction = (r2 == null ? void 0 : r2.surround) || Ie.surround, this.strikeThroughAction = (r2 == null ? void 0 : r2.strikeThrough) || Ie.strikeThrough, this.insertAction = (r2 == null ? void 0 : r2.insert) || Ie.insert;
  }
  get renderer() {
    return this.editor.renderer;
  }
  get recognizer() {
    return this.editor.recognizer;
  }
  get translator() {
    return this.editor.translator;
  }
  get texter() {
    return this.editor.texter;
  }
  get model() {
    return this.editor.model;
  }
  get history() {
    return this.editor.history;
  }
  get rowHeight() {
    return this.editor.configuration.rendering.guides.gap;
  }
  get strokeSpaceWidth() {
    return 2 * this.editor.configuration.rendering.guides.gap;
  }
  async applySurroundGesture(r2, s2) {
    __privateGet(this, _t27).info("applySurroundGesture", { gestureStroke: r2, gesture: s2 });
    const n2 = {}, a2 = this.model.symbols.filter((i2) => r2.bounds.contains(i2.bounds)).map((i2) => i2.id);
    switch (this.surroundAction) {
      case ve.Select:
        a2.length && (this.editor.tool = i.Select, this.editor.select(a2));
        break;
      case ve.Highlight: {
        const i2 = [];
        n2.decorator = [], a2.forEach((r3) => {
          const s3 = this.model.getRootSymbol(r3);
          if (s3 && [E.Group, E.Stroke, E.Text, E.Recognized].includes(s3.type) && !i2.includes(s3.id)) {
            const r4 = s3, a3 = new IIDecorator(k.Highlight, this.editor.penStyle), l2 = r4.decorators.findIndex((i3) => i3.kind === k.Highlight), d2 = -1 === l2;
            d2 ? r4.decorators.push(a3) : r4.decorators.splice(l2, 1), this.model.updateSymbol(r4), this.renderer.drawSymbol(r4), i2.push(r4.id), n2.decorator.push({ symbol: r4, decorator: a3, added: d2 });
          }
        }), n2.decorator.length && this.history.push(this.model, n2);
        break;
      }
      case ve.Surround: {
        const i2 = [];
        n2.decorator = [], a2.forEach((r3) => {
          const s3 = this.model.getRootSymbol(r3);
          if (s3 && [E.Group, E.Stroke, E.Text, E.Recognized].includes(s3.type) && !i2.includes(s3.id)) {
            const r4 = s3, a3 = new IIDecorator(k.Surround, this.editor.penStyle), l2 = r4.decorators.findIndex((i3) => i3.kind === k.Surround), d2 = -1 === l2;
            d2 ? r4.decorators.push(a3) : r4.decorators.splice(l2, 1), this.model.updateSymbol(r4), this.renderer.drawSymbol(r4), n2.decorator.push({ symbol: r4, decorator: a3, added: d2 }), i2.push(r4.id);
          }
        }), this.history.push(this.model, n2);
        break;
      }
      default:
        __privateGet(this, _t27).error("applySurroundGesture", `Unknow surroundAction: ${this.surroundAction}, values allowed are: ${ve.Highlight}, ${ve.Select}, ${ve.Surround}`);
    }
  }
  computeScratchOnStrokes(i2, r2) {
    var _a;
    const s2 = [], n2 = (_a = i2.subStrokes) == null ? void 0 : _a.find((i3) => i3.fullStrokeId === r2.id);
    if (n2) {
      const i3 = new IIStroke();
      n2.x.forEach((r3, s3) => i3.addPointer({ x: r3, y: n2.y[s3], p: 1, t: 1 }));
      const a2 = IIStroke.substract(r2, i3);
      a2.before && a2.before.pointers.length > 1 && s2.push(a2.before), a2.after && a2.after.pointers.length > 1 && s2.push(a2.after);
    }
    return s2;
  }
  computeScratchOnText(i2, r2) {
    const s2 = r2.getCharsOverlaps(i2.pointers);
    return r2.chars.length == s2.length ? void 0 : (s2.forEach((i3) => {
      const s3 = r2.chars.findIndex((r3) => r3.id === i3.id);
      r2.chars.splice(s3, 1);
    }), this.texter.updateBounds(r2), r2);
  }
  computeScratchOnSymbol(i2, r2, s2) {
    switch (s2.type) {
      case E.Stroke: {
        const i3 = this.computeScratchOnStrokes(r2, s2);
        return i3.length ? { replaced: i3 } : { erased: true };
      }
      case E.Recognized:
        if (s2.kind === T.Text) {
          const n2 = s2.strokes.filter((r3) => !i2.bounds.overlaps(r3.bounds)), a2 = s2.strokes.filter((r3) => i2.bounds.overlaps(r3.bounds)).map((i3) => ({ symbol: i3, result: this.computeScratchOnStrokes(r2, i3) }));
          if (0 === n2.length && a2.every((i3) => 0 === i3.result.length)) return { erased: true };
          {
            const i3 = n2.concat(...a2.flatMap((i4) => i4.result)), r3 = new IIRecognizedText(i3, { baseline: s2.baseline, xHeight: s2.xHeight }, s2.style);
            return r3.decorators = s2.decorators, { replaced: [r3] };
          }
        }
        return {};
      case E.Group: {
        const n2 = s2.children.filter((r3) => !i2.bounds.overlaps(r3.bounds)), a2 = s2.children.filter((r3) => i2.bounds.overlaps(r3.bounds)).map((s3) => ({ symbol: s3, result: this.computeScratchOnSymbol(i2, r2, s3) }));
        if (0 === n2.length && a2.every((i3) => i3.result.erased)) return { erased: true };
        {
          const i3 = n2;
          a2.forEach((r4) => {
            r4.result.replaced && i3.push(...r4.result.replaced);
          });
          const r3 = new IISymbolGroup(i3, s2.style);
          return r3.decorators = s2.decorators, { replaced: [r3] };
        }
      }
      case E.Text: {
        const r3 = this.computeScratchOnText(i2, s2);
        return r3 ? { replaced: [r3] } : { erased: true };
      }
      case E.Shape:
      case E.Edge:
        return { erased: true };
    }
  }
  async applyScratch(i2, r2) {
    if (__privateGet(this, _t27).debug("applyScratchGesture", { gestureStroke: i2, gesture: r2 }), !r2.strokeIds.length) return void __privateGet(this, _t27).warn("applyScratchGesture", "Unable to apply underline because there are no strokes");
    const s2 = [], n2 = [], a2 = { oldSymbols: [], newSymbols: [] };
    r2.strokeIds.forEach((s3) => {
      const l3 = this.model.getRootSymbol(s3);
      if (l3 && !n2.some((i3) => i3.id === l3.id) && !a2.oldSymbols.some((i3) => i3.id === l3.id)) {
        const s4 = this.computeScratchOnSymbol(i2, r2, l3);
        s4.erased ? n2.push(l3) : s4.replaced && (a2.newSymbols.push(...s4.replaced), a2.oldSymbols.push(l3));
      }
    });
    const l2 = [], d2 = {};
    s2.length && (l2.push(this.editor.updateSymbols(s2, false)), d2.updated = s2), n2.length && (l2.push(this.editor.removeSymbols(n2.map((i3) => i3.id), false)), d2.erased = n2), a2.newSymbols.length && (d2.replaced = a2, l2.push(this.editor.replaceSymbols(a2.oldSymbols, a2.newSymbols, false))), this.history.push(this.model, d2), await Promise.all(l2);
  }
  async applyJoinGesture(i2, r2) {
    var _a;
    __privateGet(this, _t27).debug("applyJoinGesture", { gestureStroke: i2, gesture: r2 });
    const s2 = this.model.symbols.filter((r3) => this.model.isSymbolAbove(i2, r3)), n2 = this.model.symbols.filter((r3) => i2.id !== r3.id && this.model.isSymbolInRow(i2, r3)), a2 = n2.filter((r3) => r3.bounds.xMax <= i2.bounds.xMid), l2 = n2.filter((r3) => r3.bounds.xMax > i2.bounds.xMid && r3.bounds.xMin <= i2.bounds.xMid), d2 = n2.filter((r3) => r3.bounds.xMin > i2.bounds.xMid), h2 = this.model.symbols.filter((r3) => this.model.isSymbolBelow(i2, r3)), c2 = {}, u2 = [];
    if (l2.length) {
      const r3 = l2[0];
      if ((r3 == null ? void 0 : r3.type) === E.Group) {
        const s3 = r3.children.map((i3) => i3.clone()), n3 = s3.filter((r4) => r4.bounds.xMid <= i2.bounds.xMid), a3 = s3.filter((r4) => r4.bounds.xMid > i2.bounds.xMid);
        if (n3.length && a3.length) {
          const i3 = Math.max(...n3.map((i4) => i4.bounds.xMax)) - Math.min(...a3.map((i4) => i4.bounds.xMin));
          a3.forEach((r4) => this.translator.applyToSymbol(r4, i3, 0));
          const l3 = new IISymbolGroup(s3, r3.style);
          l3.decorators = r3.decorators.map((i4) => i4.clone()), c2.replaced = { oldSymbols: [r3], newSymbols: [l3] }, d2.length && u2.push({ symbols: d2, tx: i3, ty: 0 });
        } else if (d2.length) {
          const i3 = r3.bounds.xMax - Math.min(...d2.map((i4) => i4.bounds.xMin));
          u2.push({ symbols: d2, tx: i3, ty: 0 });
        }
      } else if ((r3 == null ? void 0 : r3.type) === E.Recognized) {
        const s3 = r3.clone(), n3 = s3.strokes.filter((r4) => r4.bounds.xMid <= i2.bounds.xMid), a3 = s3.strokes.filter((r4) => r4.bounds.xMid > i2.bounds.xMid);
        if (n3.length && a3.length) {
          const i3 = Math.max(...n3.map((i4) => i4.bounds.xMax)) - Math.min(...a3.map((i4) => i4.bounds.xMin));
          a3.forEach((r4) => this.translator.applyToSymbol(r4, i3, 0)), c2.replaced = { oldSymbols: [r3], newSymbols: [s3] }, d2.length && u2.push({ symbols: d2, tx: i3, ty: 0 });
        } else if (d2.length) {
          const i3 = r3.bounds.xMax - Math.min(...d2.map((i4) => i4.bounds.xMin));
          u2.push({ symbols: d2, tx: i3, ty: 0 });
        }
      }
    } else if (a2.length && d2.length) {
      const i3 = this.model.getLastSymbol(a2), r3 = this.model.getFirstSymbol(d2), s3 = Math.max(...a2.map((i4) => i4.bounds.xMax)) - Math.min(...d2.map((i4) => i4.bounds.xMin)), n3 = i3.clone(), l3 = r3.clone();
      this.translator.applyToSymbol(l3, s3, 0);
      const h3 = i3.type === E.Group ? n3.children : [n3];
      if (h3.push(...l3.type === E.Group ? l3.children : [l3]), h3.every((i4) => i4.type === E.Text)) {
        const s4 = h3, n4 = new IIText(s4.flatMap((i4) => i4.chars), s4[0].point, Box.createFromBoxes(s4.map((i4) => i4.bounds)));
        this.texter.setBounds(n4), c2.replaced = { oldSymbols: [i3, r3], newSymbols: [n4] };
      } else if (h3.every((i4) => i4.type === E.Recognized)) {
        const s4 = h3, n4 = new IIRecognizedText(s4.flatMap((i4) => i4.strokes), s4[0], s4[0].style);
        c2.replaced = { oldSymbols: [i3, r3], newSymbols: [n4] };
      } else {
        const s4 = new IISymbolGroup(h3, i3.style);
        [E.Group, E.Stroke, E.Text, E.Recognized].includes(i3.type) && i3.decorators.forEach((i4) => {
          s4.decorators.push(new IIDecorator(i4.kind, i4.style));
        }), [E.Group, E.Stroke, E.Text, E.Recognized].includes(r3.type) && r3.decorators.forEach((i4) => {
          s4.decorators.some((r4) => r4.kind == i4.kind) || s4.decorators.push(new IIDecorator(i4.kind, i4.style));
        }), c2.replaced = { oldSymbols: [i3, r3], newSymbols: [s4] };
      }
      const p2 = d2.filter((i4) => i4.id !== r3.id);
      p2.length && u2.push({ symbols: p2, tx: s3, ty: 0 });
    } else if (a2.length) {
      const i3 = this.model.getLastSymbol(a2), r3 = this.model.getFirstSymbol(h2);
      if (r3) {
        if (this.model.roundToLineGuide(i3.bounds.yMid) >= this.model.roundToLineGuide(r3.bounds.yMid - this.rowHeight)) {
          const s3 = h2.filter((i4) => this.model.isSymbolInRow(r3, i4));
          if (s3.length) {
            const n4 = i3.bounds.xMax + this.strokeSpaceWidth - r3.bounds.xMin;
            u2.push({ symbols: s3, tx: n4, ty: -this.rowHeight });
          }
          const n3 = h2.filter((i4) => this.model.isSymbolBelow(r3, i4));
          n3.length && u2.push({ symbols: n3, tx: 0, ty: -this.rowHeight });
        }
      } else u2.push({ symbols: h2, tx: 0, ty: -this.rowHeight });
    } else if (d2.length) {
      const i3 = this.model.getFirstSymbol(d2), r3 = this.model.getLastSymbol(s2);
      if (r3) {
        if (this.model.roundToLineGuide(r3.bounds.yMid) >= this.model.roundToLineGuide(i3.bounds.yMid - this.rowHeight)) {
          const s3 = r3.bounds.xMax + this.strokeSpaceWidth - i3.bounds.xMin;
          u2.push({ symbols: d2, tx: s3, ty: -this.rowHeight });
        } else u2.push({ symbols: d2, tx: 0, ty: -this.rowHeight });
        h2.length && u2.push({ symbols: h2, tx: 0, ty: -this.rowHeight });
      } else u2.push({ symbols: d2.concat(...h2), tx: 0, ty: -this.rowHeight });
    }
    ((_a = c2.replaced) == null ? void 0 : _a.oldSymbols.length) && this.editor.replaceSymbols(c2.replaced.oldSymbols, c2.replaced.newSymbols, false), u2.length && (c2.translate = u2, Promise.all(u2.map((i3) => this.translator.translate(i3.symbols, i3.tx, i3.ty, false)))), this.history.push(this.model, c2);
  }
  createStrokesFromGestureSubStroke(i2, r2) {
    const s2 = [];
    if (r2[0]) {
      const n2 = new IIStroke(i2.style);
      r2[0].x.forEach((s3, a2) => {
        var _a, _b2;
        n2.pointers.push({ x: s3, y: r2[0].y[a2], p: ((_a = i2.pointers.at(a2)) == null ? void 0 : _a.p) || 1, t: ((_b2 = i2.pointers.at(a2)) == null ? void 0 : _b2.t) || Math.max(...n2.pointers.map((i3) => i3.t + 20)) });
      }), s2.push(n2);
    }
    if (r2[1]) {
      const n2 = new IIStroke(i2.style);
      r2[1].x.forEach((s3, a2) => {
        var _a, _b2;
        n2.pointers.push({ x: s3, y: r2[1].y[a2], p: ((_a = i2.pointers.at(n2.pointers.length + a2)) == null ? void 0 : _a.p) || 1, t: ((_b2 = i2.pointers.at(n2.pointers.length + a2)) == null ? void 0 : _b2.t) || Math.max(...n2.pointers.map((i3) => i3.t + 20)) });
      }), s2.push(n2);
    }
    return s2;
  }
  computeSplitStroke(i2, r2) {
    let s2;
    const n2 = this.createStrokesFromGestureSubStroke(i2, r2);
    return n2[1] && (s2 = n2[1], this.translator.applyToSymbol(s2, this.strokeSpaceWidth, 0)), { before: n2[0], after: s2 };
  }
  computeSplitStrokeInGroup(i2, r2, s2) {
    const n2 = [], a2 = [], l2 = [], d2 = s2[0].fullStrokeId;
    return r2.children.forEach((r3) => {
      if (r3.id === d2) {
        const i3 = this.computeSplitStroke(r3, s2);
        i3.before && a2.push(i3.before), i3.after && l2.push(i3.after);
      } else r3.bounds.xMid < i2.bounds.xMid ? a2.push(r3) : r3.bounds.xMid > i2.bounds.xMid && (this.translator.applyToSymbol(r3, this.strokeSpaceWidth, 0), l2.push(r3));
    }), a2.length && n2.push(new IISymbolGroup(a2, r2.style)), l2.length && n2.push(new IISymbolGroup(l2, r2.style)), n2;
  }
  computeChangesOnSplitStroke(i2, r2, s2) {
    const n2 = [], a2 = { oldSymbols: [], newSymbols: [] }, l2 = this.model.symbols.filter((r3) => i2.id !== r3.id && this.model.isSymbolInRow(i2, r3) && i2.bounds.xMid < r3.bounds.xMin), d2 = this.model.getRootSymbol(r2);
    if ((d2 == null ? void 0 : d2.type) === E.Group) {
      const r3 = this.computeSplitStrokeInGroup(i2, d2, s2);
      a2.newSymbols.push(...r3), a2.oldSymbols.push(d2);
    } else if ((d2 == null ? void 0 : d2.type) === E.Stroke) {
      const i3 = this.computeSplitStroke(d2, s2);
      i3.before && a2.newSymbols.push(i3.before), i3.after && a2.newSymbols.push(i3.after), a2.oldSymbols.push(d2);
    } else if ((d2 == null ? void 0 : d2.type) === E.Recognized) {
      const n3 = d2.strokes.find((i3) => i3.id === r2), l3 = d2.strokes.filter((s3) => s3.id !== r2 && s3.bounds.xMid < i2.bounds.xMid), h2 = d2.strokes.filter((s3) => s3.id !== r2 && s3.bounds.xMid > i2.bounds.xMid), c2 = this.computeSplitStroke(n3, s2);
      c2.before && a2.newSymbols.push(...l3, c2.before), c2.after && a2.newSymbols.push(c2.after, ...h2), a2.oldSymbols.push(d2);
    }
    return l2.length && n2.push({ symbols: l2, tx: this.strokeSpaceWidth, ty: 0 }), { translate: n2, replaced: a2 };
  }
  computeChangesOnSplitGroup(i2, r2) {
    const s2 = [], n2 = { oldSymbols: [], newSymbols: [] }, a2 = this.model.symbols.filter((r3) => i2.id !== r3.id && this.model.isSymbolInRow(i2, r3) && i2.bounds.xMid < r3.bounds.xMin), l2 = r2.children.filter((r3) => r3.bounds.xMid <= i2.bounds.xMid), d2 = r2.children.filter((r3) => r3.bounds.xMid > i2.bounds.xMid);
    if (n2.oldSymbols.push(r2), l2.length) {
      const i3 = new IISymbolGroup(l2.map((i4) => i4.clone()), r2.style);
      i3.decorators = r2.decorators.map((i4) => new IIDecorator(i4.kind, i4.style)), n2.newSymbols.push(i3);
    }
    if (d2.length) {
      const i3 = new IISymbolGroup(d2.map((i4) => i4.clone()), r2.style);
      i3.decorators = r2.decorators.map((i4) => new IIDecorator(i4.kind, i4.style)), this.translator.applyToSymbol(i3, this.strokeSpaceWidth, 0), n2.newSymbols.push(i3);
    }
    return (a2 == null ? void 0 : a2.length) && s2.push({ symbols: a2.filter((i3) => i3.id !== r2.id), tx: this.strokeSpaceWidth, ty: 0 }), { translate: s2, replaced: n2 };
  }
  computeChangesOnSplitStrokeText(i2, r2) {
    const s2 = [], n2 = { oldSymbols: [], newSymbols: [] }, a2 = this.model.symbols.filter((r3) => i2.id !== r3.id && this.model.isSymbolInRow(i2, r3) && i2.bounds.xMid < r3.bounds.xMin), l2 = r2.strokes.filter((r3) => r3.bounds.xMid <= i2.bounds.xMid), d2 = r2.strokes.filter((r3) => r3.bounds.xMid > i2.bounds.xMid);
    if (n2.oldSymbols.push(r2), l2.length) {
      const i3 = new IIRecognizedText(l2.map((i4) => i4.clone()), r2, r2.style);
      i3.decorators = r2.decorators.map((i4) => new IIDecorator(i4.kind, i4.style)), n2.newSymbols.push(i3);
    }
    if (d2.length) {
      const i3 = new IIRecognizedText(d2.map((i4) => i4.clone()), r2, r2.style);
      i3.decorators = r2.decorators.map((i4) => new IIDecorator(i4.kind, i4.style)), this.translator.applyToSymbol(i3, this.strokeSpaceWidth, 0), n2.newSymbols.push(i3);
    }
    return (a2 == null ? void 0 : a2.length) && s2.push({ symbols: a2.filter((i3) => i3.id !== r2.id), tx: this.strokeSpaceWidth, ty: 0 }), { translate: s2, replaced: n2 };
  }
  computeChangesOnSplitText(i2, r2) {
    const s2 = [], n2 = { oldSymbols: [], newSymbols: [] }, a2 = this.model.symbols.filter((r3) => i2.id !== r3.id && this.model.isSymbolInRow(i2, r3) && i2.bounds.xMid < r3.bounds.xMin), l2 = r2.chars.filter((r3) => r3.bounds.x + r3.bounds.width / 2 <= i2.bounds.xMid), d2 = r2.chars.filter((r3) => r3.bounds.x + r3.bounds.width / 2 > i2.bounds.xMid), h2 = [];
    if (l2.length && d2.length) {
      const i3 = new IIText(l2, r2.point, Box.createFromBoxes(l2.map((i4) => i4.bounds)));
      this.texter.setBounds(i3), h2.push(i3);
      const s3 = { x: i3.point.x + i3.bounds.width + this.texter.getSpaceWidth(computeAverage(i3.chars.map((i4) => i4.fontSize))), y: i3.point.y }, a3 = new IIText(d2, s3, Box.createFromBoxes(d2.map((i4) => i4.bounds)));
      this.texter.setBounds(a3), h2.push(a3), n2.newSymbols = h2, n2.oldSymbols = [r2];
    }
    return (a2 == null ? void 0 : a2.length) && s2.push({ symbols: a2.filter((r3) => r3.id !== i2.id), tx: this.strokeSpaceWidth, ty: 0 }), { translate: s2, replaced: n2 };
  }
  async applyInsertGesture(i2, r2) {
    var _a, _b2, _c2;
    __privateGet(this, _t27).debug("applyInsertGesture", { gestureStroke: i2, gesture: r2 });
    const s2 = this.model.symbols.filter((r3) => i2.id !== r3.id && this.model.isSymbolInRow(i2, r3)), n2 = s2.find((r3) => r3.type === E.Text && isBetween(i2.bounds.xMid, r3.bounds.xMin, r3.bounds.xMax)), a2 = s2.find((r3) => r3.type === E.Group && isBetween(i2.bounds.xMid, r3.bounds.xMin, r3.bounds.xMax)), l2 = s2.find((r3) => r3.type === E.Recognized && isBetween(i2.bounds.xMid, r3.bounds.xMin, r3.bounds.xMax)), d2 = s2.filter((r3) => i2.bounds.xMid > r3.bounds.xMax), h2 = s2.filter((r3) => i2.bounds.xMid < r3.bounds.xMin), c2 = this.model.symbols.filter((r3) => this.model.isSymbolBelow(i2, r3));
    let u2;
    if (r2.strokeIds.length && ((_a = r2.subStrokes) == null ? void 0 : _a.length)) u2 = this.computeChangesOnSplitStroke(i2, r2.strokeIds[0], r2.subStrokes);
    else if (a2) u2 = this.computeChangesOnSplitGroup(i2, a2);
    else if (n2) u2 = this.computeChangesOnSplitText(i2, n2);
    else if (l2) u2 = this.computeChangesOnSplitStrokeText(i2, l2);
    else if (h2.length) {
      const i3 = [];
      let r3 = 0;
      switch (d2.length && (r3 = Math.min(...d2.map((i4) => i4.bounds.xMin)) - Math.min(...h2.map((i4) => i4.bounds.xMin))), this.insertAction) {
        case Ee.LineBreak:
          i3.push({ symbols: h2, tx: r3, ty: this.rowHeight }), c2.length && i3.push({ symbols: c2, tx: 0, ty: this.rowHeight });
          break;
        case Ee.Insert:
          i3.push({ symbols: h2, tx: 2 * this.strokeSpaceWidth, ty: 0 });
      }
      u2 = { translate: i3 };
    } else d2.length && c2.length && this.insertAction === Ee.LineBreak && (u2 = { translate: [{ symbols: c2, tx: 0, ty: this.rowHeight }] });
    if (u2) {
      const i3 = [];
      ((_b2 = u2.translate) == null ? void 0 : _b2.length) && i3.push(...u2.translate.map((i4) => this.translator.translate(i4.symbols, i4.tx, i4.ty, false))), ((_c2 = u2.replaced) == null ? void 0 : _c2.newSymbols.length) && i3.push(this.editor.replaceSymbols(u2.replaced.oldSymbols, u2.replaced.newSymbols, false)), this.history.push(this.model, u2), await Promise.all(i3);
    }
  }
  async applyUnderlineGesture(i2, r2) {
    var _a;
    if (__privateGet(this, _t27).debug("applyUnderlineGesture", { gestureStroke: i2, gesture: r2 }), !r2.strokeIds.length) return void __privateGet(this, _t27).warn("applyUnderlineGesture", "Unable to apply underline because there are no strokes");
    const s2 = { decorator: [] }, n2 = [];
    r2.strokeIds.forEach((i3) => {
      var _a2;
      const r3 = this.model.getRootSymbol(i3);
      if (r3 && [E.Group, E.Stroke, E.Text, E.Recognized].includes(r3.type) && !n2.includes(r3.id)) {
        const i4 = r3, a2 = new IIDecorator(k.Underline, this.editor.penStyle), l2 = i4.decorators.findIndex((i5) => i5.kind === k.Underline), d2 = -1 === l2;
        d2 ? i4.decorators.push(a2) : i4.decorators.splice(l2, 1), this.model.updateSymbol(i4), this.renderer.drawSymbol(i4), (_a2 = s2.decorator) == null ? void 0 : _a2.push({ symbol: i4, decorator: a2, added: d2 }), n2.push(i4.id);
      }
    }), ((_a = s2.decorator) == null ? void 0 : _a.length) && this.history.push(this.model, s2);
  }
  async applyStrikeThroughGesture(i2, r2) {
    var _a;
    if (__privateGet(this, _t27).debug("applyStrikeThroughGesture", { gestureStroke: i2, gesture: r2 }), r2.strokeIds.length) switch (this.strikeThroughAction) {
      case ke.Draw: {
        const i3 = { decorator: [] }, s2 = [];
        r2.strokeIds.forEach((r3) => {
          var _a2;
          const n2 = this.model.getRootSymbol(r3);
          if (n2 && [E.Group, E.Stroke, E.Text, E.Recognized].includes(n2.type) && !s2.includes(n2.id)) {
            const r4 = n2, a2 = new IIDecorator(k.Strikethrough, this.editor.penStyle), l2 = r4.decorators.findIndex((i4) => i4.kind === k.Strikethrough), d2 = -1 === l2;
            d2 ? r4.decorators.push(a2) : r4.decorators.splice(l2, 1), this.model.updateSymbol(r4), this.renderer.drawSymbol(r4), (_a2 = i3.decorator) == null ? void 0 : _a2.push({ symbol: r4, decorator: a2, added: d2 }), s2.push(r4.id);
          }
        }), ((_a = i3.decorator) == null ? void 0 : _a.length) && this.history.push(this.model, i3);
        break;
      }
      case ke.Erase:
        return this.editor.removeSymbols(r2.strokeIds);
      default:
        __privateGet(this, _t27).warn("#applyStrikeThroughGesture", `Unknow OnStrikeThrough: ${this.strikeThroughAction}, values allowed are: ${ke.Draw}, ${ke.Erase}`);
    }
    else __privateGet(this, _t27).warn("applyStrikeThroughGesture", "Unable to apply strikethrough because there are no strokes");
  }
  async apply(i2, r2) {
    switch (__privateGet(this, _t27).info("apply", { gestureStroke: i2, gesture: r2 }), this.editor.updateSymbolsStyle([i2.id], { opacity: (i2.style.opacity || 1) / 2 }, false), await this.editor.removeSymbol(i2.id, false), await this.editor.synchronizeStrokesWithJIIX(), r2.gestureType) {
      case "UNDERLINE":
        await this.applyUnderlineGesture(i2, r2);
        break;
      case "SCRATCH":
        await this.applyScratch(i2, r2);
        break;
      case "JOIN":
        await this.applyJoinGesture(i2, r2);
        break;
      case "INSERT":
        await this.applyInsertGesture(i2, r2);
        break;
      case "STRIKETHROUGH":
        await this.applyStrikeThroughGesture(i2, r2);
        break;
      case "SURROUND":
        await this.applySurroundGesture(i2, r2);
        break;
      default:
        __privateGet(this, _t27).warn("apply", `Gesture unknow: ${r2.gestureType}`);
    }
    return this.editor.event.emitGestured({ gestureType: r2.gestureType, stroke: i2 }), this.editor.svgDebugger.apply(), Promise.resolve();
  }
  async getGestureFromContextLess(i2) {
    const r2 = await this.recognizer.recognizeGesture(i2);
    if (r2) switch (r2.gestureType) {
      case "surround":
        return this.model.symbols.some((r3) => !(r3.id === i2.id || !i2.bounds.contains(r3.bounds)) && (this.surroundAction === ve.Select || [E.Group, E.Stroke, E.Text].includes(r3.type))) ? { gestureType: "SURROUND", gestureStrokeId: i2.id, strokeAfterIds: [], strokeBeforeIds: [], strokeIds: [] } : void 0;
      case "left-right":
      case "right-left": {
        const r3 = this.model.symbols.filter((r4) => r4.id !== i2.id && [E.Text, E.Stroke, E.Group].includes(r4.type) && isBetween(r4.bounds.xMid, i2.bounds.xMin, i2.bounds.xMax) && isBetween(i2.bounds.yMid, r4.bounds.y + 3 * r4.bounds.height / 4, r4.bounds.y + 5 * r4.bounds.height / 4));
        if (r3.length) return { gestureType: "UNDERLINE", gestureStrokeId: i2.id, strokeAfterIds: [], strokeBeforeIds: [], strokeIds: r3.map((i3) => i3.id) };
        const s2 = this.model.symbols.filter((r4) => r4.id !== i2.id && [E.Text, E.Stroke, E.Group].includes(r4.type) && isBetween(r4.bounds.xMid, i2.bounds.xMin, i2.bounds.xMax) && isBetween(i2.bounds.yMid, r4.bounds.y + r4.bounds.height / 4, r4.bounds.y + 3 * r4.bounds.height / 4));
        return s2.length ? { gestureType: "STRIKETHROUGH", gestureStrokeId: i2.id, strokeAfterIds: [], strokeBeforeIds: [], strokeIds: s2.map((i3) => i3.id) } : void 0;
      }
      case "scratch": {
        const r3 = this.model.symbols.filter((r4) => r4.id !== i2.id && (i2.bounds.overlaps(r4.bounds) && [E.Stroke, E.Text, E.Group].includes(r4.type) || i2.bounds.contains(r4.bounds) && [E.Shape, E.Edge].includes(r4.type)));
        return r3.length ? { gestureType: "SCRATCH", gestureStrokeId: i2.id, strokeAfterIds: [], strokeBeforeIds: [], strokeIds: r3.map((i3) => i3.id) } : void 0;
      }
      case "bottom-top":
        return this.model.symbols.some((r3) => r3.id !== i2.id && [E.Text, E.Stroke, E.Group].includes(r3.type) && isBetween(r3.bounds.yMid, i2.bounds.yMin, i2.bounds.yMax)) ? { gestureType: "JOIN", gestureStrokeId: i2.id, strokeAfterIds: [], strokeBeforeIds: [], strokeIds: [] } : void 0;
      case "top-bottom":
        return this.model.symbols.some((r3) => r3.id !== i2.id && [E.Text, E.Stroke, E.Group].includes(r3.type) && isBetween(r3.bounds.yMid, i2.bounds.yMin, i2.bounds.yMax)) ? { gestureType: "INSERT", gestureStrokeId: i2.id, strokeAfterIds: [], strokeBeforeIds: [], strokeIds: [] } : void 0;
      default:
        return;
    }
  }
};
_t27 = new WeakMap();
var IIMenuSub = class {
  constructor(i2) {
    __publicField(this, "element");
    __publicField(this, "content");
    if (this.element = document.createElement("div"), this.element.classList.add("sub-menu"), this.element.appendChild(i2.trigger), this.content = document.createElement("div"), i2.menuTitle) {
      const r2 = document.createElement("h3");
      r2.classList.add("ms-menu-title"), r2.textContent = i2.menuTitle, this.content.appendChild(r2);
    }
    this.content.classList.add("sub-menu-content", i2.position), this.content.appendChild(i2.subMenu), this.element.appendChild(this.content), i2.trigger.addEventListener("pointerdown", () => this.toggle()), document.addEventListener("pointerdown", (i3) => {
      this.element.contains(i3.target) || this.close();
    });
  }
  open() {
    this.content.classList.add("open");
  }
  close() {
    this.content.classList.remove("open");
  }
  toggle() {
    this.content.classList.toggle("open");
  }
  unwrap() {
    this.content.classList.remove("sub-menu-content"), this.element.insertAdjacentElement("beforebegin", this.content), this.element.style.display = "none";
  }
  wrap() {
    this.content.classList.add("sub-menu-content"), this.element.appendChild(this.content), this.element.style.display = "block";
  }
};
var _t28;
var IIMenuAction = class extends IIMenu {
  constructor(i2, r2 = "ms-menu-action") {
    super();
    __privateAdd(this, _t28, LoggerManager.getLogger(d.MENU));
    __publicField(this, "editor");
    __publicField(this, "id");
    __publicField(this, "wrapper");
    __publicField(this, "menuLanguage");
    __publicField(this, "menuClear");
    __publicField(this, "menuUndo");
    __publicField(this, "menuRedo");
    __publicField(this, "menuConvert");
    __publicField(this, "guideGaps", [{ label: "S", value: "25" }, { label: "M", value: "50" }, { label: "L", value: "100" }, { label: "XL", value: "150" }]);
    this.id = r2, this.editor = i2;
  }
  get model() {
    return this.editor.model;
  }
  get isMobile() {
    return this.editor.renderer.parent.clientWidth < 700;
  }
  createMenuClear() {
    return this.menuClear = document.createElement("button"), this.menuClear.id = `${this.id}-clear`, this.menuClear.classList.add("ms-menu-button", "square"), this.menuClear.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M20 9L18.005 20.3463C17.8369 21.3026 17.0062 22 16.0353 22H7.96474C6.99379 22 6.1631 21.3026 5.99496 20.3463L4 9"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M21 6L15.375 6M3 6L8.625 6M8.625 6V4C8.625 2.89543 9.52043 2 10.625 2H13.375C14.4796 2 15.375 2.89543 15.375 4V6M8.625 6L15.375 6"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n', this.menuClear.addEventListener("pointerup", () => {
      __privateGet(this, _t28).info(`${this.id}.clear`), this.editor.clear();
    }), this.menuClear;
  }
  createMenuLanguage() {
    const i2 = document.createElement("button");
    i2.id = `${this.id}-language-trigger`, i2.classList.add("ms-menu-button", "square"), i2.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  stroke-width="1"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M2 12C2 17.5228 6.47715 22 12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12Z"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M13 2.04932C13 2.04932 16 5.99994 16 11.9999C16 17.9999 13 21.9506 13 21.9506"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M11 21.9506C11 21.9506 8 17.9999 8 11.9999C8 5.99994 11 2.04932 11 2.04932"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path d="M2.62964 15.5H21.3704" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M2.62964 8.5H21.3704" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n</svg>\n';
    const r2 = document.createElement("select");
    r2.classList.add("select-language"), r2.id = `${this.id}-language`, getAvailableLanguageList(this.editor.configuration).then((i3) => {
      const s3 = i3.result;
      Object.keys(s3).forEach((i4) => {
        const n2 = i4 === this.editor.configuration.recognition.lang, a2 = new Option(s3[i4], i4, n2, n2);
        r2.appendChild(a2);
      });
    }), r2.addEventListener("change", (i3) => {
      __privateGet(this, _t28).info(`${this.id}.selectLanguage`);
      const r3 = i3.target.value;
      this.editor.changeLanguage(r3);
    });
    const s2 = { trigger: i2, subMenu: r2, position: "bottom-right" };
    return this.menuLanguage = new IIMenuSub(s2), this.menuLanguage.element;
  }
  createMenuUndo() {
    return this.menuUndo = document.createElement("button"), this.menuUndo.id = `${this.id}-undo`, this.menuUndo.classList.add("ms-menu-button", "square"), this.menuUndo.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M4.5 8C8.5 8 11 8 15 8C15 8 15 8 15 8C15 8 20 8 20 12.7059C20 18 15 18 15 18C11.5714 18 9.71429 18 6.28571 18"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M7.5 11.5C6.13317 10.1332 5.36683 9.36683 4 8C5.36683 6.63317 6.13317 5.86683 7.5 4.5"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n', this.menuUndo.addEventListener("pointerup", async () => {
      __privateGet(this, _t28).info(`${this.id}.undo`), await this.editor.undo();
    }), this.menuUndo;
  }
  createMenuRedo() {
    return this.menuRedo = document.createElement("button"), this.menuRedo.id = `${this.id}-redo`, this.menuRedo.classList.add("ms-menu-button", "square"), this.menuRedo.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M19.5 8C15.5 8 13 8 9 8C9 8 9 8 9 8C9 8 4 8 4 12.7059C4 18 9 18 9 18C12.4286 18 14.2857 18 17.7143 18"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M16.5 11.5C17.8668 10.1332 18.6332 9.36683 20 8C18.6332 6.63317 17.8668 5.86683 16.5 4.5"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n', this.menuRedo.addEventListener("pointerup", async () => {
      __privateGet(this, _t28).info(`${this.id}.redo`), await this.editor.redo();
    }), this.menuRedo;
  }
  createMenuConvert() {
    return this.menuConvert = document.createElement("button"), this.menuConvert.id = `${this.id}-convert`, this.menuConvert.classList.add("ms-menu-button", "square"), this.menuConvert.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M2 5H9M16 5H13.5M9 5L13.5 5M9 5V3M13.5 5C12.6795 7.73513 10.9612 10.3206 9 12.5929M4 17.5C5.58541 16.1411 7.376 14.4744 9 12.5929M9 12.5929C8 11.5 6.4 9.3 6 8.5M9 12.5929L12 15.5"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M13.5 21L14.6429 18M21.5 21L20.3571 18M14.6429 18L17.5 10.5L20.3571 18M14.6429 18H20.3571"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n', this.menuConvert.addEventListener("pointerup", () => {
      __privateGet(this, _t28).info(`${this.id}.convert`), this.editor.convert();
    }), this.menuConvert;
  }
  createMenuGesture() {
    const s2 = document.createElement("button");
    s2.id = `${this.id}-gesture`, s2.classList.add("ms-menu-button", "square"), s2.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M18 7.5L18.9187 7.65312C20.0497 7.84162 20.791 8.94046 20.5423 10.0598L20.0143 12.4357C20.0048 12.4784 20 12.5223 20 12.5661C20 15.1904 20 17.5 20 17.5C20 17.5 20 17.5 20 17.5C20 19.5 18.4 21.5 16 21.5C14.1259 21.5 11.0119 21.5 9.41979 21.5C8.83594 21.5 8.28132 21.2449 7.90136 20.8016L3.35288 15.495C2.85811 14.9178 2.84375 14.0703 3.31868 13.4767V13.4767C3.93438 12.707 5.09624 12.6814 5.74526 13.4231L8 16V12.5"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M9 5L8.20966 5.13172C7.03189 5.32802 6.28739 6.50588 6.61542 7.65395L8 12.5"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M11 12.5L8.92263 4.60598C8.69579 3.744 9.25886 2.87352 10.1381 2.72699V2.72699C10.9097 2.59838 11.6523 3.07873 11.8514 3.83526L14 12"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M17 12.5L18 7.5L18.2475 6.01515C18.3869 5.17836 17.8216 4.38694 16.9848 4.24747V4.24747C16.16 4.11 15.3767 4.65763 15.2226 5.47955L14 12"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n';
    const n2 = document.createElement("div");
    n2.classList.add("ms-menu-colmun");
    const a2 = [];
    for (const i2 in ve) {
      const r2 = ve[i2];
      a2.push({ label: i2, value: r2 });
    }
    const l2 = [];
    for (const i2 in ke) {
      const r2 = ke[i2];
      l2.push({ label: i2, value: r2 });
    }
    const d2 = [];
    for (const i2 in Ee) {
      const r2 = Ee[i2];
      d2.push({ label: i2, value: r2 });
    }
    [{ type: "checkbox", id: `${this.id}-gesture-detect`, label: "Detect gesture", initValue: this.editor.writer.detectGesture, callback: (s3) => {
      __privateGet(this, _t28).info(`${this.id}.gesture-detect`, { value: s3 }), this.editor.writer.detectGesture = s3, this.editor.tool = i.Write, this.editor.writer.tool = r.Pencil;
    } }, { type: "select", id: `${this.id}-gesture-surround`, label: "On surround", values: a2, initValue: this.editor.gesture.surroundAction, callback: (s3) => {
      __privateGet(this, _t28).info(`${this.id}.gesture-surround`, { value: s3 }), this.editor.gesture.surroundAction = s3, this.editor.tool = i.Write, this.editor.writer.tool = r.Pencil;
    } }, { type: "select", id: `${this.id}-gesture-strikethrough`, label: "On strikethrough", values: l2, initValue: this.editor.gesture.strikeThroughAction, callback: (s3) => {
      __privateGet(this, _t28).info(`${this.id}.gesture-strikethrough`, { value: s3 }), this.editor.gesture.strikeThroughAction = s3, this.editor.tool = i.Write, this.editor.writer.tool = r.Pencil;
    } }, { type: "select", id: `${this.id}-gesture-insert`, label: "On insert", values: d2, initValue: this.editor.gesture.insertAction, callback: (s3) => {
      __privateGet(this, _t28).info(`${this.id}.gesture-InsertAction`, { value: s3 }), this.editor.gesture.insertAction = s3, this.editor.tool = i.Write, this.editor.writer.tool = r.Pencil;
    } }].forEach((i2) => {
      n2.appendChild(this.createMenuItem(i2));
    });
    return new IIMenuSub({ trigger: s2, menuTitle: "Gesture", subMenu: n2, position: "right-top" }).element;
  }
  createMenuGuide() {
    const i2 = document.createElement("button");
    i2.id = `${this.id}-guide`, i2.classList.add("ms-menu-button", "square"), i2.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  stroke-width="1"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path d="M3 21V3H21V21H3Z" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M3 16.5H12H21" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M3 12H21" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M3 7.5H21" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M16.5 3V12V21" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M12 3V21" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M7.5 3V21" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n</svg>\n';
    const r2 = document.createElement("div");
    r2.classList.add("ms-menu-colmun");
    [{ type: "checkbox", id: `${this.id}-guide-enable`, label: "Show guide", initValue: this.editor.configuration.rendering.guides.enable, callback: (i3) => {
      __privateGet(this, _t28).info(`${this.id}.guide-enable`, { value: i3 }), this.editor.configuration.rendering.guides.enable = i3, this.editor.renderingConfiguration = this.editor.configuration.rendering;
    } }, { type: "select", id: `${this.id}-guide-type`, label: "Guide style", values: [{ label: "Line", value: "line" }, { label: "Grid", value: "grid" }, { label: "Point", value: "point" }], initValue: this.editor.configuration.rendering.guides.type, callback: (i3) => {
      __privateGet(this, _t28).info(`${this.id}.guide-type`, { value: i3 }), this.editor.configuration.rendering.guides.type = i3, this.editor.renderingConfiguration = this.editor.configuration.rendering;
    } }, { type: "list", id: `${this.id}-guide-size`, label: "Guide style", values: this.guideGaps, initValue: this.editor.configuration.rendering.guides.gap.toString(), callback: (i3) => {
      __privateGet(this, _t28).info(`${this.id}.guide-size`, { value: i3 }), this.editor.configuration.rendering.guides.gap = +i3, this.editor.renderingConfiguration = this.editor.configuration.rendering;
    } }].forEach((i3) => {
      r2.appendChild(this.createMenuItem(i3));
    });
    return new IIMenuSub({ trigger: i2, menuTitle: "Guide", subMenu: r2, position: "right-top" }).element;
  }
  createMenuSnap() {
    const i2 = document.createElement("button");
    i2.id = `${this.id}-snap`, i2.classList.add("ms-menu-button", "square"), i2.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M 19 14 C 17.8954 14 17 13.1046 17 12 C 17 10.8954 17.8954 10 19 10 C 20.1046 10 21 10.8954 21 12 C 21 13.1046 20.1046 14 19 14 Z"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path d="M 4 12 H 17 M 17 12 L 14 9 M 17 12 L 14 15" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n</svg>\n';
    const r2 = document.createElement("div");
    r2.classList.add("ms-menu-colmun");
    [{ type: "checkbox", id: `${this.id}-snap-to-guide`, label: "Snap to guide", initValue: this.editor.snaps.configuration.guide, callback: (i3) => this.editor.snaps.configuration.guide = i3 }, { type: "checkbox", id: `${this.id}-snap-to-element`, label: "Snap to element", initValue: this.editor.snaps.configuration.symbol, callback: (i3) => this.editor.snaps.configuration.symbol = i3 }, { type: "select", id: `${this.id}-snap-angle`, label: "Snap angle", values: [{ label: "None", value: "0" }, { label: "10°", value: "10" }, { label: "30°", value: "30" }, { label: "45°", value: "45" }, { label: "90°", value: "90" }, { label: "180°", value: "180" }], initValue: this.editor.snaps.configuration.angle.toString(), callback: (i3) => this.editor.snaps.configuration.angle = +i3 }].forEach((i3) => {
      r2.appendChild(this.createMenuItem(i3));
    });
    return new IIMenuSub({ trigger: i2, menuTitle: "Snap", subMenu: r2, position: "right-top" }).element;
  }
  createMenuDebug() {
    const i2 = document.createElement("button");
    i2.id = `${this.id}-debug`, i2.classList.add("ms-menu-button", "square"), i2.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  stroke-width="1"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M5.81249 7C5.81249 7 5.35861 7.62759 4.81552 8.66667M18.1875 7C18.1875 7 18.6414 7.62759 19.1845 8.66667M4.81552 8.66667C4.0067 10.2142 3 12.6743 3 15.3333C5.8125 15.3333 7.49999 17 7.49999 17C7.49999 17 8.62499 22 12 22C15.375 22 16.5 17 16.5 17C16.5 17 18.1875 15.3333 21 15.3333C21 12.6743 19.9933 10.2142 19.1845 8.66667M4.81552 8.66667C4.81552 8.66667 1.875 6.44436 4.81552 2C5.81249 2.55556 8.625 4.77778 8.625 4.77778C8.625 4.77778 10.3125 3.66667 12 3.66667C13.6875 3.66667 15.375 4.77778 15.375 4.77778C15.375 4.77778 18.1875 2.55556 19.3125 2C22.125 6.44456 19.1845 8.66667 19.1845 8.66667"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path d="M11 18L12 18M13 18L12 18M12 18L12 19" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M8.5 12.5L10 14" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M15.5 12.5L14 14" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n</svg>\n';
    const r2 = [{ type: "checkbox", id: `${this.id}-debug-bounding-box`, label: "Show bounding box", initValue: this.editor.svgDebugger.boundingBoxVisibility, callback: (i3) => this.editor.svgDebugger.boundingBoxVisibility = i3 }, { type: "checkbox", id: `${this.id}-debug-recognition-box`, label: "Show recognition box", initValue: this.editor.svgDebugger.recognitionBoxVisibility, callback: (i3) => this.editor.svgDebugger.recognitionBoxVisibility = i3 }, { type: "checkbox", id: `${this.id}-debug-bounding-item-box`, label: "Show recognition item box", initValue: this.editor.svgDebugger.recognitionItemBoxVisibility, callback: (i3) => this.editor.svgDebugger.recognitionItemBoxVisibility = i3 }, { type: "checkbox", id: `${this.id}-debug-snap-points`, label: "Show snap points", initValue: this.editor.svgDebugger.snapPointsVisibility, callback: (i3) => this.editor.svgDebugger.snapPointsVisibility = i3 }, { type: "checkbox", id: `${this.id}-debug-vertices`, label: "Show vertices", initValue: this.editor.svgDebugger.verticesVisibility, callback: (i3) => this.editor.svgDebugger.verticesVisibility = i3 }], s2 = document.createElement("div");
    s2.classList.add("ms-menu-colmun"), r2.forEach((i3) => {
      s2.appendChild(this.createMenuItem(i3));
    });
    return new IIMenuSub({ trigger: i2, menuTitle: "Debug", subMenu: s2, position: "right-top" }).element;
  }
  createMenuExport() {
    const i2 = document.createElement("button");
    i2.id = `${this.id}-export`, i2.classList.add("ms-menu-button", "square"), i2.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  stroke-width="1"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="#000000"\n>\n  <path d="M6 20L18 20" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M12 4V16M12 16L15.5 12.5M12 16L8.5 12.5" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n</svg>\n';
    const r2 = [{ type: "button", id: `${this.id}-export-json`, label: "json", callback: () => {
      this.editor.downloadAsJson();
    } }, { type: "button", id: `${this.id}-export-svg`, label: "svg", callback: () => {
      this.editor.downloadAsSVG();
    } }, { type: "button", id: `${this.id}-export-png`, label: "png", callback: () => {
      this.editor.downloadAsPNG();
    } }], s2 = document.createElement("div");
    s2.classList.add("ms-menu-colmun"), r2.forEach((i3) => {
      s2.appendChild(this.createMenuItem(i3));
    });
    return new IIMenuSub({ trigger: i2, menuTitle: "Export", subMenu: s2, position: "right-top" }).element;
  }
  async readFileAsText(i2) {
    return new Promise((r2, s2) => {
      const n2 = new FileReader();
      n2.onerror = s2, n2.onload = () => {
        r2(n2.result);
      }, i2 && n2.readAsText(i2);
    });
  }
  createMenuImport() {
    const i2 = document.createElement("button");
    i2.id = `${this.id}-import`, i2.classList.add("ms-menu-button", "square"), i2.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  stroke-width="1"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="#000000"\n>\n  <path d="M6 20L18 20" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M12 16V4M12 4L15.5 7.5M12 4L8.5 7.5" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n</svg>\n';
    const r2 = document.createElement("div");
    r2.classList.add("ms-menu-colmun");
    const s2 = document.createElement("input");
    s2.type = "file", s2.accept = ".json", s2.multiple = false, s2.addEventListener("change", () => {
      var _a;
      n2.disabled = !((_a = s2.files) == null ? void 0 : _a.length);
    }), r2.appendChild(s2);
    const n2 = document.createElement("button");
    n2.classList.add("ms-menu-button"), n2.innerText = "Import", n2.disabled = true, r2.appendChild(n2), n2.addEventListener("pointerup", async (i3) => {
      var _a;
      if (i3.preventDefault(), i3.stopPropagation(), (_a = s2.files) == null ? void 0 : _a.length) {
        const i4 = await this.readFileAsText(s2.files[0]), r3 = JSON.parse(i4);
        await this.editor.createSymbols(r3), s2.value = "", n2.disabled = true;
      }
    });
    return new IIMenuSub({ trigger: i2, menuTitle: "Import", subMenu: r2, position: "right-top" }).element;
  }
  unselectAll() {
    var _a;
    (_a = this.wrapper) == null ? void 0 : _a.querySelectorAll("*").forEach((i2) => i2.classList.remove("active"));
  }
  closeAllSubMenu() {
    var _a;
    (_a = this.wrapper) == null ? void 0 : _a.querySelectorAll(".open").forEach((i2) => i2.classList.remove("open"));
  }
  render(i2) {
    if (this.editor.configuration.menu.action.enable) {
      const r2 = document.createElement("button");
      r2.id = this.id, r2.classList.add("ms-menu-button", "square"), r2.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  stroke-width="1"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path d="M3 5H21" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M3 12H21" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M3 19H21" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n</svg>\n';
      const s2 = document.createElement("div");
      s2.classList.add("ms-menu-colmun"), s2.appendChild(this.createMenuGesture()), s2.appendChild(this.createMenuGuide()), s2.appendChild(this.createMenuSnap()), s2.appendChild(this.createMenuDebug()), s2.appendChild(this.createMenuImport()), s2.appendChild(this.createMenuExport()), this.wrapper = document.createElement("div"), this.wrapper.classList.add("ms-menu", "ms-menu-top-left", "ms-menu-row"), this.wrapper.appendChild(new IIMenuSub({ trigger: r2, subMenu: s2, position: "bottom" }).element), this.wrapper.appendChild(this.createMenuLanguage()), this.wrapper.appendChild(this.createMenuClear()), this.wrapper.appendChild(this.createMenuUndo()), this.wrapper.appendChild(this.createMenuRedo()), this.wrapper.appendChild(this.createMenuConvert()), i2.appendChild(this.wrapper), this.update(), this.show();
    }
  }
  update() {
    this.menuLanguage && (this.isMobile ? this.menuLanguage.wrap() : this.menuLanguage.unwrap()), this.menuClear && (this.menuClear.disabled = this.editor.history.context.empty), this.menuUndo && (this.menuUndo.disabled = !this.editor.history.context.canUndo), this.menuRedo && (this.menuRedo.disabled = !this.editor.history.context.canRedo), this.menuConvert && (this.menuConvert.disabled = !this.editor.extractStrokesFromSymbols(this.model.symbols).length);
  }
  show() {
    this.wrapper && (this.wrapper.style.visibility = "visible");
  }
  hide() {
    this.wrapper && (this.wrapper.style.visibility = "hidden");
  }
  destroy() {
    if (this.wrapper) {
      for (; this.wrapper.lastChild; ) this.wrapper.removeChild(this.wrapper.lastChild);
      this.wrapper.remove(), this.wrapper = void 0, this.menuClear = void 0, this.menuUndo = void 0, this.menuRedo = void 0, this.menuConvert = void 0;
    }
  }
};
_t28 = new WeakMap();
var Ce = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M 21 5 V 17.986 C 21 19 21 19 20 19 H 4 C 3 19 3 19 3.015 17.986 V 5 C 3 4 3 4 4 4 H 20.4 C 21 4 21 4 21 5 Z"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n';
var Me = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path d="M3 20L21 4" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n</svg>\n';
var _t29;
var IIMenuTool = class extends IIMenu {
  constructor(i2, r2 = "ms-menu-tool") {
    super();
    __privateAdd(this, _t29, LoggerManager.getLogger(d.MENU));
    __publicField(this, "editor");
    __publicField(this, "id");
    __publicField(this, "wrapper");
    __publicField(this, "writeBtn");
    __publicField(this, "menuSelect");
    __publicField(this, "menuMove");
    __publicField(this, "menuErase");
    __publicField(this, "menuShape");
    __publicField(this, "subMenuShape");
    __publicField(this, "menuEdge");
    __publicField(this, "subMenuEdge");
    this.id = r2, __privateGet(this, _t29).info("constructor"), this.editor = i2;
  }
  createMenuWrite() {
    return this.writeBtn = document.createElement("button"), this.writeBtn.id = `${this.id}-write-pencil`, this.writeBtn.classList.add("ms-menu-button", "square"), this.writeBtn.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M14.3632 5.65156L15.8431 4.17157C16.6242 3.39052 17.8905 3.39052 18.6716 4.17157L20.0858 5.58579C20.8668 6.36683 20.8668 7.63316 20.0858 8.41421L18.6058 9.8942M14.3632 5.65156L4.74749 15.2672C4.41542 15.5993 4.21079 16.0376 4.16947 16.5054L3.92738 19.2459C3.87261 19.8659 4.39148 20.3848 5.0115 20.33L7.75191 20.0879C8.21972 20.0466 8.65806 19.8419 8.99013 19.5099L18.6058 9.8942M14.3632 5.65156L18.6058 9.8942"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n', this.writeBtn.addEventListener("pointerup", () => {
      this.unselectAll(), this.writeBtn.classList.add("active"), this.editor.tool = i.Write, this.editor.writer.tool = r.Pencil;
    }), this.writeBtn;
  }
  createMenuMove() {
    return this.menuMove = document.createElement("button"), this.menuMove.id = `${this.id}-move`, this.menuMove.classList.add("ms-menu-button", "square"), this.menuMove.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M7 10.5L4.99591 13.1721C4.41845 13.9421 4.47127 15.0141 5.1216 15.7236L8.9055 19.8515C9.28432 20.2647 9.81826 20.5 10.3789 20.5C11.4651 20.5 13.2415 20.5 15 20.5C17.4 20.5 19 19 19 16.5C19 16.5 19 16.5 19 16.5C19 16.5 19 9.64287 19 7.92859"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M16 8.49995C16 8.49995 16 8.37483 16 7.92852C16 5.6428 19 5.6428 19 7.92852"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M13 8.50008C13 8.50008 13 7.91978 13 7.02715M13 6.50008C13 6.50008 13 6.804 13 7.02715M16 8.50008C16 8.50008 16 8.37496 16 7.92865C16 7.70549 16 7.25031 16 7.02715C16 4.74144 13 4.74144 13 7.02715"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M13 8.50008C13 8.50008 13 7.91978 13 7.02715C13 4.74144 16 4.74144 16 7.02715C16 7.25031 16 7.70549 16 7.92865C16 8.37496 16 8.50008 16 8.50008"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M10 8.50005C10 8.50005 10 7.85719 10 6.50005C10 4.21434 13 4.21434 13 6.50005C13 6.50005 13 6.50005 13 6.50005C13 6.50005 13 6.80397 13 7.02713C13 7.91975 13 8.50005 13 8.50005"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M7 13.5001V6.50006C7 5.67164 7.67157 5.00006 8.5 5.00006V5.00006C9.32843 5.00006 10 5.55527 10 6.38369C10 6.42151 10 6.4603 10 6.50006C10 7.85721 10 8.50006 10 8.50006"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n', this.menuMove.addEventListener("pointerup", () => {
      this.unselectAll(), this.menuMove.classList.add("active"), this.editor.tool = i.Move;
    }), this.menuMove;
  }
  createMenuSelect() {
    return this.menuSelect = document.createElement("button"), this.menuSelect.id = `${this.id}-select`, this.menuSelect.classList.add("ms-menu-button", "square"), this.menuSelect.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M4.9984 2H2V4.9984H4.9984V2Z"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-miterlimit="1.5"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M4.99854 3.50098H18.9987"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-miterlimit="1.5"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path d="M3.5 4.99854V19.0005" stroke="currentColor" stroke-width="1" stroke-miterlimit="1.5" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M20.4978 5V19.002" stroke="currentColor" stroke-width="1" stroke-miterlimit="1.5" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M4.99854 20.501H18.9987" stroke="currentColor" stroke-width="1" stroke-miterlimit="1.5" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path\n    d="M4.9984 19H2V21.9984H4.9984V19Z"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-miterlimit="1.5"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M21.9974 2.00195H18.999V5.00035H21.9974V2.00195Z"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-miterlimit="1.5"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    d="M21.9974 19.002H18.999V22.0004H21.9974V19.002Z"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-miterlimit="1.5"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    fill-rule="evenodd"\n    clip-rule="evenodd"\n    d="M10.9966 15.002L7.99658 8.00195L14.9966 11.002L11.9986 12.0009L10.9966 15.002Z"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-miterlimit="1.5"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n  <path\n    fill-rule="evenodd"\n    clip-rule="evenodd"\n    d="M11.999 12.002L14.997 15.002L11.999 12.002Z"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-miterlimit="1.5"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n', this.menuSelect.addEventListener("pointerup", () => {
      this.unselectAll(), this.menuSelect.classList.add("active"), this.editor.tool = i.Select;
    }), this.menuSelect;
  }
  createMenuErase() {
    return this.menuErase = document.createElement("button"), this.menuErase.id = `${this.id}-erase`, this.menuErase.classList.add("ms-menu-button", "square"), this.menuErase.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path d="M21 21L9 21" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M15.889 14.8891L8.46436 7.46448" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path\n    d="M2.8934 12.6066L12.0858 3.41421C12.8668 2.63317 14.1332 2.63317 14.9142 3.41421L19.864 8.36396C20.645 9.14501 20.645 10.4113 19.864 11.1924L10.6213 20.435C10.2596 20.7968 9.76894 21 9.25736 21C8.74577 21 8.25514 20.7968 7.8934 20.435L2.8934 15.435C2.11235 14.654 2.11235 13.3877 2.8934 12.6066Z"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n', this.menuErase.addEventListener("pointerup", () => {
      this.unselectAll(), this.menuErase.classList.add("active"), this.editor.tool = i.Erase;
    }), this.menuErase;
  }
  createShapeSubMenu(r2, s2) {
    const n2 = document.createElement("button");
    return n2.id = `${this.id}-write-shape-${s2}`, n2.classList.add("ms-menu-button", "square"), n2.innerHTML = r2, n2.addEventListener("pointerup", () => {
      this.unselectAll(), this.editor.tool = i.Write, this.editor.writer.tool = s2, n2.classList.add("active"), this.menuShape.innerHTML = r2, this.menuShape.classList.add("active");
      const a2 = this.menuShape.nextSibling;
      a2 && a2.classList.remove("open");
    }), n2;
  }
  createMenuShape() {
    this.menuShape = document.createElement("button"), this.menuShape.id = `${this.id}-write-shape`, this.menuShape.classList.add("ms-menu-button", "square"), this.menuShape.innerHTML = Ce, this.subMenuShape = { circle: this.createShapeSubMenu('<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n', r.Circle), rectangle: this.createShapeSubMenu(Ce, r.Rectangle), triangle: this.createShapeSubMenu('<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M11.4752 2.94682C11.7037 2.53464 12.2963 2.53464 12.5248 2.94682L21.8985 19.8591C22.1202 20.259 21.831 20.75 21.3738 20.75H2.62625C2.16902 20.75 1.87981 20.259 2.10146 19.8591L11.4752 2.94682Z"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n', r.Triangle), ellipse: this.createShapeSubMenu('<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M 12 19 C 18 19 22 17 22 12 C 22 7 18 5 12 5 C 6 5 2 7 2 12 C 2 17 6 19 12 19 Z"\n    stroke="currentColor"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n', r.Ellipse), rhombus: this.createShapeSubMenu('<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M11.5757 1.42426C11.81 1.18995 12.1899 1.18995 12.4243 1.42426L22.5757 11.5757C22.81 11.81 22.8101 12.1899 22.5757 12.4243L12.4243 22.5757C12.19 22.81 11.8101 22.8101 11.5757 22.5757L1.42426 12.4243C1.18995 12.19 1.18995 11.8101 1.42426 11.5757L11.5757 1.42426Z"\n    stroke="#000000"\n    stroke-width="1"\n    stroke-linecap="round"\n    stroke-linejoin="round"\n  ></path>\n</svg>\n', r.Rhombus) };
    const i2 = document.createElement("div");
    i2.id = `${this.id}-write-shape-list`, i2.classList.add("ms-menu-row", "sub-menu-content-shape"), i2.appendChild(this.subMenuShape.rectangle), i2.appendChild(this.subMenuShape.circle), i2.appendChild(this.subMenuShape.ellipse), i2.appendChild(this.subMenuShape.triangle), i2.appendChild(this.subMenuShape.rhombus);
    const s2 = { trigger: this.menuShape, subMenu: i2, position: "top" };
    return new IIMenuSub(s2).element;
  }
  createEdgeSubMenu(r2, s2) {
    const n2 = document.createElement("button");
    return n2.id = `${this.id}-write-edge-${s2}`, n2.classList.add("ms-menu-button", "square"), n2.innerHTML = r2, n2.addEventListener("pointerup", () => {
      this.unselectAll(), this.editor.tool = i.Write, this.editor.writer.tool = s2, n2.classList.add("active"), this.menuEdge.innerHTML = r2, this.menuEdge.classList.add("active");
      const a2 = this.menuEdge.nextSibling;
      a2 && a2.classList.remove("open");
    }), n2;
  }
  createMenuEdge() {
    this.menuEdge = document.createElement("button"), this.menuEdge.id = `${this.id}-write-edge`, this.menuEdge.classList.add("ms-menu-button", "square"), this.menuEdge.innerHTML = Me, this.subMenuEdge = { line: this.createEdgeSubMenu(Me, r.Line), arrow: this.createEdgeSubMenu('<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path d="M3 20L21 4" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M15 5L21 4L 20 10" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n</svg>\n', r.Arrow), doubleArrow: this.createEdgeSubMenu('<svg\n  width="24px"\n  height="24px"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path d="M3 20L21 4" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M9 19L3 20L 4 14" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M15 5L21 4L 20 10" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n</svg>\n', r.DoubleArrow) };
    const i2 = document.createElement("div");
    i2.id = `${this.id}-write-edge-list`, i2.classList.add("ms-menu-row", "sub-menu-content-edge"), i2.appendChild(this.subMenuEdge.line), i2.appendChild(this.subMenuEdge.arrow), i2.appendChild(this.subMenuEdge.doubleArrow);
    const s2 = { trigger: this.menuEdge, subMenu: i2, position: "top" };
    return new IIMenuSub(s2).element;
  }
  unselectAll() {
    var _a;
    (_a = this.wrapper) == null ? void 0 : _a.querySelectorAll("*").forEach((i2) => i2.classList.remove("active"));
  }
  update() {
    var _a, _b2, _c2, _d6, _e2, _f2, _g2, _h2, _i2, _j, _k2, _l2, _m5, _n2, _o2, _p2, _q2, _r4, _s2, _t35, _u2, _v2, _w2, _x3, _y5;
    switch (this.unselectAll(), this.editor.tool) {
      case i.Erase:
        (_a = this.menuErase) == null ? void 0 : _a.classList.add("active");
        break;
      case i.Move:
        (_b2 = this.menuMove) == null ? void 0 : _b2.classList.add("active");
        break;
      case i.Select:
        (_c2 = this.menuSelect) == null ? void 0 : _c2.classList.add("active");
        break;
      case i.Write:
        switch (this.editor.writer.tool) {
          case r.Circle:
            (_d6 = this.menuShape) == null ? void 0 : _d6.classList.add("active"), (_f2 = (_e2 = this.subMenuShape) == null ? void 0 : _e2.circle) == null ? void 0 : _f2.classList.add("active");
            break;
          case r.Ellipse:
            (_g2 = this.menuShape) == null ? void 0 : _g2.classList.add("active"), (_i2 = (_h2 = this.subMenuShape) == null ? void 0 : _h2.ellipse) == null ? void 0 : _i2.classList.add("active");
            break;
          case r.Triangle:
            (_j = this.menuShape) == null ? void 0 : _j.classList.add("active"), (_l2 = (_k2 = this.subMenuShape) == null ? void 0 : _k2.triangle) == null ? void 0 : _l2.classList.add("active");
            break;
          case r.Rectangle:
            (_m5 = this.menuShape) == null ? void 0 : _m5.classList.add("active"), (_o2 = (_n2 = this.subMenuShape) == null ? void 0 : _n2.rectangle) == null ? void 0 : _o2.classList.add("active");
            break;
          case r.Line:
            (_p2 = this.menuEdge) == null ? void 0 : _p2.classList.add("active"), (_r4 = (_q2 = this.subMenuEdge) == null ? void 0 : _q2.line) == null ? void 0 : _r4.classList.add("active");
            break;
          case r.Arrow:
            (_s2 = this.menuEdge) == null ? void 0 : _s2.classList.add("active"), (_u2 = (_t35 = this.subMenuEdge) == null ? void 0 : _t35.arrow) == null ? void 0 : _u2.classList.add("active");
            break;
          case r.DoubleArrow:
            (_v2 = this.menuEdge) == null ? void 0 : _v2.classList.add("active"), (_x3 = (_w2 = this.subMenuEdge) == null ? void 0 : _w2.doubleArrow) == null ? void 0 : _x3.classList.add("active");
            break;
          default:
            (_y5 = this.writeBtn) == null ? void 0 : _y5.classList.add("active");
        }
    }
  }
  render(i2) {
    this.editor.configuration.menu.tool.enable && (this.wrapper = document.createElement("div"), this.wrapper.classList.add("ms-menu", "ms-menu-bottom", "ms-menu-row"), this.wrapper.appendChild(this.createMenuWrite()), this.wrapper.appendChild(this.createMenuMove()), this.wrapper.appendChild(this.createMenuSelect()), this.wrapper.appendChild(this.createMenuErase()), this.wrapper.appendChild(this.createMenuEdge()), this.wrapper.appendChild(this.createMenuShape()), i2.appendChild(this.wrapper), this.update(), this.show());
  }
  show() {
    this.wrapper && (this.wrapper.style.visibility = "visible");
  }
  hide() {
    this.wrapper && (this.wrapper.style.visibility = "hidden");
  }
  destroy() {
    if (this.wrapper) {
      for (; this.wrapper.lastChild; ) this.wrapper.removeChild(this.wrapper.lastChild);
      this.wrapper.remove(), this.writeBtn = void 0, this.menuSelect = void 0, this.menuMove = void 0, this.menuErase = void 0, this.menuShape = void 0, this.subMenuShape = void 0, this.menuEdge = void 0, this.subMenuEdge = void 0, this.wrapper = void 0;
    }
  }
};
_t29 = new WeakMap();
var _t30;
var IIMenuStyle = class extends IIMenu {
  constructor(i2, r2 = "ms-menu-style") {
    super();
    __privateAdd(this, _t30, LoggerManager.getLogger(d.MENU));
    __publicField(this, "editor");
    __publicField(this, "id");
    __publicField(this, "wrapper");
    __publicField(this, "subMenu");
    __publicField(this, "triggerBtn");
    __publicField(this, "menuColorStroke");
    __publicField(this, "menuColorFill");
    __publicField(this, "menuThickness");
    __publicField(this, "menuFontSize");
    __publicField(this, "menuFontWeight");
    __publicField(this, "menuStrokeOpacity");
    this.id = r2, __privateGet(this, _t30).info("constructor"), this.editor = i2;
  }
  get model() {
    return this.editor.model;
  }
  get symbolsSelected() {
    return this.model.symbolsSelected;
  }
  get writeShape() {
    return ![r.Arrow, r.DoubleArrow, r.Line, r.Pencil].includes(this.editor.writer.tool);
  }
  get rowHeight() {
    return this.editor.configuration.rendering.guides.gap;
  }
  get isMobile() {
    return this.editor.renderer.parent.clientWidth < 700;
  }
  createMenuStroke() {
    var _a, _b2;
    const i2 = this.symbolsSelected.map((i3) => i3.style), r2 = i2.length && i2.every((r3) => {
      var _a2;
      return r3.color === ((_a2 = i2[0]) == null ? void 0 : _a2.color);
    }) && ((_a = i2[0]) == null ? void 0 : _a.color) ? (_b2 = i2[0]) == null ? void 0 : _b2.color : this.editor.penStyle.color, s2 = { type: "colors", label: "Colors", id: `${this.id}-color`, fill: false, values: this.colors, initValue: r2, callback: (i3) => {
      this.editor.penStyle = { color: i3 }, this.editor.updateSymbolsStyle(this.symbolsSelected.map((i4) => i4.id), { color: i3 });
    } }, n2 = this.createColorList(s2);
    return this.menuColorStroke = this.createWrapCollapsible(n2, "Colors"), this.menuColorStroke.id = `${this.id}-color`, this.menuColorStroke;
  }
  createMenuColorFill() {
    const i2 = this.symbolsSelected.map((i3) => i3.style), r2 = i2.length && i2.every((r3) => {
      var _a;
      return r3.color === ((_a = i2[0]) == null ? void 0 : _a.color);
    }) && i2[0].color ? i2[0].color : this.editor.penStyle.color, s2 = { type: "colors", label: "Fill", id: `${this.id}-fill`, fill: true, values: this.colors, initValue: r2, callback: (i3) => {
      this.editor.penStyle = { fill: i3 }, this.editor.updateSymbolsStyle(this.symbolsSelected.map((i4) => i4.id), { fill: i3 });
    } }, n2 = this.createColorList(s2);
    return this.menuColorFill = this.createWrapCollapsible(n2, "Fill"), this.menuColorFill.id = `${this.id}-fill`, this.menuColorFill;
  }
  createMenuThickness() {
    const i2 = document.createElement("div");
    i2.id = `${this.id}-thickness-list`, i2.classList.add("ms-menu-row", "thickness-list");
    const r2 = this.symbolsSelected.map((i3) => i3.style), s2 = r2.length && r2.every((i3) => i3.width === r2[0].width) ? r2[0].width : this.editor.penStyle.width;
    return this.thicknessList.forEach((r3) => {
      const n2 = document.createElement("button");
      n2.id = `${this.id}-thickness-${r3.label}-btn`, n2.classList.add("ms-menu-button", "square"), n2.textContent = r3.label, s2 === r3.value && n2.classList.add("active"), n2.addEventListener("pointerup", (s3) => {
        s3.preventDefault(), s3.stopPropagation(), this.editor.penStyle = { width: r3.value }, i2.querySelectorAll("*").forEach((i3) => i3.classList.remove("active")), n2.classList.add("active"), this.symbolsSelected.length && (this.editor.updateSymbolsStyle(this.symbolsSelected.map((i3) => i3.id), { width: r3.value }), this.editor.selector.resetSelectedGroup(this.symbolsSelected));
      }), i2.appendChild(n2);
    }), this.menuThickness = this.createWrapCollapsible(i2, "Thickness"), this.menuThickness.id = `${this.id}-thickness`, this.menuThickness;
  }
  createMenuFontSize() {
    const i2 = document.createElement("div");
    return i2.id = `${this.id}-font-size-list`, i2.classList.add("ms-menu-row", "font-size-list"), this.fontSizeList.forEach((r2) => {
      const s2 = document.createElement("button");
      s2.id = `${this.id}-font-size-${r2.label}-btn`, s2.classList.add("ms-menu-button", "square"), s2.textContent = r2.label, this.editor.configuration.fontStyle.size === r2.value && s2.classList.add("active"), s2.addEventListener("pointerup", (n2) => {
        if (n2.preventDefault(), n2.stopPropagation(), i2.querySelectorAll("*").forEach((i3) => i3.classList.remove("active")), s2.classList.add("active"), "auto" === r2.value) this.editor.configuration.fontStyle.size = "auto";
        else {
          const i3 = r2.value;
          this.editor.configuration.fontStyle.size = i3;
          const s3 = this.symbolsSelected.filter((i4) => i4.type === E.Text || i4.type === E.Group && i4.extractText().length);
          this.editor.updateTextFontStyle(s3.map((i4) => i4.id), { fontSize: i3 * this.rowHeight }), this.editor.selector.resetSelectedGroup(this.symbolsSelected);
        }
      }), i2.appendChild(s2);
    }), this.menuFontSize = this.createWrapCollapsible(i2, "Font size"), this.menuFontSize.id = `${this.id}-font-size`, this.menuFontSize;
  }
  createMenuFontWeight() {
    const i2 = document.createElement("div");
    return i2.id = `${this.id}-font-weight-list`, i2.classList.add("ms-menu-row", "font-weight-list"), this.fontWeightList.forEach((r2) => {
      const s2 = document.createElement("button");
      s2.id = `${this.id}-font-weight-${r2.label}-btn`, s2.classList.add("ms-menu-button", "center"), s2.textContent = r2.label, this.editor.configuration.fontStyle.weight === r2.value && s2.classList.add("active"), s2.addEventListener("pointerup", (n2) => {
        if (n2.preventDefault(), n2.stopPropagation(), i2.querySelectorAll("*").forEach((i3) => i3.classList.remove("active")), s2.classList.add("active"), this.editor.configuration.fontStyle.weight = r2.value, "auto" !== this.editor.configuration.fontStyle.weight) {
          const i3 = this.symbolsSelected.filter((i4) => i4.type === E.Text || i4.type === E.Group && i4.extractText().length);
          this.editor.updateTextFontStyle(i3.map((i4) => i4.id), { fontWeight: this.editor.configuration.fontStyle.weight }), this.editor.selector.resetSelectedGroup(this.symbolsSelected);
        }
      }), i2.appendChild(s2);
    }), this.menuFontWeight = this.createWrapCollapsible(i2, "Font weight"), this.menuFontWeight.id = `${this.id}-font-weight`, this.menuFontWeight;
  }
  createMenuOpacity() {
    var _a, _b2;
    const i2 = this.symbolsSelected.map((i3) => i3.style), r2 = 100 * (i2.length && i2.every((r3) => {
      var _a2;
      return r3.opacity === ((_a2 = i2[0]) == null ? void 0 : _a2.opacity);
    }) && ((_a = i2[0]) == null ? void 0 : _a.opacity) ? (_b2 = i2[0]) == null ? void 0 : _b2.opacity : this.editor.penStyle.opacity || 1), s2 = document.createElement("div");
    s2.id = `${this.id}-opacity-input-wrapper`;
    const n2 = document.createElement("input");
    n2.id = `${this.id}-opacity-input`, n2.setAttribute("name", "opacity"), n2.setAttribute("type", "range"), n2.setAttribute("step", "1"), n2.setAttribute("min", "1"), n2.setAttribute("max", "100"), s2.appendChild(n2);
    const a2 = document.createElement("output");
    return a2.setAttribute("for", "opacity"), a2.innerHTML = r2 ? `${r2}` : "-", s2.appendChild(a2), r2 && n2.setAttribute("value", r2.toString()), n2.addEventListener("input", (i3) => {
      const r3 = i3.target.value;
      a2.innerHTML = `${r3}%`, this.editor.penStyle = { opacity: r3 / 100 }, this.symbolsSelected.length && this.editor.updateSymbolsStyle(this.symbolsSelected.map((i4) => i4.id), { opacity: r3 / 100 });
    }), this.menuStrokeOpacity = this.createWrapCollapsible(s2, "Opacity"), this.menuStrokeOpacity.id = `${this.id}-opacity`, this.menuStrokeOpacity;
  }
  render(i2) {
    if (this.editor.configuration.menu.style.enable) {
      this.triggerBtn = document.createElement("button"), this.triggerBtn.id = this.id, this.triggerBtn.classList.add("ms-menu-button", "square"), this.triggerBtn.innerHTML = '<svg\n  width="24px"\n  height="24px"\n  stroke-width="1"\n  viewBox="0 0 24 24"\n  fill="none"\n  xmlns="http://www.w3.org/2000/svg"\n  color="currentColor"\n>\n  <path\n    d="M20.5096 9.54C20.4243 9.77932 20.2918 9.99909 20.12 10.1863C19.9483 10.3735 19.7407 10.5244 19.5096 10.63C18.2796 11.1806 17.2346 12.0745 16.5002 13.2045C15.7659 14.3345 15.3733 15.6524 15.3696 17C15.3711 17.4701 15.418 17.9389 15.5096 18.4C15.5707 18.6818 15.5747 18.973 15.5215 19.2564C15.4682 19.5397 15.3588 19.8096 15.1996 20.05C15.0649 20.2604 14.8877 20.4403 14.6793 20.5781C14.4709 20.7158 14.2359 20.8085 13.9896 20.85C13.4554 20.9504 12.9131 21.0006 12.3696 21C11.1638 21.0006 9.97011 20.7588 8.85952 20.2891C7.74893 19.8194 6.74405 19.1314 5.90455 18.2657C5.06506 17.4001 4.40807 16.3747 3.97261 15.2502C3.53714 14.1257 3.33208 12.9252 3.36959 11.72C3.4472 9.47279 4.3586 7.33495 5.92622 5.72296C7.49385 4.11097 9.60542 3.14028 11.8496 3H12.3596C14.0353 3.00042 15.6777 3.46869 17.1017 4.35207C18.5257 5.23544 19.6748 6.49885 20.4196 8C20.6488 8.47498 20.6812 9.02129 20.5096 9.52V9.54Z"\n    stroke="currentColor"\n    stroke-width="1"\n  ></path>\n  <path d="M8 16.01L8.01 15.9989" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M6 12.01L6.01 11.9989" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M8 8.01L8.01 7.99889" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M12 6.01L12.01 5.99889" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n  <path d="M16 8.01L16.01 7.99889" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>\n</svg>\n';
      const r2 = document.createElement("div");
      r2.classList.add("ms-menu-colmun"), r2.appendChild(this.createMenuStroke()), r2.appendChild(this.createMenuColorFill()), r2.appendChild(this.createMenuThickness()), r2.appendChild(this.createMenuFontSize()), r2.appendChild(this.createMenuFontWeight()), r2.appendChild(this.createMenuOpacity());
      const s2 = { trigger: this.triggerBtn, subMenu: r2, position: "bottom-left" };
      this.subMenu = new IIMenuSub(s2), this.wrapper = document.createElement("div"), this.wrapper.classList.add("ms-menu", "ms-menu-top-right"), this.wrapper.appendChild(this.subMenu.element), i2.appendChild(this.wrapper), this.update();
    }
  }
  update() {
    if (this.subMenu && (this.isMobile ? this.subMenu.wrap() : this.subMenu.unwrap()), this.editor.tool === i.Write) this.show(), this.menuColorStroke && (this.menuColorStroke.style.display = "block"), this.menuColorFill && (this.menuColorFill.style.display = this.writeShape ? "block" : "none"), this.menuThickness && (this.menuThickness.style.display = "block"), this.menuFontSize && (this.menuFontSize.style.display = "block"), this.menuFontWeight && (this.menuFontWeight.style.display = "block"), this.menuStrokeOpacity && (this.menuStrokeOpacity.style.display = "block");
    else if (this.editor.tool === i.Select) {
      if (this.show(), this.menuColorStroke && (this.menuColorStroke.style.display = "block"), this.menuColorFill) {
        const i2 = this.model.symbolsSelected.length && this.model.symbolsSelected.some((i3) => i3.type === E.Shape);
        this.menuColorFill.style.display = i2 ? "block" : "none";
      }
      this.menuThickness && (this.menuThickness.style.display = "block"), this.menuFontSize && (this.menuFontSize.style.display = "block"), this.menuFontWeight && (this.menuFontWeight.style.display = "block"), this.menuStrokeOpacity && (this.menuStrokeOpacity.style.display = "block");
    } else this.hide();
  }
  show() {
    this.wrapper && (this.wrapper.style.visibility = "visible");
  }
  hide() {
    this.wrapper && (this.wrapper.style.visibility = "hidden");
  }
  destroy() {
    if (this.wrapper) {
      for (; this.wrapper.lastChild; ) this.wrapper.removeChild(this.wrapper.lastChild);
      this.wrapper.remove(), this.wrapper = void 0, this.subMenu = void 0, this.triggerBtn = void 0, this.menuColorStroke = void 0, this.menuColorFill = void 0, this.menuThickness = void 0, this.menuFontSize = void 0, this.menuFontWeight = void 0, this.menuStrokeOpacity = void 0;
    }
  }
};
_t30 = new WeakMap();
var _t31;
var IIMenuContext = class extends IIMenu {
  constructor(i2, r2 = "ms-menu-context") {
    super();
    __privateAdd(this, _t31, LoggerManager.getLogger(d.MENU));
    __publicField(this, "editor");
    __publicField(this, "id");
    __publicField(this, "wrapper");
    __publicField(this, "editMenu");
    __publicField(this, "editInput");
    __publicField(this, "editSaveBtn");
    __publicField(this, "reorderMenu");
    __publicField(this, "decoratorMenu");
    __publicField(this, "menuExport");
    __publicField(this, "duplicateBtn");
    __publicField(this, "groupBtn");
    __publicField(this, "convertBtn");
    __publicField(this, "removeBtn");
    __publicField(this, "position");
    this.id = r2, __privateGet(this, _t31).info("constructor"), this.editor = i2, this.position = { x: 0, y: 0, scrollLeft: 0, scrollTop: 0 };
  }
  get symbolsSelected() {
    return this.editor.model.symbolsSelected;
  }
  get haveSymbolsSelected() {
    return this.symbolsSelected.length > 0;
  }
  get symbolsDecorable() {
    return this.symbolsSelected.filter((i2) => [E.Stroke, E.Text, E.Group].includes(i2.type) || i2.type === E.Recognized && i2.kind === T.Text);
  }
  get showDecorator() {
    return this.symbolsDecorable.length > 0;
  }
  createMenuEdit() {
    const i2 = document.createElement("button");
    i2.id = `${this.id}-edit-trigger`, i2.classList.add("ms-menu-button");
    const r2 = document.createElement("span");
    r2.innerText = "Edit", i2.appendChild(r2);
    const s2 = document.createElement("span");
    s2.style.setProperty("width", "32px"), s2.style.setProperty("transform", "rotate(270deg)"), s2.innerHTML = we, i2.appendChild(s2);
    const n2 = document.createElement("div");
    n2.classList.add("ms-menu-colmun"), this.editInput = document.createElement("input"), n2.appendChild(this.editInput), this.editSaveBtn = document.createElement("button"), this.editSaveBtn.classList.add("ms-menu-button"), this.editSaveBtn.innerText = "Save", n2.appendChild(this.editSaveBtn), this.editSaveBtn.addEventListener("pointerdown", async (i3) => {
      i3.stopPropagation();
      const r3 = this.editor.model.symbolsSelected.find((i4) => i4.type === E.Text);
      if (r3) {
        const i4 = r3.chars[0];
        r3.chars = [];
        for (let s3 = 0; s3 < this.editInput.value.length; s3++) r3.chars.push({ label: this.editInput.value.charAt(s3), id: createUUID(), color: i4.color, fontSize: i4.fontSize, fontWeight: i4.fontWeight, bounds: i4.bounds });
        await this.editor.updateSymbol(r3), this.editor.selector.resetSelectedGroup([r3]);
      }
    });
    const a2 = { trigger: i2, subMenu: n2, position: "right" };
    return this.editMenu = new IIMenuSub(a2).element, this.editMenu;
  }
  createMenuDuplicate() {
    return this.duplicateBtn = document.createElement("button"), this.duplicateBtn.id = `${this.id}-duplicate`, this.duplicateBtn.textContent = "Duplicate", this.duplicateBtn.classList.add("ms-menu-button"), this.duplicateBtn.addEventListener("pointerup", async () => {
      const i2 = this.symbolsSelected, updateDeepIdInGroup = (i3) => {
        i3.children.forEach((i4) => {
          switch (i4.id = i4.id.slice(0, -36) + `-${createUUID()}`, i4.type) {
            case E.Group:
              updateDeepIdInGroup(i4);
              break;
            case E.Recognized:
              i4.strokes.forEach((i5) => i5.id = i5.id.slice(0, -36) + `-${createUUID()}`);
          }
        });
      }, r2 = i2.map((i3) => {
        const r3 = i3.clone();
        for (; this.editor.model.symbols.find((i4) => i4.id === r3.id); ) r3.id = r3.id.slice(0, -36) + `-${createUUID()}`, r3.type === E.Group ? updateDeepIdInGroup(r3) : r3.type === E.Recognized && r3.strokes.forEach((i4) => i4.id = i4.id.slice(0, -36) + `-${createUUID()}`);
        return r3.selected = true, this.editor.translator.applyToSymbol(r3, a, a), r3;
      });
      this.editor.unselectAll(), await this.editor.addSymbols(r2), this.editor.selector.drawSelectedGroup(r2);
    }), this.duplicateBtn;
  }
  createMenuGroup() {
    return this.groupBtn = document.createElement("button"), this.groupBtn.id = `${this.id}-duplicate`, this.groupBtn.textContent = "Group", this.groupBtn.classList.add("ms-menu-button"), this.groupBtn.addEventListener("pointerup", async () => {
      if (1 === this.symbolsSelected.length && this.symbolsSelected[0].type === E.Group) {
        const i2 = this.editor.ungroupSymbol(this.symbolsSelected[0]);
        this.editor.select(i2.map((i3) => i3.id));
      } else {
        const i2 = this.symbolsSelected.slice();
        this.editor.unselectAll();
        const r2 = this.editor.groupSymbols(i2);
        r2.selected = true, this.editor.select([r2.id]);
      }
    }), this.groupBtn;
  }
  createMenuConvert() {
    return this.convertBtn = document.createElement("button"), this.convertBtn.id = `${this.id}-convert`, this.convertBtn.textContent = "Convert", this.convertBtn.classList.add("ms-menu-button"), this.convertBtn.addEventListener("pointerup", () => this.editor.convertSymbols(this.symbolsSelected)), this.convertBtn;
  }
  createMenuRemove() {
    return this.removeBtn = document.createElement("button"), this.removeBtn.id = `${this.id}-remove`, this.removeBtn.textContent = "Remove", this.removeBtn.classList.add("ms-menu-button"), this.removeBtn.addEventListener("pointerup", async () => {
      this.editor.selector.removeSelectedGroup(), await this.editor.removeSymbols(this.symbolsSelected.map((i2) => i2.id));
    }), this.removeBtn;
  }
  createMenuReorder() {
    const i2 = document.createElement("button");
    i2.id = `${this.id}-reorder`, i2.classList.add("ms-menu-button");
    const r2 = document.createElement("span");
    r2.innerText = "Reorder", i2.appendChild(r2);
    const s2 = document.createElement("span");
    s2.style.setProperty("width", "32px"), s2.style.setProperty("transform", "rotate(270deg)"), s2.innerHTML = we, i2.appendChild(s2);
    const n2 = [{ type: "button", id: `${this.id}-reorder-first`, label: "Bring to front", callback: () => {
      this.editor.changeOrderSymbols(this.symbolsSelected, "last"), this.editor.selector.resetSelectedGroup(this.symbolsSelected);
    } }, { type: "button", id: `${this.id}-reorder-forward`, label: "Bring forward", callback: () => {
      this.editor.changeOrderSymbols(this.symbolsSelected, "forward"), this.editor.selector.resetSelectedGroup(this.symbolsSelected);
    } }, { type: "button", id: `${this.id}-reorder-backward`, label: "Send backward", callback: () => {
      this.editor.changeOrderSymbols(this.symbolsSelected, "backward"), this.editor.selector.resetSelectedGroup(this.symbolsSelected);
    } }, { type: "button", id: `${this.id}-reorder-last`, label: "Send to back", callback: () => {
      this.editor.changeOrderSymbols(this.symbolsSelected.slice().reverse(), "first"), this.editor.selector.resetSelectedGroup(this.symbolsSelected);
    } }], a2 = document.createElement("div");
    a2.classList.add("ms-menu-colmun"), n2.forEach((i3) => {
      a2.appendChild(this.createMenuItem(i3));
    });
    const l2 = { trigger: i2, subMenu: a2, position: "right" };
    return this.reorderMenu = new IIMenuSub(l2).element, this.reorderMenu;
  }
  createDecoratorSubMenu(i2, r2) {
    const s2 = document.createElement("button");
    s2.id = `${this.id}-decorator-${r2}`, s2.classList.add("ms-menu-button");
    const n2 = document.createElement("span");
    n2.innerText = i2, s2.appendChild(n2);
    const a2 = document.createElement("span");
    a2.style.setProperty("width", "32px"), a2.style.setProperty("transform", "rotate(270deg)"), a2.innerHTML = we, s2.appendChild(a2);
    const l2 = [{ type: "checkbox", id: `${this.id}-decorator-${r2}-enable`, label: "Enable", initValue: false, callback: (i3) => {
      var _a;
      this.symbolsDecorable.forEach((s3) => {
        if (i3) s3.decorators.some((i4) => i4.kind === r2) || s3.decorators.push(new IIDecorator(r2, this.editor.penStyle));
        else {
          const i4 = s3.decorators.findIndex((i5) => i5.kind === r2);
          i4 > -1 && s3.decorators.splice(i4, 1);
        }
        this.editor.model.updateSymbol(s3), this.editor.renderer.drawSymbol(s3);
      }), document.querySelectorAll(`#${this.id}-decorator-${r2}-color button`).forEach((r3) => {
        r3.disabled = !i3, r3.classList.remove("active");
      }), i3 && ((_a = document.querySelector(`#${this.id}-decorator-${r2}-color button`)) == null ? void 0 : _a.classList.add("active"));
    } }, { type: "colors", label: "Colors", id: `${this.id}-decorator-${r2}-color`, fill: false, values: this.colors.filter((i3, r3) => !(r3 % 4)), initValue: this.colors[0], disabled: true, callback: (i3) => {
      this.symbolsDecorable.forEach((s3) => {
        const n3 = s3.decorators.find((i4) => i4.kind === r2);
        n3 && (n3.style.color = i3, this.editor.model.updateSymbol(s3), this.editor.renderer.drawSymbol(s3));
      });
    } }], d2 = document.createElement("div");
    d2.classList.add("ms-menu-colmun"), l2.forEach((i3) => {
      d2.appendChild(this.createMenuItem(i3));
    });
    const h2 = { trigger: s2, subMenu: d2, position: "right" };
    return this.decoratorMenu = new IIMenuSub(h2).element;
  }
  createMenuDecorator() {
    const i2 = document.createElement("button");
    i2.id = `${this.id}-decorator`, i2.classList.add("ms-menu-button");
    const r2 = document.createElement("span");
    r2.innerText = "Decorator", i2.appendChild(r2);
    const s2 = document.createElement("span");
    s2.style.setProperty("width", "32px"), s2.style.setProperty("transform", "rotate(270deg)"), s2.innerHTML = we, i2.appendChild(s2);
    const n2 = document.createElement("div");
    n2.classList.add("ms-menu-colmun"), n2.appendChild(this.createDecoratorSubMenu("Hightlight", k.Highlight)), n2.appendChild(this.createDecoratorSubMenu("Surround", k.Surround)), n2.appendChild(this.createDecoratorSubMenu("Underline", k.Underline)), n2.appendChild(this.createDecoratorSubMenu("Strikethrough", k.Strikethrough));
    const a2 = { trigger: i2, subMenu: n2, position: "right" };
    return this.decoratorMenu = new IIMenuSub(a2).element, this.decoratorMenu;
  }
  createMenuExport() {
    const i2 = document.createElement("button");
    i2.id = `${this.id}-export`, i2.classList.add("ms-menu-button");
    const r2 = document.createElement("span");
    r2.innerText = "Export", i2.appendChild(r2);
    const s2 = document.createElement("span");
    s2.style.setProperty("width", "32px"), s2.style.setProperty("transform", "rotate(270deg)"), s2.innerHTML = we, i2.appendChild(s2);
    const n2 = [{ type: "button", id: `${this.id}-export-json`, label: "json", callback: () => this.editor.downloadAsJson(this.haveSymbolsSelected) }, { type: "button", id: `${this.id}-export-svg`, label: "svg", callback: () => this.editor.downloadAsSVG(this.haveSymbolsSelected) }, { type: "button", id: `${this.id}-export-png`, label: "png", callback: () => this.editor.downloadAsPNG(this.haveSymbolsSelected) }], a2 = document.createElement("div");
    a2.classList.add("ms-menu-colmun"), n2.forEach((i3) => {
      a2.appendChild(this.createMenuItem(i3));
    });
    const l2 = { trigger: i2, subMenu: a2, position: "right" };
    return this.menuExport = new IIMenuSub(l2).element, this.menuExport;
  }
  createMenuSelectAll() {
    const i2 = document.createElement("button");
    return i2.id = `${this.id}-duplicate`, i2.textContent = "Select all", i2.classList.add("ms-menu-button"), i2.addEventListener("pointerup", async () => this.editor.selectAll()), i2;
  }
  updateDecoratorSubMenu() {
    var _a, _b2;
    this.showDecorator ? ((_a = this.decoratorMenu) == null ? void 0 : _a.style.removeProperty("display"), Object.values(k).forEach((i2) => {
      var _a2;
      const r2 = document.getElementById(`${this.id}-decorator-${i2}-enable`);
      if (r2) {
        document.querySelectorAll(`#${this.id}-decorator-${i2}-color button`).forEach((i3) => i3.classList.remove("active"));
        const s2 = this.symbolsDecorable.flatMap((i3) => i3.decorators).filter((r3) => r3.kind === i2);
        if (s2.length && s2.every((i3) => i3.style.color === s2[0].style.color)) {
          const r3 = document.getElementById(`${this.id}-decorator-${i2}-color-${(_a2 = s2[0].style.color) == null ? void 0 : _a2.replace("#", "")}-btn`);
          r3 == null ? void 0 : r3.classList.add("active");
        }
        this.symbolsDecorable.filter((r3) => r3.decorators.some((r4) => r4.kind === i2)).length === this.symbolsDecorable.length ? (r2.checked = true, document.querySelectorAll(`#${this.id}-decorator-${i2}-color button`).forEach((i3) => {
          i3.disabled = false;
        }), r2.indeterminate = false) : this.symbolsDecorable.filter((r3) => !r3.decorators.some((r4) => r4.kind === i2)).length === this.symbolsDecorable.length ? (r2.checked = false, document.querySelectorAll(`#${this.id}-decorator-${i2}-color button`).forEach((i3) => {
          i3.disabled = true;
        }), r2.indeterminate = false) : (r2.setAttribute("indeterminate", "true"), r2.indeterminate = true, document.querySelectorAll(`#${this.id}-decorator-${i2}-color button`).forEach((i3) => {
          i3.disabled = false;
        }));
      }
    })) : (_b2 = this.decoratorMenu) == null ? void 0 : _b2.style.setProperty("display", "none");
  }
  updateGroupMenu() {
    var _a;
    this.groupBtn && this.haveSymbolsSelected ? (this.groupBtn.style.removeProperty("display"), 1 === this.symbolsSelected.length && this.symbolsSelected[0].type === E.Group ? this.groupBtn.textContent = "UnGroup" : this.groupBtn.textContent = "Group") : (_a = this.groupBtn) == null ? void 0 : _a.style.setProperty("display", "none");
  }
  update() {
    var _a, _b2, _c2, _d6, _e2, _f2, _g2, _h2, _i2, _j, _k2, _l2, _m5, _n2, _o2;
    if ((_a = this.wrapper) == null ? void 0 : _a.style.setProperty("left", this.position.x - this.position.scrollLeft + "px"), (_b2 = this.wrapper) == null ? void 0 : _b2.style.setProperty("top", this.position.y - this.position.scrollTop + "px"), this.haveSymbolsSelected) {
      const i2 = this.editor.model.symbolsSelected.find((i3) => i3.type === E.Text);
      this.editMenu && this.editInput && 1 === this.editor.model.symbolsSelected.length && i2 ? (this.editMenu.style.removeProperty("display"), this.editInput.value = i2.label) : (_c2 = this.editMenu) == null ? void 0 : _c2.style.setProperty("display", "none"), this.editor.extractStrokesFromSymbols(this.symbolsSelected).length ? (_d6 = this.convertBtn) == null ? void 0 : _d6.style.removeProperty("display") : (_e2 = this.convertBtn) == null ? void 0 : _e2.style.setProperty("display", "none"), (_f2 = this.reorderMenu) == null ? void 0 : _f2.style.removeProperty("display"), (_g2 = this.duplicateBtn) == null ? void 0 : _g2.style.removeProperty("display"), (_h2 = this.removeBtn) == null ? void 0 : _h2.style.removeProperty("display"), (_i2 = this.menuExport) == null ? void 0 : _i2.style.removeProperty("display");
    } else (_j = this.editMenu) == null ? void 0 : _j.style.setProperty("display", "none"), (_k2 = this.convertBtn) == null ? void 0 : _k2.style.setProperty("display", "none"), (_l2 = this.reorderMenu) == null ? void 0 : _l2.style.setProperty("display", "none"), (_m5 = this.duplicateBtn) == null ? void 0 : _m5.style.setProperty("display", "none"), (_n2 = this.removeBtn) == null ? void 0 : _n2.style.setProperty("display", "none"), (_o2 = this.menuExport) == null ? void 0 : _o2.style.setProperty("display", "none");
    this.updateDecoratorSubMenu(), this.updateGroupMenu();
  }
  render(i2) {
    this.wrapper = document.createElement("div"), this.wrapper.id = `${this.id}-wrapper`, this.wrapper.classList.add("ms-menu", "ms-menu-context"), this.wrapper.appendChild(this.createMenuEdit()), this.wrapper.appendChild(this.createMenuDecorator()), this.wrapper.appendChild(this.createMenuReorder()), this.wrapper.appendChild(this.createMenuExport()), this.wrapper.appendChild(this.createMenuConvert()), this.wrapper.appendChild(this.createMenuGroup()), this.wrapper.appendChild(this.createMenuDuplicate()), this.wrapper.appendChild(this.createMenuRemove()), this.wrapper.appendChild(this.createMenuSelectAll()), this.wrapper.style.setProperty("display", "none"), i2.appendChild(this.wrapper), this.editor.layers.rendering.addEventListener("scroll", () => {
      this.position.scrollLeft = this.editor.layers.rendering.scrollLeft || 0, this.position.scrollTop = this.editor.layers.rendering.scrollTop || 0, this.update();
    });
  }
  show() {
    var _a;
    this.update(), (_a = this.wrapper) == null ? void 0 : _a.style.setProperty("display", "block");
  }
  hide() {
    var _a;
    (_a = this.wrapper) == null ? void 0 : _a.style.setProperty("display", "none");
  }
  destroy() {
    var _a, _b2;
    for (; (_a = this.wrapper) == null ? void 0 : _a.lastChild; ) this.wrapper.removeChild(this.wrapper.lastChild);
    (_b2 = this.wrapper) == null ? void 0 : _b2.remove();
  }
};
_t31 = new WeakMap();
var Te = { enable: true, style: { enable: true }, tool: { enable: true }, action: { enable: true }, context: { enable: true } };
var _t32;
var IIMenuManager = class {
  constructor(i2, r2) {
    __privateAdd(this, _t32, LoggerManager.getLogger(d.MENU));
    __publicField(this, "editor");
    __publicField(this, "layer");
    __publicField(this, "action");
    __publicField(this, "tool");
    __publicField(this, "context");
    __publicField(this, "style");
    if (__privateGet(this, _t32).info("constructor"), this.editor = i2, r2 == null ? void 0 : r2.style) {
      const i3 = r2.style;
      this.style = new i3(this.editor);
    } else this.style = new IIMenuStyle(this.editor);
    if (r2 == null ? void 0 : r2.tool) {
      const i3 = r2.tool;
      this.tool = new i3(this.editor);
    } else this.tool = new IIMenuTool(this.editor);
    if (r2 == null ? void 0 : r2.action) {
      const i3 = r2.action;
      this.action = new i3(this.editor);
    } else this.action = new IIMenuAction(this.editor);
    if (r2 == null ? void 0 : r2.context) {
      const i3 = r2.context;
      this.context = new i3(this.editor);
    } else this.context = new IIMenuContext(this.editor);
  }
  render(i2) {
    if (this.editor.configuration.menu.enable) {
      this.layer = i2;
      const r2 = document.createElement("style");
      r2.appendChild(document.createTextNode(".ms-editor .ms-menu{background-color:#fff;box-shadow:1px 1px 5px rgba(0,0,0,.25),-1px -1px 5px rgba(0,0,0,.25);cursor:auto;padding:5px;pointer-events:all;z-index:99}.ms-editor .ms-menu-top-left{border-radius:0 0 5px 5px;left:5px;position:absolute;top:0}.ms-editor .ms-menu-bottom{border-radius:5px;bottom:8px;left:50%;position:absolute;transform:translateX(-50%)}.ms-editor .ms-menu-top-right{border-radius:0 0 5px 5px;position:absolute;right:5px;top:0}.ms-editor .ms-menu .ms-menu-title{background-color:#b3dfff;border-radius:5px 5px 0 0;font-size:16px;font-weight:700;margin-bottom:8px;margin-top:0;padding:2px;text-align:center}.ms-editor .ms-menu-colmun{display:flex;flex-direction:column;justify-content:center}.ms-editor .ms-menu-row{display:flex;flex-direction:row;justify-content:center}.ms-editor .ms-menu-item{align-items:center;display:flex;gap:5px;justify-content:space-between;padding:5px;width:100%}.ms-editor .ms-menu .select-language{height:32px;padding:0 8px;width:auto}.ms-editor .ms-menu-item.list button{align-items:center;background-color:#fff;border:none;border-radius:4px;cursor:pointer;display:flex;font-size:inherit;height:32px;justify-content:center;padding:0;position:relative;width:32px}.ms-editor .ms-menu-item.list button:hover{background-color:#efefef}.ms-editor .ms-menu-item.list button.active{border:1px solid #1a9fff}.ms-editor .ms-menu .color-list{cursor:pointer;flex-wrap:wrap;gap:2px;margin:auto;max-width:150px;min-width:150px;padding:4px}.ms-editor .ms-menu .font-size-list,.ms-editor .ms-menu .thickness-list{cursor:pointer;flex-wrap:wrap;gap:2px;margin:auto;max-width:150px;min-width:150px;padding:0}.ms-editor .ms-menu .ms-menu-button{-webkit-touch-callout:none;align-items:center;background-color:#fff;border:none;border-radius:4px;color:#000;cursor:pointer;display:flex;font-size:inherit;height:32px;justify-content:space-between;padding:4px;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:100%}.ms-editor .ms-menu svg{height:20px;position:relative;width:20px}.ms-editor .ms-menu .ms-menu-button.center{justify-content:center}.ms-editor .ms-menu .ms-menu-button.square{justify-content:center;width:32px}.ms-editor .ms-menu .ms-menu-button .color{border-radius:100%;height:75%;margin:auto;width:75%}.ms-editor .ms-menu .ms-menu-button:hover{background-color:#efefef}.ms-editor .ms-menu .ms-menu-button:disabled{background-color:hsla(0,0%,100%,.4);color:rgba(0,0,0,.4);opacity:.5;pointer-events:none}.ms-editor .ms-menu .ms-menu-button:active,.ms-editor .ms-menu .ms-menu-button:focus{background-color:#1aa0ff55;outline:none}.ms-editor .ms-menu .ms-menu-button.active{border:1px solid #1a9fff;color:#1a9fff}.ms-editor .sub-menu{overflow:visible;position:relative}.ms-editor .sub-menu .sub-menu-content{background-color:#fff;border-radius:5px;box-shadow:1px 1px 5px rgba(0,0,0,.25),-1px -1px 5px rgba(0,0,0,.25);color:#000;display:none;padding:5px;position:absolute;white-space:nowrap;width:auto;z-index:100}.ms-editor .sub-menu .sub-menu-content.open{display:block}.ms-editor .sub-menu .sub-menu-content.top{left:50%;top:-8px;transform:translate(-50%,-100%)}.ms-editor .sub-menu .sub-menu-content.bottom{bottom:-8px;left:50%;transform:translate(-50%,100%)}.ms-editor .sub-menu .sub-menu-content.bottom-left{bottom:-8px;right:0;transform:translateY(100%)}.ms-editor .sub-menu .sub-menu-content.right-top{right:-8px;top:0;transform:translate(100%)}.ms-editor .sub-menu .sub-menu-content.right{right:-8px;top:50%;transform:translate(100%,-50%)}.ms-editor .ms-menu-context{position:absolute}.ms-editor .ms-menu output{background-color:#fff;border-radius:5px;box-shadow:0 2px 5px 0 rgba(0,0,0,.225);color:#000;display:none;font-weight:700;left:50%;padding:5px;position:absolute;transform:translate(-50%,-250%);white-space:nowrap;width:auto}.ms-editor .ms-menu input:focus+output,.ms-editor .ms-menu input:focus-visible+output,.ms-editor .ms-menu input:hover+output{display:block}.ms-editor .ms-menu input:not([type=checkbox]):not([type=color]):not([type=range]),.ms-editor .ms-menu select{-webkit-tap-highlight-color:transparent;-webkit-appearance:none;appearance:none;border:1px solid #ced5d9;border-radius:3px;color:#131f26;font:600 14px Source Sans Pro,sans-serif;height:2rem;padding:0 10px}.ms-editor .ms-menu input[type=file]{border:none!important}.ms-editor .ms-menu input[type=file]:focus{border:none!important;box-shadow:none!important}.ms-editor .ms-menu input[type=file]:focus::file-selector-button{border:1px solid #1a9fff!important}.ms-editor .ms-menu input[type=file]::file-selector-button{background-color:#fff;border:1px solid rgba(0,0,0,.16);border-radius:4px;box-shadow:0 1px 0 rgba(0,0,0,.05);cursor:pointer;height:2rem;margin:0 auto 0 8px;padding:0 16px;transition:background-color .2s}.ms-editor .ms-menu input[type=file]::file-selector-button:hover{background-color:#f3f4f6}.ms-editor .ms-menu input[type=file]::file-selector-button:active{background-color:#e5e7eb}.ms-editor .ms-menu select{background:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQuNDIyLjI2Yy0uMjMzLS4zMzctLjYxLS4zMzctLjg0NCAwTC4xNzUgNS4xN0MtLjE0MiA1LjYyOC4wNDggNiAuNjEgNmg2Ljc4Yy41NTggMCAuNzU0LS4zNy40MzUtLjgzTDQuNDIyLjI2em0uMDIgMTMuNDdjLS4yMzYuMzQyLS42MTguMzQ3LS44NS4wMUwuMTY3IDguODE4Qy0uMTQ2IDguMzY3LjA0OCA4IC42MDggOGg2Ljc4M2MuNTU4IDAgLjc1NS4zNy40MzcuODNsLTMuMzg1IDQuOXoiIGZpbGw9IiMxMzFGMjYiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==) 100% no-repeat #fff;padding:0 25px 0 10px}.ms-editor .ms-menu input:not([type=checkbox]):not([type=color]):not([type=range]):not([type=file]):focus,.ms-editor .ms-menu select:focus{border:1px solid #1a9fff;box-shadow:0 1px 1px 0 rgba(0,0,0,.16);outline:0}")), this.layer.prepend(r2), this.editor.configuration.menu.action.enable && this.action.render(this.layer), this.editor.configuration.menu.style.enable && this.style.render(this.layer), this.editor.configuration.menu.tool.enable && this.tool.render(this.layer), this.editor.configuration.menu.context.enable && this.context.render(this.layer);
    }
  }
  update() {
    this.action.update(), this.tool.update(), this.style.update();
  }
  show() {
    this.action.show(), this.tool.show(), this.style.show();
  }
  hide() {
    this.action.hide(), this.tool.hide(), this.style.hide();
  }
  destroy() {
    this.action.destroy(), this.tool.destroy(), this.style.destroy();
  }
};
_t32 = new WeakMap();
var Le = { guide: true, symbol: true, angle: 0 };
var SnapConfiguration = class {
  constructor(i2) {
    __publicField(this, "guide");
    __publicField(this, "symbol");
    __publicField(this, "angle");
    this.symbol = void 0 !== (i2 == null ? void 0 : i2.symbol) ? i2.symbol : Le.symbol, this.guide = void 0 !== (i2 == null ? void 0 : i2.guide) ? i2.guide : Le.guide, this.angle = void 0 !== (i2 == null ? void 0 : i2.angle) ? i2.angle : Le.angle;
  }
};
var _t33;
var IISnapManager = class {
  constructor(i2, r2) {
    __privateAdd(this, _t33, LoggerManager.getLogger(d.CONVERTER));
    __publicField(this, "editor");
    __publicField(this, "configuration");
    __privateGet(this, _t33).info("constructor"), this.editor = i2, this.configuration = new SnapConfiguration(r2);
  }
  get model() {
    return this.editor.model;
  }
  get renderer() {
    return this.editor.renderer;
  }
  get selectionSnapPoints() {
    return Box.createFromPoints(this.model.symbolsSelected.flatMap((i2) => i2.snapPoints)).snapPoints;
  }
  get otherSnapPoints() {
    const i2 = this.model.symbolsSelected.map((i3) => i3.id);
    return this.model.symbols.filter((r2) => !i2.includes(r2.id)).flatMap((i3) => i3.snapPoints);
  }
  get snapThreshold() {
    return this.editor.configuration.rendering.guides.gap / 2;
  }
  getNearestVerticalGuide(i2) {
    return this.renderer.verticalGuides.length ? this.renderer.verticalGuides.reduce((r2, s2) => Math.abs(s2 - i2) < Math.abs(r2 - i2) ? s2 : r2) : i2;
  }
  getNearestHorizontalGuide(i2) {
    return this.renderer.horizontalGuides.length ? this.renderer.horizontalGuides.reduce((r2, s2) => Math.abs(s2 - i2) < Math.abs(r2 - i2) ? s2 : r2) : i2;
  }
  getGuidePointToSnap(i2) {
    return { x: this.getNearestVerticalGuide(i2.x), y: this.getNearestHorizontalGuide(i2.y) };
  }
  drawSnapToElementLines(i2) {
    const r2 = { role: "snap-to-element", fill: "transparent", stroke: "blue", "stroke-width": "2", style: pe.noSelection, "marker-start": `url(#${pe.crossMarker})`, "marker-end": `url(#${pe.crossMarker})` };
    i2.forEach((i3) => {
      this.renderer.drawLine(i3.p1, i3.p2, r2);
    });
  }
  clearSnapToElementLines() {
    this.renderer.clearElements({ attrs: { role: "snap-to-element" } });
  }
  getSnapLinesInfos(i2, r2) {
    const s2 = { nudge: { x: 1 / 0, y: 1 / 0 }, verticales: [], horizontales: [] };
    return i2.length && r2.length ? (i2.forEach((i3) => {
      r2.forEach((r3) => {
        this.snapThreshold > Math.abs(r3.x - i3.x) && (Math.abs(s2.nudge.x) > Math.abs(r3.x - i3.x) ? (s2.nudge.x = r3.x - i3.x, s2.verticales = [{ p1: { ...i3 }, p2: r3 }]) : s2.nudge.x === r3.x - i3.x && s2.verticales.push({ p1: { ...i3 }, p2: r3 })), this.snapThreshold > Math.abs(r3.y - i3.y) && (Math.abs(s2.nudge.y) > Math.abs(r3.y - i3.y) ? (s2.nudge.y = r3.y - i3.y, s2.horizontales = [{ p1: { ...i3 }, p2: r3 }]) : s2.nudge.y === r3.y - i3.y && s2.horizontales.push({ p1: { ...i3 }, p2: r3 }));
      });
    }), s2) : s2;
  }
  snapResize(i2, r2 = true, s2 = true) {
    if (this.clearSnapToElementLines(), !this.configuration.symbol && !this.configuration.guide) return i2;
    let n2 = { x: 1 / 0, y: 1 / 0 };
    this.configuration.guide && (n2 = this.getGuidePointToSnap(i2));
    const a2 = [];
    if (this.configuration.symbol) {
      const l2 = this.getSnapLinesInfos([i2], this.otherSnapPoints);
      r2 && Math.abs(l2.nudge.x) <= Math.abs(i2.x - n2.x) && (n2.x = i2.x + l2.nudge.x, a2.push(...l2.verticales)), s2 && Math.abs(l2.nudge.y) <= Math.abs(i2.y - n2.y) && (n2.y = i2.y + l2.nudge.y, a2.push(...l2.horizontales));
    }
    return n2.x === 1 / 0 && (n2.x = i2.x), n2.y === 1 / 0 && (n2.y = i2.y), a2.forEach((i3) => i3.p1 = n2), this.drawSnapToElementLines(a2), n2;
  }
  snapTranslate(i2, r2) {
    this.clearSnapToElementLines();
    const s2 = { x: i2, y: r2 };
    if (!this.configuration.symbol && !this.configuration.guide) return s2;
    const n2 = this.selectionSnapPoints.map((s3) => ({ x: s3.x + i2, y: s3.y + r2 }));
    let a2 = 1 / 0, l2 = 1 / 0;
    this.configuration.guide && n2.forEach((n3) => {
      const d3 = this.getGuidePointToSnap(n3);
      a2 > Math.abs(d3.x - n3.x) && (s2.x = d3.x - n3.x + i2, a2 = Math.abs(d3.x - n3.x)), l2 > Math.abs(d3.y - n3.y) && (s2.y = d3.y - n3.y + r2, l2 = Math.abs(d3.y - n3.y));
    });
    const d2 = [];
    if (this.configuration.symbol) {
      const h2 = this.getSnapLinesInfos(n2, this.otherSnapPoints);
      a2 >= Math.abs(h2.nudge.x) && h2.verticales.length && (s2.x = h2.nudge.x + i2, d2.push(...h2.verticales)), l2 >= Math.abs(h2.nudge.y) && h2.horizontales.length && (s2.y = h2.nudge.y + r2, d2.push(...h2.horizontales));
    }
    return d2.length && (d2.forEach((n3) => {
      n3.p1.x += s2.x - i2, n3.p1.y += s2.y - r2;
    }), this.drawSnapToElementLines(d2)), s2;
  }
  snapRotation(i2) {
    return this.configuration.angle > 0 ? this.configuration.angle * Math.round(i2 / this.configuration.angle) : i2;
  }
};
_t33 = new WeakMap();
var Pe = { server: he.server, recognition: he.recognition, menu: Te, rendering: be, logger: h, grabber: xe, "undo-redo": Se, penStyle: y, fontStyle: { size: "auto", weight: "auto" }, gesture: Ie, snap: Le };
var InteractiveInkEditorConfiguration = class {
  constructor(i2) {
    __publicField(this, "grabber");
    __publicField(this, "logger");
    __publicField(this, "server");
    __publicField(this, "recognition");
    __publicField(this, "rendering");
    __publicField(this, "undo-redo");
    __publicField(this, "menu");
    __publicField(this, "penStyle");
    __publicField(this, "fontStyle");
    __publicField(this, "gesture");
    __publicField(this, "snap");
    const { server: r2, recognition: s2 } = new RecognizerWebSocketConfiguration(i2);
    this.recognition = s2, this.server = r2, this.grabber = mergeDeep({}, Pe.grabber, i2 == null ? void 0 : i2.grabber), this.logger = mergeDeep({}, Pe.logger, i2 == null ? void 0 : i2.logger), this.rendering = mergeDeep({}, Pe.rendering, i2 == null ? void 0 : i2.rendering), this["undo-redo"] = mergeDeep({}, Pe["undo-redo"], i2 == null ? void 0 : i2["undo-redo"]), this.menu = mergeDeep({}, Pe.menu, i2 == null ? void 0 : i2.menu), this.gesture = mergeDeep({}, Pe.gesture, i2 == null ? void 0 : i2.gesture), this.snap = new SnapConfiguration(i2 == null ? void 0 : i2.snap), this.penStyle = mergeDeep({}, Pe.penStyle, i2 == null ? void 0 : i2.penStyle), this.fontStyle = mergeDeep({}, Pe.fontStyle, i2 == null ? void 0 : i2.fontStyle);
  }
};
var _m, _y, _d2, _b, _f, _r2;
var InteractiveInkEditor = class extends AbstractEditor {
  constructor(i2, r2) {
    var _a, _b2;
    super(i2, r2);
    __privateAdd(this, _m);
    __privateAdd(this, _y);
    __privateAdd(this, _d2, i.Write);
    __privateAdd(this, _b);
    __privateAdd(this, _f);
    __publicField(this, "renderer");
    __publicField(this, "recognizer");
    __privateAdd(this, _r2);
    __publicField(this, "history");
    __publicField(this, "writer");
    __publicField(this, "eraser");
    __publicField(this, "gesture");
    __publicField(this, "resizer");
    __publicField(this, "rotator");
    __publicField(this, "translator");
    __publicField(this, "converter");
    __publicField(this, "texter");
    __publicField(this, "selector");
    __publicField(this, "svgDebugger");
    __publicField(this, "snaps");
    __publicField(this, "move");
    __publicField(this, "menu");
    if (__privateSet(this, _m, new InteractiveInkEditorConfiguration(r2 == null ? void 0 : r2.configuration)), __privateSet(this, _r2, Object.assign({}, __privateGet(this, _m).penStyle)), (_a = r2 == null ? void 0 : r2.override) == null ? void 0 : _a.recognizer) {
      const i3 = r2 == null ? void 0 : r2.override.recognizer;
      this.recognizer = new i3(__privateGet(this, _m));
    } else this.recognizer = new RecognizerWebSocket(__privateGet(this, _m));
    this.recognizer.event.addErrorListener(this.manageError.bind(this)), this.recognizer.event.addExportedListener(this.event.emitExported.bind(this.event)), this.recognizer.event.addContentChangedListener(this.onContentChanged.bind(this)), this.recognizer.event.addSessionOpenedListener(this.event.emitSessionOpened.bind(this.event)), this.recognizer.event.addEndInitialization(this.layers.hideMessageModal.bind(this.layers)), this.recognizer.event.addIdleListener(this.updateLayerState.bind(this)), this.renderer = new IISVGRenderer(__privateGet(this, _m).rendering), this.history = new IIHistoryManager(__privateGet(this, _m)["undo-redo"], this.event), this.writer = new IIWriteManager(this), this.eraser = new IIEraseManager(this), this.selector = new IISelectionManager(this), this.move = new IIMoveManager(this), this.gesture = new IIGestureManager(this, __privateGet(this, _m).gesture), this.resizer = new IIResizeManager(this), this.rotator = new IIRotationManager(this), this.translator = new IITranslateManager(this), this.converter = new IIConversionManager(this), this.texter = new IITextManager(this), this.svgDebugger = new IIDebugSVGManager(this), this.snaps = new IISnapManager(this, __privateGet(this, _m).snap), this.menu = new IIMenuManager(this, (_b2 = r2 == null ? void 0 : r2.override) == null ? void 0 : _b2.menu), __privateSet(this, _y, new IIModel(__privateGet(this, _m).rendering.minWidth, __privateGet(this, _m).rendering.minHeight, this.configuration.rendering.guides.gap));
  }
  get initializationPromise() {
    return this.recognizer.initialized.promise;
  }
  get tool() {
    return __privateGet(this, _d2);
  }
  set tool(r2) {
    switch (__privateSet(this, _d2, r2), this.menu.tool.update(), this.setCursorStyle(), this.unselectAll(), this.eraser.detach(), this.selector.detach(), this.move.detach(), this.writer.detach(), __privateGet(this, _d2)) {
      case i.Erase:
        this.eraser.attach(this.layers.rendering);
        break;
      case i.Select:
        this.selector.attach(this.layers.rendering);
        break;
      case i.Move:
        this.move.attach(this.layers.rendering);
        break;
      default:
        this.writer.attach(this.layers.rendering);
    }
    this.event.emitToolChanged(r2);
  }
  get model() {
    return __privateGet(this, _y);
  }
  get configuration() {
    return __privateGet(this, _m);
  }
  set renderingConfiguration(i2) {
    this.configuration.rendering = mergeDeep(this.configuration.rendering, i2);
    const r2 = Math.max(this.renderer.parent.clientHeight, this.configuration.rendering.minHeight), s2 = Math.max(this.renderer.parent.clientWidth, this.configuration.rendering.minWidth);
    this.renderer.resize(r2, s2), this.model.rowHeight = this.configuration.rendering.guides.gap, this.history.stack.forEach((i3) => i3.model.rowHeight = this.model.rowHeight), this.event.emitUIpdated();
  }
  get penStyle() {
    return __privateGet(this, _r2);
  }
  set penStyle(i2) {
    this.logger.info("set penStyle", { penStyle: i2 }), __privateSet(this, _r2, Object.assign({}, __privateGet(this, _r2), i2));
  }
  updateLayerState(i2) {
    this.event.emitIdle(i2), this.layers.updateState(i2);
  }
  updateLayerUI(i2 = 500) {
    clearTimeout(__privateGet(this, _b)), __privateSet(this, _b, setTimeout(() => {
      this.menu.update(), this.svgDebugger.apply(), this.waitForIdle(), this.event.emitUIpdated();
    }, i2));
  }
  manageError(i2) {
    this.layers.showMessageError(i2), this.event.emitError(i2);
  }
  setCursorStyle() {
    switch (__privateGet(this, _d2)) {
      case i.Erase:
        this.layers.root.classList.remove("draw"), this.layers.root.classList.add("erase"), this.layers.root.classList.remove("select"), this.layers.root.classList.remove("move");
        break;
      case i.Select:
        this.layers.root.classList.remove("draw"), this.layers.root.classList.remove("erase"), this.layers.root.classList.add("select"), this.layers.root.classList.remove("move");
        break;
      case i.Move:
        this.layers.root.classList.remove("draw"), this.layers.root.classList.remove("erase"), this.layers.root.classList.remove("select"), this.layers.root.classList.add("move");
        break;
      default:
        this.layers.root.classList.add("draw"), this.layers.root.classList.remove("erase"), this.layers.root.classList.remove("select"), this.layers.root.classList.remove("move");
    }
  }
  async onContentChanged(i2) {
    clearTimeout(__privateGet(this, _f)), __privateSet(this, _f, setTimeout(async () => {
      await this.synchronizeStrokesWithJIIX(), this.updateLayerUI(0), this.event.emitChanged(i2);
    }, 500));
  }
  async initialize() {
    try {
      this.logger.info("initialize"), this.layers.render(), this.layers.showLoader(), this.tool = i.Write, this.renderer.init(this.layers.rendering), this.menu.render(this.layers.ui.root);
      const r2 = window.getComputedStyle(this.layers.root);
      this.model.width = Math.max(parseInt(r2.width.replace("px", "")), __privateGet(this, _m).rendering.minWidth), this.model.height = Math.max(parseInt(r2.height.replace("px", "")), __privateGet(this, _m).rendering.minHeight), this.model.rowHeight = this.configuration.rendering.guides.gap, this.history.init(this.model), this.recognizer.configuration.server.version || (await this.loadInfo(this.configuration.server), this.recognizer.configuration.server.version = this.info.version), await this.recognizer.init();
    } catch (i2) {
      throw this.logger.error("initialize", i2), this.layers.showMessageError(i2), i2;
    } finally {
      this.logger.debug("initialize", "finally"), this.layers.hideLoader(), this.layers.updateState(true);
    }
  }
  async changeLanguage(i2) {
    try {
      this.logger.info("changeLanguage", { code: i2 }), this.updateLayerState(false), this.configuration.recognition.lang = i2, await this.recognizer.newSession(this.configuration), this.recognizer.addStrokes(this.extractStrokesFromSymbols(this.model.symbols), false), await this.synchronizeStrokesWithJIIX(true), this.layers.hideLoader(), this.event.emitLoaded();
    } catch (i3) {
      throw this.logger.error("changeLanguage", i3), this.manageError(i3), i3;
    } finally {
      this.updateLayerUI();
    }
  }
  buildShape(i2) {
    switch (i2.kind) {
      case M.Circle:
        return IIShapeCircle.create(i2);
      case M.Ellipse:
        return IIShapeEllipse.create(i2);
      case M.Polygon:
        return IIShapePolygon.create(i2);
      default:
        throw new Error(`Unable to create shape, kind: "${i2.kind}" is unknown`);
    }
  }
  buildEdge(i2) {
    switch (i2.kind) {
      case I.Arc:
        return IIEdgeArc.create(i2);
      case I.Line:
        return IIEdgeLine.create(i2);
      case I.PolyEdge:
        return IIEdgePolyLine.create(i2);
      default:
        throw new Error(`Unable to create edge, kind: "${i2.kind}" is unknown`);
    }
  }
  buildRecognized(i2) {
    switch (i2.kind) {
      case T.Text:
        return IIRecognizedText.create(i2);
      case T.Arc:
        return IIRecognizedArc.create(i2);
      case T.Circle:
        return IIRecognizedCircle.create(i2);
      case T.Ellipse:
        return IIRecognizedEllipse.create(i2);
      case T.Polygone:
        return IIRecognizedPolygon.create(i2);
      case T.Line:
        return IIRecognizedLine.create(i2);
      case T.PolyEdge:
        return IIRecognizedPolyLine.create(i2);
      default:
        throw new Error(`Unable to create recognized, symbol type '${JSON.stringify(i2)} is unknow`);
    }
  }
  buildGroup(i2) {
    var _a;
    if (!((_a = i2.children) == null ? void 0 : _a.length)) throw new Error("Unable to create group, no children");
    const r2 = i2.children.map((i3) => {
      switch (i3 == null ? void 0 : i3.type) {
        case E.Stroke:
          return IIStroke.create(i3);
        case E.Shape:
          return this.buildShape(i3);
        case E.Edge:
          return this.buildEdge(i3);
        case E.Text:
          return IIText.create(i3);
        case E.Group:
          return this.buildGroup(i3);
        case E.Recognized:
          return this.buildRecognized(i3);
        default:
          throw new Error(`Unable to create group, symbol type '${JSON.stringify(i3)} is unknow`);
      }
    }), s2 = new IISymbolGroup(r2, i2.style);
    return i2.id && (s2.id = i2.id), i2.decorators && (s2.decorators = i2.decorators.map((i3) => new IIDecorator(i3.kind, i3.style))), s2;
  }
  buildStroke(i2) {
    return IIStroke.create(i2);
  }
  buildStrokeText(i2) {
    return IIRecognizedText.create(i2);
  }
  buildText(i2) {
    return IIText.create(i2);
  }
  buildSymbol(i2) {
    try {
      switch (i2.type) {
        case E.Stroke:
          return this.buildStroke(i2);
        case E.Shape:
          return this.buildShape(i2);
        case E.Edge:
          return this.buildEdge(i2);
        case E.Text:
          return this.buildText(i2);
        case E.Group:
          return this.buildGroup(i2);
        case E.Recognized:
          return this.buildRecognized(i2);
        default:
          throw new Error(`Unable to build symbol, type: "${i2.type}" is unknown`);
      }
    } catch (i3) {
      throw this.logger.error("createSymbol", i3), this.manageError(i3), i3;
    }
  }
  async createSymbol(i2) {
    try {
      return await this.addSymbol(this.buildSymbol(i2));
    } catch (i3) {
      throw this.logger.error("createSymbol", i3), this.manageError(i3), i3;
    } finally {
      this.updateLayerUI();
    }
  }
  async createSymbols(i2) {
    try {
      const r2 = [], s2 = [];
      if (i2.forEach((i3) => {
        try {
          s2.push(this.buildSymbol(i3));
        } catch (i4) {
          r2.push(i4.message || i4);
        }
      }), r2.length) throw new Error(r2.join("\n"));
      return await this.addSymbols(s2);
    } catch (i3) {
      throw this.logger.error("createSymbols", i3), this.manageError(i3), i3;
    }
  }
  updateTextBounds(i2) {
    i2.type === E.Text ? this.texter.updateBounds(i2) : i2.type === E.Group && i2.extractText().forEach((i3) => this.texter.updateBounds(i3));
  }
  async addSymbol(i2, r2 = true) {
    this.logger.info("addSymbol", { sym: i2 }), this.updateLayerState(false), this.updateTextBounds(i2), this.model.addSymbol(i2), this.renderer.drawSymbol(i2);
    const s2 = this.extractStrokesFromSymbols([i2]);
    return this.recognizer.addStrokes(s2, false), r2 && this.history.push(this.model, { added: [i2] }), this.updateLayerUI(), i2;
  }
  async addSymbols(i2, r2 = true) {
    this.logger.info("addSymbol", { symList: i2 }), this.updateLayerState(false), i2.forEach((i3) => {
      this.updateTextBounds(i3), this.model.addSymbol(i3), this.renderer.drawSymbol(i3);
    });
    const s2 = this.extractStrokesFromSymbols(i2);
    return this.recognizer.addStrokes(s2, false), r2 && this.history.push(this.model, { added: i2 }), this.updateLayerUI(), i2;
  }
  async updateSymbol(i2, r2 = true) {
    this.logger.info("updateSymbol", { sym: i2 }), this.updateLayerState(false), this.updateTextBounds(i2), this.model.updateSymbol(i2), this.renderer.drawSymbol(i2);
    const s2 = this.extractStrokesFromSymbols([i2]);
    return this.recognizer.replaceStrokes(s2.map((i3) => i3.id), s2), r2 && this.history.push(this.model, { updated: [i2] }), this.updateLayerUI(), i2;
  }
  async updateSymbols(i2, r2 = true) {
    this.logger.info("updateSymbol", { symList: i2 }), this.updateLayerState(false), i2.forEach((i3) => {
      this.updateTextBounds(i3), this.model.updateSymbol(i3), this.renderer.drawSymbol(i3);
    });
    const s2 = this.extractStrokesFromSymbols(i2);
    return this.recognizer.replaceStrokes(s2.map((i3) => i3.id), s2), r2 && this.history.push(this.model, { updated: i2 }), this.updateLayerUI(), i2;
  }
  updateSymbolsStyle(i2, r2, s2 = true) {
    this.logger.info("updateSymbolsStyle", { symbolIds: i2, style: r2 });
    const n2 = [];
    this.model.symbols.forEach((s3) => {
      i2.includes(s3.id) && (s3.style = Object.assign({}, s3.style, r2), E.Text !== s3.type && E.Group !== s3.type && E.Recognized !== s3.type || s3.updateChildrenStyle(), this.renderer.drawSymbol(s3), this.model.updateSymbol(s3), s3.modificationDate = Date.now(), n2.push(s3));
    }), n2.length && n2.forEach((i3) => {
      if (i3.type === E.Text) {
        const r3 = i3.bounds.width;
        this.texter.updateBounds(i3);
        const s3 = i3.bounds.width - r3;
        0 !== s3 && this.texter.moveTextAfter(i3, s3);
      }
    }), s2 && n2.length && this.history.push(this.model, { style: { symbols: n2, style: r2 } });
  }
  updateTextFontStyle(i2, { fontSize: r2, fontWeight: s2 }) {
    this.logger.info("updateTextFontStyle", { textIds: i2, fontSize: r2, fontWeight: s2 });
    const n2 = [], a2 = [];
    this.model.symbols.forEach((l2) => {
      if (i2.includes(l2.id)) {
        if (l2.type === E.Text) {
          l2.updateChildrenFont({ fontSize: r2, fontWeight: "auto" === s2 ? void 0 : s2 });
          const i3 = l2.bounds.width;
          this.texter.updateBounds(l2), this.renderer.drawSymbol(l2);
          const d2 = l2.bounds.width - i3;
          if (0 !== d2) {
            const i4 = this.texter.moveTextAfter(l2, d2);
            (i4 == null ? void 0 : i4.length) && a2.push({ symbols: i4, tx: d2, ty: 0 });
          }
          l2.modificationDate = Date.now(), n2.push(l2);
        } else if (l2.type === E.Group) {
          const i3 = l2.extractText();
          i3.length && (i3.forEach((i4) => {
            i4.updateChildrenFont({ fontSize: r2, fontWeight: "auto" === s2 ? void 0 : s2 });
            const n3 = l2.bounds.width;
            this.texter.updateBounds(i4);
            const d2 = l2.bounds.width - n3, h2 = this.texter.moveTextAfter(i4, d2);
            (h2 == null ? void 0 : h2.length) && a2.push({ symbols: h2, tx: d2, ty: 0 });
          }), l2.modificationDate = Date.now(), this.renderer.drawSymbol(l2), n2.push(l2));
        }
      }
    }), n2.length && this.history.push(this.model, { style: { symbols: n2, fontSize: r2 }, translate: a2 });
  }
  async replaceSymbols(i2, r2, s2 = true) {
    this.logger.info("replaceSymbol", { oldSymbols: i2, newSymbols: r2 }), this.updateLayerState(false);
    const n2 = this.extractStrokesFromSymbols(i2), a2 = this.extractStrokesFromSymbols(r2), l2 = i2.shift();
    l2 && (i2.forEach((i3) => {
      this.renderer.removeSymbol(i3.id), this.model.removeSymbol(i3.id);
    }), this.model.replaceSymbol(l2.id, r2), this.renderer.replaceSymbol(l2.id, r2), n2.length && a2.length ? this.recognizer.replaceStrokes(n2.map((i3) => i3.id), a2) : n2.length ? this.recognizer.eraseStrokes(n2.map((i3) => i3.id)) : this.recognizer.addStrokes(a2, false), s2 && this.history.push(this.model, { replaced: { oldSymbols: i2, newSymbols: r2 } }), this.updateLayerUI());
  }
  changeOrderSymbol(i2, r2) {
    this.model.changeOrderSymbol(i2.id, r2), this.renderer.changeOrderSymbol(i2, r2), this.history.push(this.model, { order: { symbols: [i2], position: r2 } });
  }
  changeOrderSymbols(i2, r2) {
    i2.forEach((i3) => {
      this.model.changeOrderSymbol(i3.id, r2), this.renderer.changeOrderSymbol(i3, r2);
    }), this.history.push(this.model, { order: { symbols: i2, position: r2 } });
  }
  groupSymbols(i2) {
    const r2 = this.buildGroup({ children: i2 });
    return i2.forEach((i3) => {
      this.model.removeSymbol(i3.id), this.renderer.removeSymbol(i3.id);
    }), this.model.addSymbol(r2), this.history.push(this.model, { group: { symbols: i2 } }), r2;
  }
  ungroupSymbol(i2) {
    return i2.children.forEach((i3) => this.renderer.drawSymbol(i3)), this.renderer.removeSymbol(i2.id), this.model.replaceSymbol(i2.id, i2.children), this.history.push(this.model, { ungroup: { group: i2 } }), i2.children;
  }
  async synchronizeStrokesWithJIIX(i2 = false) {
    var _a, _b2;
    const r2 = this.model.symbols.filter((i3) => i3.type === E.Stroke);
    if (!i2 && !r2.length) return void this.event.emitSynchronized();
    await this.export(["application/vnd.myscript.jiix"]);
    const getSymbolsAndStrokesAssociatedFromJIIXStrokeItems = (i3 = []) => {
      const r3 = [], s3 = [], n2 = [];
      return i3.forEach((i4) => {
        const a2 = i4["full-id"];
        if (n2.includes(a2)) return;
        n2.push(a2);
        const l2 = this.model.getRootSymbol(a2);
        if (l2) {
          if ((l2 == null ? void 0 : l2.type) === E.Recognized) s3.push(l2.strokes.find((r4) => r4.id === i4["full-id"]));
          else s3.push(l2);
          const n3 = r3.findIndex((i5) => i5.id === l2.id);
          n3 < 0 ? r3.push(l2) : r3[n3] = l2;
        }
      }), { symbols: r3, strokes: s3 };
    }, s2 = (_a = this.model.exports) == null ? void 0 : _a["application/vnd.myscript.jiix"];
    (_b2 = s2 == null ? void 0 : s2.elements) == null ? void 0 : _b2.forEach((i3) => {
      var _a2;
      switch (i3.type) {
        case p.Text:
          (_a2 = i3.words) == null ? void 0 : _a2.forEach((r3) => {
            const s3 = getSymbolsAndStrokesAssociatedFromJIIXStrokeItems(r3.items);
            if (s3.strokes.length) {
              if (1 === s3.symbols.length) {
                const i4 = s3.symbols[0];
                if (i4.type === E.Recognized && i4.kind === T.Text && i4.label === r3.label && i4.strokes.length == i4.strokes.length) return;
              }
              const n2 = i3.lines.find((i4) => i4["first-char"] <= r3["first-char"] && i4["last-char"] >= r3["last-char"]), a2 = new IIRecognizedText(s3.strokes, { baseline: convertMillimeterToPixel(n2["baseline-y"]), xHeight: convertMillimeterToPixel(n2["x-height"]) });
              a2.label = r3.label, s3.symbols.forEach((i4) => {
                i4.type === E.Recognized && i4.kind === T.Text && i4.decorators.forEach((i5) => {
                  a2.decorators.some((r4) => r4.kind === i5.kind) || a2.decorators.push(i5);
                }), this.model.removeSymbol(i4.id), this.renderer.removeSymbol(i4.id);
              }), this.model.addSymbol(a2), this.renderer.drawSymbol(a2);
            }
          });
          break;
        case p.Node: {
          let r3;
          const s3 = getSymbolsAndStrokesAssociatedFromJIIXStrokeItems(i3.items);
          if (s3.strokes.length) {
            if (1 === s3.symbols.length) {
              const i4 = s3.symbols[0];
              if (i4.type === E.Recognized && i4.strokes.length === s3.strokes.length) return;
            }
            switch (i3.kind) {
              case g.Circle:
                r3 = new IIRecognizedCircle(s3.strokes);
                break;
              case g.Ellipse:
                r3 = new IIRecognizedEllipse(s3.strokes);
                break;
              case g.Rectangle:
              case g.Triangle:
              case g.Parallelogram:
              case g.Polygon:
              case g.Rhombus:
                r3 = new IIRecognizedPolygon(s3.strokes);
                break;
              default:
                this.logger.warn("synchronizeStrokesWithJIIX", `Can not create recognized shape symbol, kind unknow: ${i3}`);
            }
            r3 && (s3.symbols.forEach((i4) => {
              this.model.removeSymbol(i4.id), this.renderer.removeSymbol(i4.id);
            }), this.model.addSymbol(r3), this.renderer.drawSymbol(r3));
          }
          break;
        }
        case p.Edge: {
          let r3;
          const s3 = getSymbolsAndStrokesAssociatedFromJIIXStrokeItems(i3.kind === m.PolyEdge ? i3.edges.flatMap((i4) => i4.items) : i3.items);
          if (s3.strokes.length) {
            if (1 === s3.symbols.length) {
              const i4 = s3.symbols[0];
              if (i4.type === E.Recognized && i4.strokes.length === s3.strokes.length) return;
            }
            switch (i3.kind) {
              case m.Line:
                r3 = new IIRecognizedLine(s3.strokes);
                break;
              case m.PolyEdge:
                r3 = new IIRecognizedPolyLine(s3.strokes);
                break;
              case m.Arc:
                r3 = new IIRecognizedArc(s3.strokes);
                break;
              default:
                this.logger.warn("synchronizeStrokesWithJIIX", `Can not create recognized edge symbol, kind unknow: ${i3}`);
            }
            r3 && (s3.symbols.forEach((i4) => {
              this.model.removeSymbol(i4.id), this.renderer.removeSymbol(i4.id);
            }), this.model.addSymbol(r3), this.renderer.drawSymbol(r3));
          }
          break;
        }
        default:
          this.logger.warn("synchronizeStrokesWithJIIX", `Can not create recognized symbol, type unknow: ${i3}`);
      }
    }), this.model.mergeExport({ "application/vnd.myscript.jiix": s2 }), this.history.update(this.model), this.event.emitSynchronized();
  }
  async removeSymbol(i2, r2 = true) {
    this.logger.info("removeSymbol", { id: i2 });
    const s2 = this.model.getRootSymbol(i2);
    if (s2) {
      if (this.updateLayerState(false), s2.type === E.Group) {
        const r3 = s2.extractStrokes().map((i3) => i3.id);
        s2.removeChilds([i2]), s2.children.length ? (this.model.updateSymbol(s2), this.renderer.drawSymbol(s2), r3.includes(i2) && this.recognizer.eraseStrokes([i2])) : (this.recognizer.eraseStrokes(r3), this.model.removeSymbol(s2.id), this.renderer.removeSymbol(s2.id));
      } else this.recognizer.eraseStrokes([i2]), this.model.removeSymbol(s2.id), this.renderer.removeSymbol(s2.id);
      r2 && this.history.push(this.model, { erased: [s2] }), this.updateLayerUI();
    } else this.renderer.removeSymbol(i2), this.recognizer.eraseStrokes([i2]);
  }
  async removeSymbols(i2, r2 = true) {
    this.logger.info("removeSymbol", { ids: i2 });
    const s2 = [], n2 = [], a2 = [];
    if (i2.forEach((r3) => {
      const l2 = this.model.getRootSymbol(r3);
      if (l2) if (l2.id === r3) switch (s2.push(l2), l2.type) {
        case E.Stroke:
          a2.push(l2.id);
          break;
        case E.Recognized:
          a2.push(...l2.strokes.map((i3) => i3.id));
          break;
        case E.Group:
          a2.push(...l2.extractStrokes().map((i3) => i3.id));
      }
      else switch (l2.type) {
        case E.Group: {
          const r4 = l2.clone();
          a2.push(...r4.extractStrokes().map((i3) => i3.id).filter((r5) => i2.includes(r5))), r4.removeChilds(i2), r4.children.length ? n2.push(r4) : s2.push(r4);
          break;
        }
        case E.Recognized: {
          a2.push(r3);
          const d2 = l2.clone();
          d2.removeStrokes(i2), d2.strokes.length ? n2.push(d2) : s2.push(d2);
          break;
        }
      }
    }), this.recognizer.eraseStrokes(a2), s2.forEach((i3) => {
      this.model.removeSymbol(i3.id), this.renderer.removeSymbol(i3.id);
    }), n2.forEach((i3) => {
      this.model.updateSymbol(i3), this.renderer.drawSymbol(i3);
    }), r2) {
      const i3 = {};
      (s2.length || n2.length) && (s2.length && (i3.erased = s2), n2.length && (i3.updated = n2), this.history.push(this.model, i3), this.updateLayerUI());
    }
    return this.updateLayerState(false), s2;
  }
  select(i2) {
    this.selector.removeSelectedGroup(), this.model.symbols.forEach((r2) => {
      r2.selected = i2.includes(r2.id), this.renderer.drawSymbol(r2);
    }), this.selector.drawSelectedGroup(this.model.symbolsSelected), this.updateLayerUI(), this.event.emitSelected(this.model.symbolsSelected);
  }
  selectAll() {
    this.selector.removeSelectedGroup(), this.model.symbols.forEach((i2) => {
      i2.selected = true, this.renderer.drawSymbol(i2);
    }), this.selector.drawSelectedGroup(this.model.symbolsSelected), this.updateLayerUI(), this.event.emitSelected(this.model.symbolsSelected);
  }
  unselectAll() {
    this.model.symbolsSelected.length && (this.model.symbolsSelected.forEach((i2) => {
      i2.selected = false, this.renderer.drawSymbol(i2);
    }), this.selector.removeSelectedGroup(), this.updateLayerUI(), this.event.emitSelected(this.model.symbolsSelected));
  }
  async importPointEvents(i2) {
    this.logger.info("importPointEvents", { partialStrokes: i2 }), this.updateLayerState(false);
    const r2 = convertPartialStrokesToOIStrokes(i2);
    return r2.forEach((i3) => {
      this.model.addSymbol(i3), this.renderer.drawSymbol(i3);
    }), this.recognizer.addStrokes(r2, false), this.history.push(this.model, { added: r2 }), this.logger.debug("importPointEvents", this.model), this.updateLayerUI(), this.event.emitImported(this.model.exports), this.model;
  }
  triggerDownload(i2, r2) {
    const s2 = document.createElement("a");
    s2.setAttribute("href", r2), s2.setAttribute("download", i2), document.body.appendChild(s2), s2.click(), s2.remove();
  }
  getSymbolsBounds(i2, r2 = 10) {
    const s2 = Box.createFromBoxes(i2.map((i3) => i3.bounds));
    return s2.x -= r2, s2.y -= r2, s2.width += 2 * r2, s2.height += 2 * r2, s2;
  }
  buildBlobFromSymbols(i2, r2) {
    const s2 = SVGBuilder.createLayer(r2);
    i2.forEach((i3) => {
      var _a;
      const r3 = (_a = this.renderer.getElementById(i3.id)) == null ? void 0 : _a.cloneNode(true);
      r3 && s2.appendChild(r3);
    });
    const n2 = new XMLSerializer().serializeToString(s2);
    return new Blob([n2], { type: "image/svg+xml;charset=utf-8" });
  }
  getExportName(i2) {
    const r2 = { year: "numeric", month: "numeric", day: "numeric", hour: "2-digit", minute: "2-digit", second: "2-digit" };
    try {
      return `iink-ts-${(/* @__PURE__ */ new Date()).toLocaleDateString(navigator.language, r2)}.${i2}`;
    } catch {
      return `iink-ts-${(/* @__PURE__ */ new Date()).toLocaleDateString("en-US", r2)}.${i2}`;
    }
  }
  downloadAsSVG(i2 = false) {
    const r2 = i2 ? this.model.symbolsSelected : this.model.symbols, s2 = this.getSymbolsBounds(r2), n2 = this.buildBlobFromSymbols(r2, s2), a2 = URL.createObjectURL(n2);
    this.triggerDownload(this.getExportName("svg"), a2);
  }
  downloadAsPNG(i2 = false) {
    const r2 = i2 ? this.model.symbolsSelected : this.model.symbols, s2 = this.getSymbolsBounds(r2), n2 = this.buildBlobFromSymbols(r2, s2), a2 = URL.createObjectURL(n2), l2 = new Image(s2.width, s2.height);
    l2.src = a2, l2.onload = () => {
      const i3 = document.createElement("canvas");
      i3.width = l2.width, i3.height = l2.height;
      i3.getContext("2d").drawImage(l2, 0, 0), URL.revokeObjectURL(a2);
      const r3 = i3.toDataURL("image/png").replace("image/png", "image/octet-stream");
      this.triggerDownload(this.getExportName("png"), r3);
    };
  }
  downloadAsJson(i2 = false) {
    const r2 = i2 ? this.model.symbolsSelected : this.model.symbols, s2 = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(r2, null, 2));
    this.triggerDownload(this.getExportName("json"), s2);
  }
  extractStrokesFromSymbols(i2) {
    if (!(i2 == null ? void 0 : i2.length)) return [];
    const r2 = [];
    return i2.forEach((i3) => {
      switch (i3.type) {
        case E.Stroke:
          r2.push(i3);
          break;
        case E.Recognized:
          r2.push(...i3.strokes);
          break;
        case E.Group:
          r2.push(...i3.extractStrokes());
      }
    }), r2;
  }
  extractTextsFromSymbols(i2) {
    if (!(i2 == null ? void 0 : i2.length)) return [];
    const r2 = [];
    return i2.forEach((i3) => {
      switch (i3.type) {
        case E.Text:
          r2.push(i3);
          break;
        case E.Group:
          r2.push(...i3.extractText());
      }
    }), r2;
  }
  extractBackendChanges(i2) {
    var _a, _b2, _c2, _d6, _e2;
    const r2 = {};
    r2.added = this.extractStrokesFromSymbols(i2.added), r2.erased = this.extractStrokesFromSymbols(i2.erased);
    const s2 = this.extractStrokesFromSymbols(i2.updated), n2 = s2.concat(this.extractStrokesFromSymbols((_a = i2.replaced) == null ? void 0 : _a.oldSymbols)), a2 = s2.concat(this.extractStrokesFromSymbols((_b2 = i2.replaced) == null ? void 0 : _b2.newSymbols));
    return n2.length && a2.length ? r2.replaced = { oldStrokes: n2, newStrokes: a2 } : (r2.added.push(...a2), r2.erased.push(...n2)), i2.matrix && (r2.matrix = { strokes: this.extractStrokesFromSymbols(i2.matrix.symbols), matrix: i2.matrix.matrix }), ((_c2 = i2.translate) == null ? void 0 : _c2.length) && (r2.translate = [], i2.translate.forEach((i3) => {
      const s3 = this.extractStrokesFromSymbols(i3.symbols);
      s3.length && r2.translate.push({ strokes: s3, tx: i3.tx, ty: i3.ty });
    })), ((_d6 = i2.scale) == null ? void 0 : _d6.length) && (r2.scale = [], i2.scale.forEach((i3) => {
      const s3 = this.extractStrokesFromSymbols(i3.symbols);
      s3.length && r2.scale.push({ strokes: s3, origin: i3.origin, scaleX: i3.scaleX, scaleY: i3.scaleY });
    })), ((_e2 = i2.rotate) == null ? void 0 : _e2.length) && (r2.rotate = [], i2.rotate.forEach((i3) => {
      const s3 = this.extractStrokesFromSymbols(i3.symbols);
      s3.length && r2.rotate.push({ strokes: s3, center: i3.center, angle: i3.angle });
    })), r2;
  }
  async undo() {
    var _a, _b2, _c2, _d6, _e2;
    if (this.logger.info("undo"), this.history.context.canUndo) {
      this.updateLayerState(false), this.unselectAll();
      const i2 = this.history.undo(), r2 = i2.model.extractDifferenceSymbols(this.model);
      __privateSet(this, _y, i2.model.clone()), this.logger.debug("undo", { previousStackItem: i2 });
      const s2 = this.extractBackendChanges(i2.changes);
      r2.removed.forEach((i3) => this.renderer.removeSymbol(i3.id)), r2.added.forEach((i3) => this.renderer.drawSymbol(i3)), (((_a = s2.added) == null ? void 0 : _a.length) || ((_b2 = s2.erased) == null ? void 0 : _b2.length) || s2.replaced || s2.matrix || ((_c2 = s2.translate) == null ? void 0 : _c2.length) || ((_d6 = s2.scale) == null ? void 0 : _d6.length) || ((_e2 = s2.rotate) == null ? void 0 : _e2.length)) && await this.recognizer.undo(s2), this.updateLayerUI();
    }
    return this.model;
  }
  async redo() {
    var _a, _b2, _c2, _d6, _e2;
    if (this.logger.info("redo"), this.history.context.canRedo) {
      this.updateLayerState(false), this.unselectAll();
      const i2 = this.history.redo(), r2 = i2.model.extractDifferenceSymbols(this.model);
      __privateSet(this, _y, i2.model.clone()), this.logger.debug("redo", { modifications: r2 });
      const s2 = this.extractBackendChanges(i2.changes);
      r2.removed.forEach((i3) => this.renderer.removeSymbol(i3.id)), r2.added.forEach((i3) => this.renderer.drawSymbol(i3)), (((_a = s2.added) == null ? void 0 : _a.length) || ((_b2 = s2.erased) == null ? void 0 : _b2.length) || s2.replaced || s2.matrix || ((_c2 = s2.translate) == null ? void 0 : _c2.length) || ((_d6 = s2.scale) == null ? void 0 : _d6.length) || ((_e2 = s2.rotate) == null ? void 0 : _e2.length)) && await this.recognizer.redo(s2), this.updateLayerUI();
    }
    return this.model;
  }
  async export(i2) {
    try {
      this.logger.info("export", { mimeTypes: i2 });
      const r2 = await this.recognizer.export(i2);
      this.model.mergeExport(r2);
    } catch (i3) {
      throw this.logger.error("export", { error: i3 }), this.manageError(i3), i3;
    }
    return this.model;
  }
  async convert() {
    await this.convertSymbols();
  }
  async convertSymbols(i2) {
    try {
      this.updateLayerState(false), await this.converter.apply(i2), this.event.emitConverted(this.model.converts);
    } catch (i3) {
      throw this.logger.error("convert", i3), this.manageError(i3), i3;
    } finally {
      this.updateLayerUI();
    }
  }
  async waitForIdle() {
    return this.recognizer.waitForIdle();
  }
  async resize({ height: i2, width: r2 } = {}) {
    try {
      this.logger.info("resize", { height: i2, width: r2 });
      const s2 = window.getComputedStyle(this.layers.root);
      i2 = i2 || Math.max(parseInt(s2.height.replace("px", "")), this.configuration.rendering.minHeight), r2 = r2 || Math.max(parseInt(s2.width.replace("px", "")), this.configuration.rendering.minWidth), this.updateLayerState(false), this.model.height = i2, this.model.width = r2, this.renderer.resize(i2, r2), this.updateLayerUI(50), this.updateLayerState(true);
    } catch (i3) {
      this.manageError(i3);
    }
  }
  async clear() {
    try {
      if (this.logger.info("clear"), this.updateLayerState(false), this.model.symbols.length) {
        this.selector.removeSelectedGroup();
        const i2 = this.model.symbols;
        this.renderer.clear(), this.model.clear(), this.history.push(this.model, { erased: i2 }), this.recognizer.clear(), this.event.emitSelected(this.model.symbolsSelected);
      }
      this.updateLayerUI(), this.event.emitCleared();
    } catch (i2) {
      this.manageError(i2);
    }
  }
  async destroy() {
    return this.logger.info("destroy"), this.eraser.detach(), this.selector.detach(), this.move.detach(), this.writer.detach(), this.renderer.destroy(), this.menu.destroy(), this.recognizer.destroy(), this.model.clear(), this.history.clear(), Promise.resolve();
  }
};
_m = new WeakMap();
_y = new WeakMap();
_d2 = new WeakMap();
_b = new WeakMap();
_f = new WeakMap();
_r2 = new WeakMap();
var Re = { exportContent: "POINTER_UP", exportContentDelay: 1e3, resizeTriggerDelay: 100 };
var De = { server: te.server, recognition: te.recognition, rendering: ye, grabber: xe, triggers: Re, "undo-redo": Se, logger: h, penStyle: {}, theme: f };
var InkEditorDeprecatedConfiguration = class {
  constructor(i2) {
    __publicField(this, "server");
    __publicField(this, "recognition");
    __publicField(this, "rendering");
    __publicField(this, "undo-redo");
    __publicField(this, "grabber");
    __publicField(this, "triggers");
    __publicField(this, "logger");
    __publicField(this, "penStyle");
    __publicField(this, "penStyleClasses");
    __publicField(this, "theme");
    const { server: r2, recognition: s2 } = new RecognizerHTTPV1Configuration(i2);
    this.server = r2, this.recognition = s2, this.rendering = mergeDeep({}, De.rendering, i2 == null ? void 0 : i2.rendering), this.grabber = mergeDeep({}, De.grabber, i2 == null ? void 0 : i2.grabber), this["undo-redo"] = mergeDeep({}, De["undo-redo"], i2 == null ? void 0 : i2["undo-redo"]), this.triggers = mergeDeep({}, De.triggers, i2 == null ? void 0 : i2.triggers), this.logger = mergeDeep({}, De.logger, i2 == null ? void 0 : i2.logger), this.penStyle = mergeDeep({}, De.penStyle, i2 == null ? void 0 : i2.penStyle), this.penStyleClasses = (i2 == null ? void 0 : i2.penStyleClasses) || this.penStyleClasses, this.theme = mergeDeep({}, De.theme, i2 == null ? void 0 : i2.theme);
  }
};
var _m2, _y2, _x, _S, _d3;
var InkEditorDeprecated = class extends AbstractEditor {
  constructor(r2, s2) {
    var _a, _b2, _c2, _d6;
    super(r2, s2);
    __privateAdd(this, _m2);
    __privateAdd(this, _y2);
    __privateAdd(this, _x);
    __privateAdd(this, _S);
    __publicField(this, "grabber");
    __publicField(this, "renderer");
    __publicField(this, "recognizer");
    __publicField(this, "history");
    __publicField(this, "styleManager");
    __privateAdd(this, _d3, i.Write);
    if (__privateSet(this, _m2, new InkEditorDeprecatedConfiguration(s2 == null ? void 0 : s2.configuration)), this.styleManager = new StyleManager((_a = s2 == null ? void 0 : s2.configuration) == null ? void 0 : _a.penStyle, (_b2 = s2 == null ? void 0 : s2.configuration) == null ? void 0 : _b2.theme), (_c2 = s2 == null ? void 0 : s2.override) == null ? void 0 : _c2.grabber) {
      const i2 = s2.override.grabber;
      this.grabber = new i2(__privateGet(this, _m2).grabber);
    } else this.grabber = new PointerEventGrabber(__privateGet(this, _m2).grabber);
    if (this.grabber.onPointerDown = this.onPointerDown.bind(this), this.grabber.onPointerMove = this.onPointerMove.bind(this), this.grabber.onPointerUp = this.onPointerUp.bind(this), (_d6 = s2 == null ? void 0 : s2.override) == null ? void 0 : _d6.recognizer) {
      const i2 = s2.override.recognizer;
      this.recognizer = new i2(__privateGet(this, _m2));
    } else this.recognizer = new RecognizerHTTPV1(__privateGet(this, _m2));
    this.renderer = new CanvasRenderer(__privateGet(this, _m2).rendering), this.tool = i.Write, __privateSet(this, _y2, new Model()), this.history = new HistoryManager(__privateGet(this, _m2)["undo-redo"], this.event);
  }
  onPointerDown(r2) {
    var _a;
    this.logger.info("onPointerDown", { tool: this.tool, info: r2 });
    const s2 = Object.assign({}, (_a = this.theme) == null ? void 0 : _a.ink, this.currentPenStyle);
    switch (this.tool) {
      case i.Erase:
        this.model.removeStrokesFromPoint(r2.pointer).length > 0 && this.renderer.drawModel(this.model);
        break;
      case i.Write:
        this.model.initCurrentStroke(r2.pointer, r2.pointerType, s2), this.drawCurrentStroke();
        break;
      default:
        this.logger.warn("#onPointerDown", `onPointerDown tool unknow: "${this.tool}"`);
    }
  }
  onPointerMove(r2) {
    switch (this.logger.info("onPointerMove", { tool: this.tool, info: r2 }), this.tool) {
      case i.Erase:
        this.model.removeStrokesFromPoint(r2.pointer).length > 0 && this.renderer.drawModel(this.model);
        break;
      case i.Write:
        this.model.appendToCurrentStroke(r2.pointer), this.drawCurrentStroke();
        break;
      default:
        this.logger.warn("#onPointerMove", `onPointerMove tool unknow: "${this.tool}"`);
    }
  }
  async onPointerUp(r2) {
    var _a;
    try {
      switch (this.logger.info("onPointerUp", { tool: this.tool, info: r2 }), this.tool) {
        case i.Erase:
          this.model.removeStrokesFromPoint(r2.pointer), ((_a = this.history.stack.at(-1)) == null ? void 0 : _a.modificationDate) !== this.model.modificationDate && await this.updateModelRendering();
          break;
        case i.Write:
          this.model.endCurrentStroke(r2.pointer), await this.updateModelRendering();
          break;
        default:
          this.logger.warn("#onPointerUp", `onPointerUp tool unknow: "${this.tool}"`);
      }
    } catch (i2) {
      throw this.layers.showMessageError(i2), this.event.emitError(i2), i2;
    }
  }
  get initializationPromise() {
    return Promise.resolve();
  }
  get tool() {
    return __privateGet(this, _d3);
  }
  set tool(i2) {
    __privateSet(this, _d3, i2), this.setCursorStyle();
  }
  setCursorStyle() {
    if (this.tool === i.Erase) this.layers.root.classList.remove("draw"), this.layers.root.classList.add("erase");
    else this.layers.root.classList.add("draw"), this.layers.root.classList.remove("erase");
  }
  get model() {
    return __privateGet(this, _y2);
  }
  get currentPenStyle() {
    return this.styleManager.currentPenStyle;
  }
  get penStyle() {
    return this.styleManager.penStyle;
  }
  set penStyle(i2) {
    this.logger.info("setPenStyle", { penStyle: i2 }), this.styleManager.setPenStyle(i2);
  }
  get penStyleClasses() {
    return this.styleManager.penStyleClasses;
  }
  set penStyleClasses(i2) {
    this.logger.info("setPenStyleClasses", { penStyleClasses: i2 }), this.styleManager.setPenStyleClasses(i2);
  }
  get theme() {
    return this.styleManager.theme;
  }
  set theme(i2) {
    this.logger.info("setTheme", { theme: i2 }), this.styleManager.setTheme(i2);
  }
  get configuration() {
    return __privateGet(this, _m2);
  }
  async initialize() {
    try {
      this.logger.info("initialize"), this.layers.render(), this.layers.showLoader();
      const i2 = window.getComputedStyle(this.layers.root);
      this.model.width = Math.max(parseInt(i2.width.replace("px", "")), __privateGet(this, _m2).rendering.minWidth), this.model.height = Math.max(parseInt(i2.height.replace("px", "")), __privateGet(this, _m2).rendering.minHeight), this.history.push(this.model), this.layers.rendering.classList.add(this.configuration.recognition.type.toLowerCase().replace(" ", "-")), this.renderer.init(this.layers.rendering, { x: 50, y: 50 }), this.grabber.attach(this.layers.rendering);
    } catch (i2) {
      throw this.logger.error("initialize", i2), this.layers.showMessageError(i2), i2;
    } finally {
      this.logger.debug("initialize", "finally"), this.layers.hideLoader(), this.layers.updateState(true);
    }
  }
  drawCurrentStroke() {
    this.logger.debug("drawCurrentStroke", { stroke: this.model.currentSymbol }), this.renderer.drawPendingStroke(this.model.currentSymbol);
  }
  async updateModelRendering() {
    this.logger.info("updateModelRendering"), this.renderer.drawModel(this.model);
    const i2 = new DeferredPromise();
    if (this.history.push(this.model), "DEMAND" !== __privateGet(this, _m2).triggers.exportContent) {
      clearTimeout(__privateGet(this, _S));
      let r2 = this.model.clone();
      __privateSet(this, _S, setTimeout(async () => {
        try {
          r2 = await this.recognizer.export(r2), this.history.updateStack(r2), this.model.modificationDate === r2.modificationDate && (this.model.exports = r2.exports), i2.resolve(this.model);
        } catch (r3) {
          this.logger.error("updateModelRendering", { error: r3 }), this.event.emitError(r3), i2.reject(r3);
        }
      }, "QUIET_PERIOD" === __privateGet(this, _m2).triggers.exportContent ? __privateGet(this, _m2).triggers.exportContentDelay : 0));
    } else i2.resolve(this.model);
    return await i2.promise, this.event.emitExported(this.model.exports), this.logger.debug("updateModelRendering", this.model.exports), i2.promise;
  }
  async export(i2) {
    this.logger.info("export", { mimeTypes: i2 });
    const r2 = await this.recognizer.export(this.model.clone(), i2);
    return this.model.modificationDate === r2.modificationDate && this.model.mergeExport(r2.exports), this.history.updateStack(r2), this.event.emitExported(this.model.exports), this.logger.debug("export", this.model), this.model;
  }
  async convert(i2) {
    this.logger.info("convert", { params: i2 });
    const r2 = await this.recognizer.convert(this.model, i2 == null ? void 0 : i2.conversionState, i2 == null ? void 0 : i2.mimeTypes);
    return Object.assign(__privateGet(this, _y2), r2), this.event.emitConverted(this.model.converts), this.logger.debug("convert", this.model), this.model;
  }
  async importPointEvents(i2) {
    const r2 = [];
    i2.forEach((i3, s2) => {
      var _a, _b2;
      let n2 = true;
      const a2 = new Stroke(i3.style || b, i3.pointerType);
      if (i3.id && (a2.id = i3.id), !((_a = i3.pointers) == null ? void 0 : _a.length)) return r2.push(`stroke ${s2 + 1} has not pointers`), void (n2 = false);
      (_b2 = i3.pointers) == null ? void 0 : _b2.forEach((i4, l2) => {
        if (!i4) return r2.push(`stroke ${s2 + 1} has no pointer at ${l2}`), void (n2 = false);
        const d2 = { p: i4.p || 1, t: i4.t || l2, x: 0, y: 0 };
        return null == (i4 == null ? void 0 : i4.x) || null == (i4 == null ? void 0 : i4.x) ? (r2.push(`stroke ${s2 + 1} has no x at pointer at ${l2}`), void (n2 = false)) : (d2.x = i4.x, null == (i4 == null ? void 0 : i4.y) || null == (i4 == null ? void 0 : i4.y) ? (r2.push(`stroke ${s2 + 1} has no y at pointer at ${l2}`), void (n2 = false)) : (d2.y = i4.y, void (n2 && a2.pointers.push(d2))));
      }), n2 && this.model.addStroke(a2);
    }), r2.length && this.event.emitError(new Error(r2.join("\n")));
    try {
      const i3 = await this.updateModelRendering();
      return Object.assign(__privateGet(this, _y2), i3), this.event.emitImported(this.model.exports), this.model;
    } catch (i3) {
      throw this.event.emitError(i3), i3;
    }
  }
  async resize({ height: i2, width: r2 } = {}) {
    this.logger.info("resize", { height: i2, width: r2 });
    const s2 = new DeferredPromise(), n2 = window.getComputedStyle(this.layers.root);
    this.model.height = i2 || Math.max(parseInt(n2.height.replace("px", "")), this.configuration.rendering.minHeight), this.model.width = r2 || Math.max(parseInt(n2.width.replace("px", "")), this.configuration.rendering.minWidth), this.renderer.resize(this.model), this.model.symbols.length ? (clearTimeout(__privateGet(this, _x)), __privateSet(this, _x, setTimeout(async () => {
      const i3 = await this.recognizer.resize(this.model);
      s2.resolve(i3);
    }, __privateGet(this, _m2).triggers.resizeTriggerDelay))) : s2.resolve(this.model), __privateSet(this, _y2, await s2.promise), this.logger.debug("resize", { model: this.model }), this.event.emitExported(this.model.exports);
  }
  async undo() {
    this.logger.info("undo"), __privateSet(this, _y2, this.history.undo()), this.renderer.drawModel(__privateGet(this, _y2)), __privateSet(this, _y2, await this.recognizer.export(__privateGet(this, _y2))), this.history.updateStack(__privateGet(this, _y2)), this.event.emitExported(__privateGet(this, _y2).exports), this.logger.debug("undo", __privateGet(this, _y2));
  }
  async redo() {
    this.logger.info("redo"), __privateSet(this, _y2, this.history.redo()), this.renderer.drawModel(__privateGet(this, _y2)), __privateSet(this, _y2, await this.recognizer.export(__privateGet(this, _y2))), this.history.updateStack(__privateGet(this, _y2)), this.event.emitExported(__privateGet(this, _y2).exports), this.logger.debug("redo", __privateGet(this, _y2));
  }
  async clear() {
    this.logger.info("clear"), this.model.clear(), this.history.push(this.model), this.renderer.drawModel(this.model), this.event.emitExported(this.model.exports), this.event.emitCleared(), this.logger.debug("clear", this.model);
  }
  async destroy() {
    return this.logger.info("destroy"), this.event.removeAllListeners(), this.grabber.detach(), this.layers.destroy(), this.renderer.destroy(), Promise.resolve();
  }
};
_m2 = new WeakMap();
_y2 = new WeakMap();
_x = new WeakMap();
_S = new WeakMap();
_d3 = new WeakMap();
var _w, _v, _k, _E, _I, _C, _M, _T, _L, _P, _R, _D, _t34, _InteractiveInkSSRSmartGuide_instances, A_fn, z_fn, G_fn, B_fn, O_fn, N_fn, $_fn, j_fn, V_fn, U_fn, H_fn, _W, __fn, Y_fn, X_fn, _J, _q, Z_fn, K_fn, _Q, _ee, _te, _ie, _re, _oe, F_fn, se_fn;
var InteractiveInkSSRSmartGuide = class {
  constructor(i2) {
    __privateAdd(this, _InteractiveInkSSRSmartGuide_instances);
    __publicField(this, "uuid");
    __privateAdd(this, _w);
    __privateAdd(this, _v);
    __privateAdd(this, _k);
    __privateAdd(this, _E);
    __privateAdd(this, _I);
    __privateAdd(this, _C);
    __privateAdd(this, _M);
    __privateAdd(this, _T);
    __privateAdd(this, _L);
    __privateAdd(this, _P);
    __privateAdd(this, _R);
    __privateAdd(this, _D);
    __publicField(this, "editor");
    __publicField(this, "margin");
    __publicField(this, "jiix");
    __publicField(this, "lastWord");
    __publicField(this, "wordToChange");
    __privateAdd(this, _t34, LoggerManager.getLogger(d.SMARTGUIDE));
    __privateAdd(this, _W, (i2) => {
      var _a, _b2;
      __privateGet(this, _t34).info("showCandidates", { target: i2 });
      const r2 = parseInt(i2.id.replace("word-", "").replace(this.uuid, "")), s2 = (_a = this.jiix) == null ? void 0 : _a.words;
      this.wordToChange = s2[r2], this.wordToChange && (this.wordToChange.id = r2.toString(), __privateGet(this, _M).innerHTML = "", ((_b2 = this.wordToChange) == null ? void 0 : _b2.candidates) && (__privateGet(this, _M).style.display = "flex", this.wordToChange.candidates.forEach((i3, r3) => {
        var _a2;
        ((_a2 = this.wordToChange) == null ? void 0 : _a2.label) === i3 ? __privateGet(this, _M).innerHTML += `<span id="cdt-${r3}${this.uuid}" class="selected-word">${i3}</span>` : __privateGet(this, _M).innerHTML += `<span id="cdt-${r3}${this.uuid}">${i3}</span>`;
      }), i2.appendChild(__privateGet(this, _M))));
    });
    __privateAdd(this, _J, (i2) => {
      __privateGet(this, _t34).info("onClickEllipsis", { evt: i2 }), i2.preventDefault(), i2.stopPropagation(), __privateGet(this, _D) ? __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, X_fn).call(this) : __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, Y_fn).call(this), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, __fn).call(this);
    });
    __privateAdd(this, _q, (i2) => {
      __privateGet(this, _t34).info("onClickConvert", { evt: i2 }), i2.preventDefault(), i2.stopPropagation(), this.editor.convert(), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, X_fn).call(this);
    });
    __privateAdd(this, _Q, async (i2) => {
      __privateGet(this, _t34).info("onClickCopy", { evt: i2 }), i2.preventDefault(), i2.stopPropagation();
      try {
        __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, X_fn).call(this);
        let i3 = "Nothing to copy";
        if (__privateGet(this, _E).innerText) {
          i3 = `"${__privateGet(this, _E).innerText}" copied to clipboard`;
          const r2 = __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, Z_fn).call(this, __privateGet(this, _E).innerText);
          __privateGet(this, _k).appendChild(r2), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, K_fn).call(this, r2), document.execCommand("copy"), r2.remove();
        }
        this.editor.event.emitNotif({ message: i3, timeout: 1500 });
      } catch (i3) {
        __privateGet(this, _t34).error("onClickCopy", i3), this.editor.event.emitError(i3);
      }
    });
    __privateAdd(this, _ee, (i2) => {
      __privateGet(this, _t34).info("onClickDelete", { evt: i2 }), i2.preventDefault(), i2.stopPropagation(), this.editor.clear(), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, X_fn).call(this);
    });
    __privateAdd(this, _te, (i2) => {
      var _a, _b2, _c2, _d6, _e2;
      __privateGet(this, _t34).info("onClickCandidate", { evt: i2 }), i2.preventDefault(), i2.stopPropagation();
      const r2 = i2.target.innerText;
      ((_a = this.jiix) == null ? void 0 : _a.words) && r2 !== ((_b2 = this.wordToChange) == null ? void 0 : _b2.label) && ((_d6 = (_c2 = this.wordToChange) == null ? void 0 : _c2.candidates) == null ? void 0 : _d6.includes(r2)) && (this.jiix.words[parseInt((_e2 = this.wordToChange) == null ? void 0 : _e2.id)].label = r2, this.editor.import(new Blob([JSON.stringify(this.jiix)], { type: u.JIIX }), u.JIIX)), __privateGet(this, _M).style.display = "none";
    });
    __privateAdd(this, _ie, (i2) => {
      __privateGet(this, _t34).info("onClickPrompter", { evt: i2 }), i2.preventDefault(), i2.stopPropagation(), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, X_fn).call(this);
      const r2 = i2.target;
      r2.id !== __privateGet(this, _E).id ? __privateGet(this, _W).call(this, r2) : __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, __fn).call(this);
    });
    __privateAdd(this, _re, (i2) => {
      i2.preventDefault(), i2.stopPropagation();
    });
    __privateAdd(this, _oe, () => {
      __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, __fn).call(this), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, X_fn).call(this);
    });
    __privateGet(this, _t34).info("constructor"), this.uuid = createUUID(), this.editor = i2, this.margin = { bottom: 0, left: 0, right: 0, top: 0 }, __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, A_fn).call(this), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, z_fn).call(this), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, G_fn).call(this), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, B_fn).call(this), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, O_fn).call(this), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, N_fn).call(this), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, $_fn).call(this), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, j_fn).call(this), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, V_fn).call(this), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, U_fn).call(this), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, H_fn).call(this);
  }
  init(i2, r2) {
    __privateGet(this, _t34).info("init", { domElement: i2, margin: r2 });
    const s2 = document.createElement("style");
    s2.appendChild(document.createTextNode(".ms-editor .smartguide{background-color:#fff;box-shadow:2px 2px 12px #bdbdbd;cursor:default;font-size:16px;left:0;line-height:48px;padding-bottom:12px;padding-top:12px;position:absolute;top:0;width:100%;z-index:40}.ms-editor .smartguide .smartguide-wrapper{border-bottom:1px solid #959da6;display:flex}.ms-editor .smartguide .tag-icon{background-color:hsla(0,0%,100%,.9);border-left:1px solid #959da6;border-right:1px solid #959da6;border-top:1px solid #959da6;font-size:large;height:100%;line-height:48px;padding:0 18px;z-index:31}.ms-editor .smartguide .ellipsis,.ms-editor .smartguide .tag-icon{color:#959da6;font-weight:700;height:48px;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:48px}.ms-editor .smartguide .ellipsis{-webkit-tap-highlight-color:transparent;cursor:pointer;font-size:x-large;line-height:38px;padding:0 8px}.ms-editor .smartguide .ellipsis:active{background-color:#e0e0e0}.ms-editor .smartguide .prompter-container{-webkit-tap-highlight-color:transparent;color:#bfbfbf;display:block;height:48px;line-height:48px;overflow:hidden;text-align:left;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap;width:calc(100% - 96px)}.ms-editor .smartguide .prompter-container>div>span{cursor:pointer;display:inline-block}.ms-editor .smartguide .prompter-container .prompter-text{margin-left:12px}.ms-editor .smartguide .prompter-container .prompter-text .added-word{animation:word-added .1s linear,color-input 3s ease-in-out}.ms-editor .smartguide .prompter-container .prompter-text .modified-word{animation:word-modified .1s linear,color-input 3s ease-in-out}.ms-editor .smartguide .candidates{-webkit-tap-highlight-color:transparent;background-color:#f5f5f5;border-radius:3px;box-shadow:2px 2px 12px #bdbdbd,-2px 2px 12px #bdbdbd;color:#000;flex-direction:column;line-height:30px;position:absolute;text-align:center;z-index:100}.ms-editor .smartguide .candidates>span{cursor:pointer;padding:2px 20px}.ms-editor .smartguide .candidates>span:hover{background-color:#eee}.ms-editor .smartguide .candidates>span:active{background-color:#e0e0e0}.ms-editor .smartguide .candidates .selected-word{background-color:#e0e0e0;font-weight:700}.ms-editor .smartguide .more-menu{background-color:#f5f5f5;border-radius:3px;bottom:0;box-shadow:2px 2px 12px #bdbdbd;display:flex;flex-direction:column;line-height:30px;margin-right:12px;overflow:hidden;position:absolute;right:0;transform:translateY(100%);transition:max-height 1s ease-out,opacity 1s,visibility .5s linear;z-index:100}.ms-editor .smartguide .more-menu.open{max-height:500px;opacity:1;visibility:visible}.ms-editor .smartguide .more-menu.close{max-height:0;opacity:0;visibility:hidden}.ms-editor .smartguide .more-menu .options-label-button{-webkit-tap-highlight-color:transparent;background:transparent;border:none;box-sizing:border-box;color:#000;cursor:pointer;font-size:16px;height:40px;margin:0;outline:none;padding:0 24px}.ms-editor .smartguide .more-menu .options-label-button:hover{background-color:#eee;padding:4px}.ms-editor .smartguide .more-menu .options-label-button:active{background-color:#e0e0e0}@keyframes color-input{0%{color:#000}to{color:#bfbfbf}}@keyframes word-added{0%{transform:translate(5px)}to{transform:none}}@keyframes word-modified{0%{transform:translateY(5px)}to{transform:none}}")), i2.appendChild(s2), i2.appendChild(__privateGet(this, _w)), __privateGet(this, _w).appendChild(__privateGet(this, _v)), __privateGet(this, _v).appendChild(__privateGet(this, _C)), __privateGet(this, _k).appendChild(__privateGet(this, _E)), __privateGet(this, _v).appendChild(__privateGet(this, _k)), __privateGet(this, _v).appendChild(__privateGet(this, _I)), __privateGet(this, _T).appendChild(__privateGet(this, _L)), __privateGet(this, _T).appendChild(__privateGet(this, _P)), __privateGet(this, _T).appendChild(__privateGet(this, _R)), __privateGet(this, _T).classList.add("close"), __privateGet(this, _v).appendChild(__privateGet(this, _T)), __privateSet(this, _D, false), __privateGet(this, _M).style.display = "none", __privateGet(this, _v).appendChild(__privateGet(this, _M)), this.margin = r2, __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, F_fn).call(this), this.resize();
  }
  resize() {
    __privateGet(this, _t34).info("resize");
    const i2 = convertMillimeterToPixel(this.margin.left), r2 = convertMillimeterToPixel(this.margin.right);
    __privateGet(this, _v).style.marginLeft = `${i2}px`, __privateGet(this, _v).style.marginRight = `${r2}px`;
  }
  update(i2) {
    var _a, _b2;
    __privateGet(this, _t34).info("update", { exports: i2 }), this.jiix = i2;
    const createWordSpan = (i3, r2) => {
      const s2 = document.createElement("span");
      return s2.id = `word-${i3}${this.uuid}`, r2 ? s2.textContent = r2.label : s2.innerHTML = "&nbsp;", __privateGet(this, _t34).debug("update", { span: s2 }), s2;
    };
    (() => {
      var _a2;
      if (__privateGet(this, _t34).info("populatePrompter"), __privateGet(this, _E).innerHTML = "", (_a2 = this.jiix) == null ? void 0 : _a2.words) {
        const i3 = this.jiix.words, r2 = document.createDocumentFragment();
        i3.forEach((s2, n2) => {
          var _a3, _b3, _c2;
          if (" " === s2.label || s2.label.includes("\n")) r2.appendChild(createWordSpan(n2));
          else if (n2 !== i3.length - 1) r2.appendChild(createWordSpan(n2, s2));
          else {
            __privateGet(this, _E).appendChild(r2), this.lastWord && (this.lastWord = s2);
            const i4 = createWordSpan(n2, s2);
            ((_a3 = this.lastWord) == null ? void 0 : _a3.candidates) !== s2.candidates && ((_b3 = this.lastWord) == null ? void 0 : _b3.label) !== s2.label && (this.lastWord = s2), ((_c2 = this.wordToChange) == null ? void 0 : _c2.id) === n2.toString() ? (i4.classList.add("modified-word"), this.wordToChange = void 0) : i4.classList.add("added-word"), __privateGet(this, _E).appendChild(i4), __privateGet(this, _k).scrollLeft = i4.offsetLeft, __privateGet(this, _t34).debug("update => populatePrompter", { span: i4, lastWord: this.lastWord });
          }
        });
      }
    })(), ((_b2 = (_a = this.jiix) == null ? void 0 : _a.words) == null ? void 0 : _b2.length) ? __privateGet(this, _I).style.setProperty("pointer-events", "auto") : __privateGet(this, _I).style.setProperty("pointer-events", "none");
  }
  clear() {
    __privateGet(this, _t34).info("clear"), __privateGet(this, _E).innerHTML = "", __privateGet(this, _M).innerHTML = "";
  }
  destroy() {
    __privateGet(this, _t34).info("destroy"), __privateMethod(this, _InteractiveInkSSRSmartGuide_instances, se_fn).call(this), __privateGet(this, _w).remove();
  }
};
_w = new WeakMap();
_v = new WeakMap();
_k = new WeakMap();
_E = new WeakMap();
_I = new WeakMap();
_C = new WeakMap();
_M = new WeakMap();
_T = new WeakMap();
_L = new WeakMap();
_P = new WeakMap();
_R = new WeakMap();
_D = new WeakMap();
_t34 = new WeakMap();
_InteractiveInkSSRSmartGuide_instances = new WeakSet();
A_fn = function() {
  __privateSet(this, _w, document.createElement("div")), __privateGet(this, _w).id = `smartguide-${this.uuid}`, __privateGet(this, _w).classList.add("smartguide"), __privateGet(this, _w).addEventListener("pointerdown", (i2) => {
    i2.preventDefault(), i2.stopPropagation();
  });
};
z_fn = function() {
  __privateSet(this, _v, document.createElement("div")), __privateGet(this, _v).id = `smartguide-wrapper-${this.uuid}`, __privateGet(this, _v).classList.add("smartguide-wrapper");
};
G_fn = function() {
  __privateSet(this, _k, document.createElement("div")), __privateGet(this, _k).id = `prompter-container-${this.uuid}`, __privateGet(this, _k).classList.add("prompter-container");
};
B_fn = function() {
  __privateSet(this, _E, document.createElement("div")), __privateGet(this, _E).id = `prompter-text-${this.uuid}`, __privateGet(this, _E).classList.add("prompter-text"), __privateGet(this, _E).setAttribute("touch-action", "none");
};
O_fn = function() {
  __privateSet(this, _I, document.createElement("div")), __privateGet(this, _I).id = `ellipsis-${this.uuid}`, __privateGet(this, _I).classList.add("ellipsis"), __privateGet(this, _I).innerHTML = "...";
};
N_fn = function() {
  __privateSet(this, _C, document.createElement("div")), __privateGet(this, _C).id = `tag-icon-${this.uuid}`, __privateGet(this, _C).classList.add("tag-icon"), __privateGet(this, _C).innerHTML = "&#182;";
};
$_fn = function() {
  __privateSet(this, _M, document.createElement("div")), __privateGet(this, _M).id = `candidates-${this.uuid}`, __privateGet(this, _M).classList.add("candidates");
};
j_fn = function() {
  __privateSet(this, _T, document.createElement("div")), __privateGet(this, _T).id = `more-menu-${this.uuid}`, __privateGet(this, _T).classList.add("more-menu");
};
V_fn = function() {
  __privateSet(this, _L, document.createElement("button")), __privateGet(this, _L).id = `convert-${this.uuid}`, __privateGet(this, _L).classList.add("options-label-button"), __privateGet(this, _L).innerHTML = "Convert";
};
U_fn = function() {
  __privateSet(this, _P, document.createElement("button")), __privateGet(this, _P).id = `copy-${this.uuid}`, __privateGet(this, _P).classList.add("options-label-button"), __privateGet(this, _P).innerHTML = "Copy";
};
H_fn = function() {
  __privateSet(this, _R, document.createElement("button")), __privateGet(this, _R).id = `delete-${this.uuid}`, __privateGet(this, _R).classList.add("options-label-button"), __privateGet(this, _R).innerHTML = "Delete";
};
_W = new WeakMap();
__fn = function() {
  __privateGet(this, _M).style.display = "none";
};
Y_fn = function() {
  __privateGet(this, _T).classList.add("open"), __privateGet(this, _T).classList.remove("close"), __privateSet(this, _D, true);
};
X_fn = function() {
  __privateGet(this, _T).classList.add("close"), __privateGet(this, _T).classList.remove("open"), __privateSet(this, _D, false);
};
_J = new WeakMap();
_q = new WeakMap();
Z_fn = function(i2) {
  const r2 = "rtl" === document.documentElement.getAttribute("dir"), s2 = document.createElement("textarea");
  s2.style.fontSize = "12pt", s2.style.display = "absolute", s2.style[r2 ? "right" : "left"] = "-9999px";
  const n2 = window.pageYOffset || document.documentElement.scrollTop;
  return s2.style.top = `${n2}px`, s2.setAttribute("readonly", ""), s2.value = i2, s2;
};
K_fn = function(i2) {
  if (navigator.userAgent.match(/ipad|iphone/i)) {
    const r2 = document.createRange();
    r2.selectNodeContents(i2);
    const s2 = window.getSelection();
    s2 && (s2.removeAllRanges(), s2.addRange(r2), i2.setSelectionRange(0, 999999));
  } else i2.select();
};
_Q = new WeakMap();
_ee = new WeakMap();
_te = new WeakMap();
_ie = new WeakMap();
_re = new WeakMap();
_oe = new WeakMap();
F_fn = function() {
  __privateGet(this, _w).addEventListener("pointerdown", __privateGet(this, _re).bind(this)), __privateGet(this, _I).addEventListener("pointerdown", __privateGet(this, _J).bind(this)), __privateGet(this, _L).addEventListener("pointerdown", __privateGet(this, _q).bind(this)), __privateGet(this, _P).addEventListener("pointerdown", __privateGet(this, _Q).bind(this)), __privateGet(this, _R).addEventListener("pointerdown", __privateGet(this, _ee).bind(this)), __privateGet(this, _E).addEventListener("pointerdown", __privateGet(this, _ie).bind(this)), __privateGet(this, _M).addEventListener("pointerdown", __privateGet(this, _te).bind(this)), document.addEventListener("pointerdown", __privateGet(this, _oe).bind(this));
};
se_fn = function() {
  __privateGet(this, _w).addEventListener("pointerdown", __privateGet(this, _re)), __privateGet(this, _I).removeEventListener("pointerdown", __privateGet(this, _J)), __privateGet(this, _L).removeEventListener("pointerdown", __privateGet(this, _q)), __privateGet(this, _P).removeEventListener("pointerdown", __privateGet(this, _Q)), __privateGet(this, _R).removeEventListener("pointerdown", __privateGet(this, _ee)), __privateGet(this, _E).removeEventListener("pointerdown", __privateGet(this, _ie)), __privateGet(this, _M).removeEventListener("pointerdown", __privateGet(this, _te)), document.removeEventListener("pointerdown", __privateGet(this, _oe));
};
var Ae = { server: ue.server, recognition: ue.recognition, rendering: ye, smartGuide: { enable: true }, grabber: xe, triggers: Re, "undo-redo": Se, logger: h, penStyle: {}, theme: f };
var InteractiveInkSSREditorConfiguration = class {
  constructor(i2) {
    __publicField(this, "server");
    __publicField(this, "recognition");
    __publicField(this, "rendering");
    __publicField(this, "smartGuide");
    __publicField(this, "undo-redo");
    __publicField(this, "grabber");
    __publicField(this, "triggers");
    __publicField(this, "logger");
    __publicField(this, "penStyle");
    __publicField(this, "penStyleClasses");
    __publicField(this, "theme");
    const { server: r2, recognition: s2 } = new RecognizerWebSocketSSRConfiguration(i2);
    this.server = r2, this.recognition = s2, this.rendering = mergeDeep({}, Ae.rendering, i2 == null ? void 0 : i2.rendering), this.smartGuide = mergeDeep({}, Ae.smartGuide, i2 == null ? void 0 : i2.smartGuide), this["undo-redo"] = mergeDeep({}, Ae["undo-redo"], i2 == null ? void 0 : i2["undo-redo"]), this.grabber = mergeDeep({}, Ae.grabber, i2 == null ? void 0 : i2.grabber), this.triggers = mergeDeep({}, Ae.triggers, i2 == null ? void 0 : i2.triggers), this.logger = mergeDeep({}, Ae.logger, i2 == null ? void 0 : i2.logger), this.penStyle = mergeDeep({}, Ae.penStyle, i2 == null ? void 0 : i2.penStyle), this.penStyleClasses = (i2 == null ? void 0 : i2.penStyleClasses) || this.penStyleClasses, this.theme = mergeDeep({}, Ae.theme, i2 == null ? void 0 : i2.theme), "TEXT" !== this.recognition.type && (this.smartGuide.enable = false), this.smartGuide.enable && !this.recognition.text.mimeTypes.includes("application/vnd.myscript.jiix") && this.recognition.text.mimeTypes.push("application/vnd.myscript.jiix");
  }
};
var _m3, _y3, _x2, _d4;
var InteractiveInkSSREditor = class extends AbstractEditor {
  constructor(r2, s2) {
    var _a, _b2, _c2, _d6;
    super(r2, s2);
    __privateAdd(this, _m3);
    __privateAdd(this, _y3);
    __privateAdd(this, _x2);
    __publicField(this, "smartGuide");
    __publicField(this, "grabber");
    __publicField(this, "renderer");
    __publicField(this, "recognizer");
    __publicField(this, "history");
    __publicField(this, "styleManager");
    __privateAdd(this, _d4, i.Write);
    if (__privateSet(this, _m3, new InteractiveInkSSREditorConfiguration(s2 == null ? void 0 : s2.configuration)), this.styleManager = new StyleManager((_a = s2 == null ? void 0 : s2.configuration) == null ? void 0 : _a.penStyle, (_b2 = s2 == null ? void 0 : s2.configuration) == null ? void 0 : _b2.theme), (_c2 = s2 == null ? void 0 : s2.override) == null ? void 0 : _c2.grabber) {
      const i2 = s2.override.grabber;
      this.grabber = new i2(__privateGet(this, _m3).grabber);
    } else this.grabber = new PointerEventGrabber(__privateGet(this, _m3).grabber);
    if ((_d6 = s2 == null ? void 0 : s2.override) == null ? void 0 : _d6.recognizer) {
      const i2 = s2.override.recognizer;
      this.recognizer = new i2(__privateGet(this, _m3));
    } else this.recognizer = new RecognizerWebSocketSSR(__privateGet(this, _m3));
    this.renderer = new InteractiveInkSSRSVGRenderer(__privateGet(this, _m3).rendering), this.tool = i.Write, __privateSet(this, _y3, new Model()), this.history = new HistoryManager(__privateGet(this, _m3)["undo-redo"], this.event);
  }
  get initializationPromise() {
    return this.recognizer.initialized.promise;
  }
  get tool() {
    return __privateGet(this, _d4);
  }
  set tool(i2) {
    __privateSet(this, _d4, i2), this.setCursorStyle();
  }
  setCursorStyle() {
    if (this.tool === i.Erase) this.layers.root.classList.remove("draw"), this.layers.root.classList.add("erase");
    else this.layers.root.classList.add("draw"), this.layers.root.classList.remove("erase");
  }
  get model() {
    return __privateGet(this, _y3);
  }
  get configuration() {
    return __privateGet(this, _m3);
  }
  get currentPenStyle() {
    return this.styleManager.currentPenStyle;
  }
  get penStyle() {
    return this.styleManager.penStyle;
  }
  set penStyle(i2) {
    this.logger.info("setPenStyle", { penStyle: i2 }), this.styleManager.setPenStyle(i2), this.logger.debug("setPenStyle", this.styleManager.penStyle), this.recognizer.setPenStyle(this.styleManager.penStyle);
  }
  get penStyleClasses() {
    return this.styleManager.penStyleClasses;
  }
  set penStyleClasses(i2) {
    this.logger.info("setPenStyleClasses", { penClass: i2 }), this.styleManager.setPenStyleClasses(i2), this.logger.debug("setPenStyleClasses", this.styleManager.penStyleClasses), this.recognizer.setPenStyleClasses(this.styleManager.penStyleClasses);
  }
  get theme() {
    return this.styleManager.theme;
  }
  set theme(i2) {
    this.logger.info("setTheme", { theme: i2 }), this.styleManager.setTheme(i2), this.logger.debug("setTheme", this.styleManager.theme), this.recognizer.setTheme(this.styleManager.theme);
  }
  async syncStyle() {
    await Promise.all([this.recognizer.setPenStyle(this.styleManager.penStyle), this.recognizer.setPenStyleClasses(this.styleManager.penStyleClasses), this.recognizer.setTheme(this.styleManager.theme)]);
  }
  onExport(i2) {
    if (this.logger.debug("onExport", { exports: i2 }), this.smartGuide && (i2 == null ? void 0 : i2["application/vnd.myscript.jiix"])) {
      const r2 = i2["application/vnd.myscript.jiix"];
      this.smartGuide.update(r2);
    }
    this.model.mergeExport(i2), this.event.emitExported(i2);
  }
  onPointerDown(r2) {
    var _a;
    this.logger.info("onPointerDown", { tool: this.tool, info: r2 });
    const s2 = Object.assign({}, (_a = this.theme) == null ? void 0 : _a.ink, this.currentPenStyle);
    this.model.initCurrentStroke(r2.pointer, this.tool === i.Erase ? "eraser" : r2.pointerType, s2), this.drawCurrentStroke();
  }
  onPointerMove(i2) {
    this.logger.info("onPointerMove", { tool: this.tool, info: i2 }), this.model.appendToCurrentStroke(i2.pointer), this.drawCurrentStroke();
  }
  async onPointerUp(i2) {
    try {
      this.logger.info("onPointerUp", { tool: this.tool, info: i2 }), this.model.endCurrentStroke(i2.pointer), await this.synchronizeModelWithBackend();
    } catch (i3) {
      this.event.emitError(i3);
    }
  }
  onSVGPatch(i2) {
    this.logger.info("onSVGPatch", { evt: i2 }), this.renderer.updatesLayer(i2.layer, i2.updates);
  }
  initializeSmartGuide() {
    var _a;
    if ((_a = this.smartGuide) == null ? void 0 : _a.destroy(), this.logger.info("initializeSmartGuide", { smartGuide: this.configuration.smartGuide }), this.configuration.smartGuide.enable) {
      this.smartGuide = new InteractiveInkSSRSmartGuide(this);
      let i2 = O;
      switch (this.configuration.recognition.type) {
        case "TEXT":
          i2 = this.configuration.recognition.text.margin;
          break;
        case "MATH":
          i2 = this.configuration.recognition.math.margin;
      }
      this.smartGuide.init(this.layers.ui.root, i2);
    }
  }
  onContetChaned(i2) {
    this.history.context = i2, this.event.emitChanged(i2);
  }
  onError(i2) {
    this.layers.showMessageError(i2), this.event.emitError(i2);
  }
  async initialize() {
    try {
      this.logger.info("initialize"), this.layers.render(), this.layers.showLoader();
      const i2 = window.getComputedStyle(this.layers.root);
      this.model.width = Math.max(parseInt(i2.width.replace("px", "")), __privateGet(this, _m3).rendering.minWidth), this.model.height = Math.max(parseInt(i2.height.replace("px", "")), __privateGet(this, _m3).rendering.minHeight), this.history.push(this.model), this.renderer.init(this.layers.rendering), this.grabber.attach(this.layers.rendering), this.grabber.onPointerDown = this.onPointerDown.bind(this), this.grabber.onPointerMove = this.onPointerMove.bind(this), this.grabber.onPointerUp = this.onPointerUp.bind(this), this.initializeSmartGuide(), this.recognizer.configuration.server.version || (await this.loadInfo(this.configuration.server), this.recognizer.configuration.server.version = this.info.version), await this.recognizer.init(this.model.height, this.model.width), this.recognizer.event.addExportedListener(this.onExport.bind(this)), this.recognizer.event.addSVGPatchListener(this.onSVGPatch.bind(this)), this.recognizer.event.addContentChangedListener(this.onContetChaned.bind(this)), this.recognizer.event.addIdleListener(this.event.emitIdle.bind(this.event)), this.recognizer.event.addErrorListener(this.onError.bind(this)), await this.syncStyle();
    } catch (i2) {
      throw this.logger.error("initialize", i2), this.layers.showMessageError(i2), i2;
    } finally {
      this.logger.debug("initialize", "finally"), this.layers.hideLoader(), this.layers.updateState(true);
    }
  }
  drawCurrentStroke() {
    this.logger.debug("drawCurrentStroke", { stroke: this.model.currentSymbol });
    const i2 = this.model.currentSymbol;
    i2 && this.renderer.drawPendingStroke(i2);
  }
  async synchronizeModelWithBackend() {
    if (this.logger.info("synchronizeModelWithBackend"), "DEMAND" !== __privateGet(this, _m3).triggers.exportContent) {
      const i2 = this.model.extractUnsentStrokes();
      this.model.updatePositionSent(), this.history.push(this.model), this.renderer.clearErasingStrokes();
      const r2 = await this.recognizer.addStrokes(i2);
      this.model.mergeExport(r2), this.history.updateStack(this.model);
    }
    return this.logger.debug("synchronizeModelWithBackend", this.model), this.model;
  }
  async waitForIdle() {
    return this.recognizer.waitForIdle();
  }
  async export(i2) {
    this.logger.info("export", { mimeTypes: i2 });
    try {
      if ("DEMAND" !== __privateGet(this, _m3).triggers.exportContent) return await this.recognizer.export(this.model, i2);
      {
        const i3 = this.model.extractUnsentStrokes();
        this.history.push(this.model), this.history.stack.push(this.model.clone()), this.model.updatePositionSent();
        const r2 = await this.recognizer.addStrokes(i3);
        this.model.updatePositionReceived(), this.model.mergeExport(r2), this.logger.debug("export", this.model);
      }
    } catch (i3) {
      return this.logger.error("export", { error: i3 }), this.event.emitError(i3), Promise.reject(i3);
    }
    return this.model;
  }
  async convert(i2) {
    return this.logger.info("convert", { params: i2 }), this.history.push(this.model), this.history.stack.push(this.model.clone()), __privateSet(this, _y3, await this.recognizer.convert(this.model, i2 == null ? void 0 : i2.conversionState)), this.logger.debug("convert", this.model), this.history.push(this.model), this.event.emitConverted(this.model.converts), this.model;
  }
  async import(i2, r2) {
    let s2;
    return s2 = i2 instanceof Blob ? i2 : "string" == typeof i2 ? new Blob([i2]) : new Blob([JSON.stringify(i2)]), this.logger.info("import", { data: i2, mimeType: r2 }), this.history.stack.push(this.model.clone()), __privateSet(this, _y3, await this.recognizer.import(this.model, s2, r2)), this.history.push(this.model), this.event.emitImported(this.model.exports), this.model;
  }
  async importPointEvents(i2) {
    this.logger.info("importPointEvents", { strokes: i2 });
    const r2 = [], s2 = i2.map((i3, s3) => {
      var _a, _b2;
      const n3 = new Stroke(i3.style || b, i3.pointerType);
      i3.id && (n3.id = i3.id), i3.pointerType && (n3.pointerType = i3.pointerType), ((_a = i3.pointers) == null ? void 0 : _a.length) || r2.push(`stroke ${s3 + 1} has not pointers`);
      let a2 = true;
      return (_b2 = i3.pointers) == null ? void 0 : _b2.forEach((i4, l2) => {
        if (a2 = true, !i4) return void r2.push(`stroke ${s3 + 1} has no pointer at ${l2}`);
        const d2 = { p: i4.p || 1, t: i4.t || l2, x: 0, y: 0 };
        null == (i4 == null ? void 0 : i4.x) || null == (i4 == null ? void 0 : i4.x) ? (r2.push(`stroke ${s3 + 1} has no x at pointer at ${l2}`), a2 = false) : d2.x = i4.x, null == (i4 == null ? void 0 : i4.y) || null == (i4 == null ? void 0 : i4.y) ? (r2.push(`stroke ${s3 + 1} has no y at pointer at ${l2}`), a2 = false) : d2.y = i4.y, a2 && n3.pointers.push(d2);
      }), n3;
    });
    r2.length && this.event.emitError(new Error(r2.join("\n"))), s2.map((i3) => this.model.addStroke(i3));
    const n2 = await this.recognizer.importPointEvents(s2);
    return this.model.mergeExport(n2), this.event.emitImported(this.model.exports), this.logger.debug("importPointEvents", this.model), this.model;
  }
  async resize({ height: i2, width: r2 } = {}) {
    var _a;
    this.logger.info("resize", { height: i2, width: r2 });
    const s2 = new DeferredPromise(), n2 = window.getComputedStyle(this.layers.root);
    this.model.height = i2 || Math.max(parseInt(n2.height.replace("px", "")), this.configuration.rendering.minHeight), this.model.width = r2 || Math.max(parseInt(n2.width.replace("px", "")), this.configuration.rendering.minWidth);
    const a2 = this.model.clone();
    this.renderer.resize(a2), clearTimeout(__privateGet(this, _x2)), __privateSet(this, _x2, setTimeout(async () => {
      try {
        const i3 = await this.recognizer.resize(a2);
        s2.resolve(i3);
      } catch (n3) {
        this.logger.error("resize", { height: i2, width: r2, error: n3 }), s2.reject(n3);
      }
    }, __privateGet(this, _m3).triggers.resizeTriggerDelay)), __privateSet(this, _y3, await s2.promise), (_a = this.smartGuide) == null ? void 0 : _a.resize(), this.event.emitExported(this.model.exports), this.logger.debug("resize", this.model);
  }
  async undo() {
    if (this.logger.info("undo"), this.history.context.canUndo) return __privateSet(this, _y3, this.history.undo()), this.recognizer.undo(this.model);
    throw new Error("Undo not allowed");
  }
  async redo() {
    if (this.logger.info("redo"), this.history.context.canRedo) return __privateSet(this, _y3, this.history.redo()), this.logger.debug("undo", __privateGet(this, _y3)), this.recognizer.redo(this.model);
    throw new Error("Redo not allowed");
  }
  async clear() {
    this.logger.info("clear"), this.model.clear(), this.history.push(this.model), await this.recognizer.clear(this.model), this.event.emitCleared();
  }
  async destroy() {
    var _a;
    return this.logger.info("destroy"), this.event.removeAllListeners(), this.grabber.detach(), this.layers.destroy(), this.renderer.destroy(), this.recognizer.destroy(), (_a = this.smartGuide) == null ? void 0 : _a.destroy(), Promise.resolve();
  }
};
_m3 = new WeakMap();
_y3 = new WeakMap();
_x2 = new WeakMap();
_d4 = new WeakMap();
var ze = { server: re.server, recognition: re.recognition, renderer: ye, grabber: xe, triggers: Re, "undo-redo": Se, logger: h, penStyle: y };
var InkEditorConfiguration = class {
  constructor(i2) {
    __publicField(this, "server");
    __publicField(this, "recognition");
    __publicField(this, "renderer");
    __publicField(this, "undo-redo");
    __publicField(this, "grabber");
    __publicField(this, "triggers");
    __publicField(this, "logger");
    __publicField(this, "penStyle");
    const { server: r2, recognition: s2 } = new RecognizerHTTPV2Configuration(i2);
    this.server = r2, this.recognition = s2, this.renderer = mergeDeep({}, ze.renderer, i2 == null ? void 0 : i2.renderer), this.recognition.text.guides.enable = this.renderer.guides.enable, this.renderer.guides.enable && (this.recognition.text.guides["line-gap-mm"] = convertPixelToMillimeter(this.renderer.guides.gap)), this.grabber = mergeDeep({}, ze.grabber, i2 == null ? void 0 : i2.grabber), this["undo-redo"] = mergeDeep({}, ze["undo-redo"], i2 == null ? void 0 : i2["undo-redo"]), this.triggers = mergeDeep({}, ze.triggers, i2 == null ? void 0 : i2.triggers), this.logger = mergeDeep({}, ze.logger, i2 == null ? void 0 : i2.logger), this.penStyle = mergeDeep({}, ze.penStyle, i2 == null ? void 0 : i2.penStyle);
  }
};
var _m4, _y4, _S2, _r3, _d5;
var InkEditor = class extends AbstractEditor {
  constructor(r2, s2) {
    var _a, _b2;
    super(r2, s2);
    __privateAdd(this, _m4);
    __privateAdd(this, _y4);
    __privateAdd(this, _S2);
    __privateAdd(this, _r3);
    __publicField(this, "grabber");
    __publicField(this, "renderer");
    __publicField(this, "recognizer");
    __publicField(this, "history");
    __privateAdd(this, _d5, i.Write);
    if (__privateSet(this, _m4, new InkEditorConfiguration(s2 == null ? void 0 : s2.configuration)), __privateSet(this, _r3, Object.assign({}, __privateGet(this, _m4).penStyle)), (_a = s2 == null ? void 0 : s2.override) == null ? void 0 : _a.grabber) {
      const i2 = s2.override.grabber;
      this.grabber = new i2(__privateGet(this, _m4).grabber);
    } else this.grabber = new PointerEventGrabber(__privateGet(this, _m4).grabber);
    if (this.grabber.onPointerDown = this.onPointerDown.bind(this), this.grabber.onPointerMove = this.onPointerMove.bind(this), this.grabber.onPointerUp = this.onPointerUp.bind(this), (_b2 = s2 == null ? void 0 : s2.override) == null ? void 0 : _b2.recognizer) {
      const i2 = s2.override.recognizer;
      this.recognizer = new i2(__privateGet(this, _m4));
    } else this.recognizer = new RecognizerHTTPV2(__privateGet(this, _m4));
    this.renderer = new CanvasRenderer(__privateGet(this, _m4).renderer), this.tool = i.Write, __privateSet(this, _y4, new Model()), this.history = new HistoryManager(__privateGet(this, _m4)["undo-redo"], this.event);
  }
  onPointerDown(r2) {
    switch (this.logger.info("onPointerDown", { tool: this.tool, info: r2 }), this.tool) {
      case i.Erase:
        this.model.removeStrokesFromPoint(r2.pointer).length > 0 && this.renderer.drawModel(this.model);
        break;
      case i.Write:
        this.model.initCurrentStroke(r2.pointer, r2.pointerType, this.penStyle), this.drawCurrentStroke();
        break;
      default:
        this.logger.warn("#onPointerDown", `onPointerDown tool unknow: "${this.tool}"`);
    }
  }
  onPointerMove(r2) {
    switch (this.logger.info("onPointerMove", { tool: this.tool, info: r2 }), this.tool) {
      case i.Erase:
        this.model.removeStrokesFromPoint(r2.pointer).length > 0 && this.renderer.drawModel(this.model);
        break;
      case i.Write:
        this.model.appendToCurrentStroke(r2.pointer), this.drawCurrentStroke();
        break;
      default:
        this.logger.warn("#onPointerMove", `onPointerMove tool unknow: "${this.tool}"`);
    }
  }
  async onPointerUp(r2) {
    var _a;
    switch (this.logger.info("onPointerUp", { tool: this.tool, info: r2 }), this.tool) {
      case i.Erase:
        this.model.removeStrokesFromPoint(r2.pointer), ((_a = this.history.stack.at(-1)) == null ? void 0 : _a.modificationDate) !== this.model.modificationDate && await this.updateModelRendering();
        break;
      case i.Write:
        this.model.endCurrentStroke(r2.pointer), await this.updateModelRendering();
        break;
      default:
        this.logger.warn("#onPointerUp", `onPointerUp tool unknow: "${this.tool}"`);
    }
  }
  get penStyle() {
    return __privateGet(this, _r3);
  }
  set penStyle(i2) {
    this.logger.info("set penStyle", { penStyle: i2 }), __privateSet(this, _r3, Object.assign({}, __privateGet(this, _r3), i2));
  }
  get initializationPromise() {
    return Promise.resolve();
  }
  get tool() {
    return __privateGet(this, _d5);
  }
  set tool(i2) {
    __privateSet(this, _d5, i2), this.setCursorStyle();
  }
  setCursorStyle() {
    if (this.tool === i.Erase) this.layers.root.classList.remove("draw"), this.layers.root.classList.add("erase");
    else this.layers.root.classList.add("draw"), this.layers.root.classList.remove("erase");
  }
  get model() {
    return __privateGet(this, _y4);
  }
  get configuration() {
    return __privateGet(this, _m4);
  }
  async initialize() {
    try {
      this.logger.info("initialize"), this.layers.render(), this.layers.showLoader();
      const i2 = window.getComputedStyle(this.layers.root);
      this.model.width = Math.max(parseInt(i2.width.replace("px", "")), __privateGet(this, _m4).renderer.minWidth), this.model.height = Math.max(parseInt(i2.height.replace("px", "")), __privateGet(this, _m4).renderer.minHeight), this.history.push(this.model), this.layers.rendering.classList.add(this.configuration.recognition.type.toLowerCase().replace(" ", "-")), this.renderer.init(this.layers.rendering, __privateGet(this, _m4).renderer.guides.enable ? { x: __privateGet(this, _m4).renderer.guides.gap, y: __privateGet(this, _m4).renderer.guides.gap } : void 0), this.grabber.attach(this.layers.rendering);
    } catch (i2) {
      throw this.logger.error("initialize", i2), this.layers.showMessageError(i2), i2;
    } finally {
      this.logger.debug("initialize", "finally"), this.layers.hideLoader(), this.layers.updateState(true);
    }
  }
  drawCurrentStroke() {
    this.logger.debug("drawCurrentStroke", { stroke: this.model.currentSymbol }), this.renderer.drawPendingStroke(this.model.currentSymbol);
  }
  async updateModelRendering() {
    this.logger.info("updateModelRendering"), this.renderer.drawModel(this.model);
    const i2 = new DeferredPromise();
    if (this.history.push(this.model), "DEMAND" !== __privateGet(this, _m4).triggers.exportContent) {
      clearTimeout(__privateGet(this, _S2));
      const r2 = this.model.clone();
      __privateSet(this, _S2, setTimeout(async () => {
        try {
          r2.mergeExport(await this.recognizer.send(r2.symbols)), this.history.updateStack(r2), this.model.modificationDate === r2.modificationDate && (this.model.exports = r2.exports), i2.resolve(this.model);
        } catch (r3) {
          this.logger.error("updateModelRendering", { error: r3 }), this.layers.showMessageError(r3), this.event.emitError(r3), i2.reject(r3);
        }
      }, "QUIET_PERIOD" === __privateGet(this, _m4).triggers.exportContent ? __privateGet(this, _m4).triggers.exportContentDelay : 0));
    } else i2.resolve(this.model);
    return await i2.promise, this.event.emitExported(this.model.exports), this.logger.debug("updateModelRendering", this.model.exports), i2.promise;
  }
  async importPointEvents(i2) {
    try {
      convertPartialStrokesToStrokes(i2).forEach((i3) => {
        this.model.addStroke(i3);
      });
      const r2 = await this.updateModelRendering();
      return Object.assign(__privateGet(this, _y4), r2), this.event.emitImported(this.model.exports), this.model;
    } catch (i3) {
      throw this.layers.showMessageError(i3), this.event.emitError(i3), i3;
    }
  }
  async resize({ height: i2, width: r2 } = {}) {
    this.logger.info("resize", { height: i2, width: r2 });
    const s2 = window.getComputedStyle(this.layers.root);
    this.model.height = i2 || Math.max(parseInt(s2.height.replace("px", "")), this.configuration.renderer.minHeight), this.model.width = r2 || Math.max(parseInt(s2.width.replace("px", "")), this.configuration.renderer.minWidth), this.renderer.resize(this.model), this.logger.debug("resize", { model: this.model }), this.event.emitExported(this.model.exports);
  }
  async undo() {
    this.logger.info("undo"), __privateSet(this, _y4, this.history.undo()), this.renderer.drawModel(__privateGet(this, _y4)), this.history.updateStack(__privateGet(this, _y4)), this.event.emitExported(__privateGet(this, _y4).exports), this.logger.debug("undo", __privateGet(this, _y4));
  }
  async redo() {
    this.logger.info("redo"), __privateSet(this, _y4, this.history.redo()), this.renderer.drawModel(__privateGet(this, _y4)), this.history.updateStack(__privateGet(this, _y4)), this.event.emitExported(__privateGet(this, _y4).exports), this.logger.debug("redo", __privateGet(this, _y4));
  }
  async clear() {
    this.logger.info("clear"), this.model.clear(), this.history.push(this.model), this.renderer.drawModel(this.model), this.event.emitExported(this.model.exports), this.event.emitCleared(), this.logger.debug("clear", this.model);
  }
  async destroy() {
    return this.logger.info("destroy"), this.event.removeAllListeners(), this.grabber.detach(), this.layers.destroy(), this.renderer.destroy(), Promise.resolve();
  }
};
_m4 = new WeakMap();
_y4 = new WeakMap();
_S2 = new WeakMap();
_r3 = new WeakMap();
_d5 = new WeakMap();
var _Editor = class _Editor {
  static async load(i2, r2, s2) {
    if (_Editor.logger.info("load", { type: r2, options: s2 }), !s2) throw new Error("Param 'options' missing");
    switch (_Editor.instance && await _Editor.instance.destroy(), r2) {
      case "INTERACTIVEINK":
        _Editor.instance = new InteractiveInkEditor(i2, s2);
        break;
      case "INKV1":
        _Editor.instance = new InkEditorDeprecated(i2, s2);
        break;
      case "INKV2":
        _Editor.instance = new InkEditor(i2, s2);
        break;
      default:
        _Editor.instance = new InteractiveInkSSREditor(i2, s2);
    }
    return await _Editor.instance.initialize(), _Editor.instance;
  }
  static getInstance() {
    return _Editor.instance;
  }
};
__publicField(_Editor, "logger", LoggerManager.getLogger(d.EDITOR));
__publicField(_Editor, "instance");
var Editor = _Editor;
export {
  AbstractEditor,
  Box,
  CanvasRenderer,
  CanvasRendererShape,
  CanvasRendererStroke,
  CanvasRendererText,
  k as DecoratorKind,
  ee as DefaulRecognitionHTTPV1ConfigurationConfiguration,
  X as DefaultConvertionConfiguration,
  U as DefaultDebugConfiguration,
  z as DefaultDiagramConfiguration,
  A as DefaultDiagramConvertConfiguration,
  Re as DefaultEditorTriggerConfiguration,
  D as DefaultEraserConfiguration,
  B as DefaultExportConfiguration,
  Ie as DefaultGestureConfiguration,
  xe as DefaultGrabberConfiguration,
  me as DefaultGuidesConfiguration,
  Se as DefaultHistoryConfiguration,
  be as DefaultIIRendererConfiguration,
  ze as DefaultInkEditorConfiguration,
  De as DefaultInkEditorDeprecatedConfiguration,
  Pe as DefaultInteractiveInkEditorConfiguration,
  Ae as DefaultInteractiveInkSSREditorConfiguration,
  G as DefaultJiixConfiguration,
  fe as DefaultListenerConfiguration,
  h as DefaultLoggerConfiguration,
  O as DefaultMarginConfiguration,
  j as DefaultMathConfiguration,
  $ as DefaultMathUndoRedoConfiguration,
  Te as DefaultMenuConfiguration,
  b as DefaultPenStyle,
  V as DefaultRawContentConfiguration,
  H as DefaultRecognitionRendererConfiguration,
  de as DefaultRecognitionWebSocketConfiguration,
  te as DefaultRecognizerHTTPV1Configuration,
  re as DefaultRecognizerHTTPV2Configuration,
  ie as DefaultRecognizerHTTPV2RecognitionConfiguration,
  he as DefaultRecognizerWebSocketConfiguration,
  ue as DefaultRecognizerWebSocketSSRConfiguration,
  ce as DefaultRecognizerWebSocketSSRRecognitionConfiguration,
  ye as DefaultRendererConfiguration,
  P as DefaultServerHTTPConfiguration,
  R as DefaultServerWebsocketConfiguration,
  q as DefaultShapeBeautificationConfiguration,
  Z as DefaultShapeConfiguration,
  J as DefaultShapeConvertConfiguration,
  Le as DefaultSnapConfiguration,
  N as DefaultSolverConfiguration,
  y as DefaultStyle,
  Y as DefaultTexConfigurationV2,
  W as DefaultTextConfiguration,
  F as DefaultTextGuidesConfiguration,
  _ as DefaultTextGuidesConfigurationV2,
  f as DefaultTheme,
  DeferredPromise,
  C as EdgeDecoration,
  I as EdgeKind,
  Editor,
  EditorEvent,
  c as EditorEventName,
  EditorLayer,
  i as EditorTool,
  r as EditorWriteTool,
  u as ExportType,
  HistoryManager,
  IIConversionManager,
  IIDebugSVGManager,
  IIDecorator,
  IIEdgeArc,
  IIEdgeLine,
  IIEdgePolyLine,
  IIEraseManager,
  IIEraser,
  IIGestureManager,
  IIHistoryManager,
  IIMenu,
  IIMenuAction,
  IIMenuContext,
  IIMenuManager,
  IIMenuStyle,
  IIMenuSub,
  IIMenuTool,
  IIModel,
  IIMoveManager,
  IIRecognizedArc,
  IIRecognizedBase,
  IIRecognizedCircle,
  IIRecognizedEllipse,
  IIRecognizedLine,
  IIRecognizedPolyLine,
  IIRecognizedPolygon,
  IIRecognizedText,
  IIResizeManager,
  IIRotationManager,
  IISVGRenderer,
  pe as IISVGRendererConst,
  IISVGRendererDecoratorUtil,
  IISVGRendererEdgeUtil,
  IISVGRendererEraserUtil,
  IISVGRendererGroupUtil,
  IISVGRendererRecognizedUtil,
  IISVGRendererShapeUtil,
  IISVGRendererStrokeUtil,
  IISVGRendererTextUtil,
  IISelectionManager,
  IIShapeCircle,
  IIShapeEllipse,
  IIShapePolygon,
  IISnapManager,
  IIStroke,
  IISymbolBase,
  IISymbolGroup,
  IIText,
  IITextManager,
  IITranslateManager,
  IIWriteManager,
  InkEditor,
  InkEditorConfiguration,
  InkEditorDeprecated,
  InkEditorDeprecatedConfiguration,
  Ee as InsertAction,
  InteractiveInkEditor,
  InteractiveInkEditorConfiguration,
  InteractiveInkSSREditor,
  InteractiveInkSSREditorConfiguration,
  InteractiveInkSSRSVGRenderer,
  InteractiveInkSSRSmartGuide,
  p as JIIXELementType,
  m as JIIXEdgeKind,
  g as JIIXNodeKind,
  Logger,
  d as LoggerCategory,
  l as LoggerLevel,
  LoggerManager,
  MatrixTransform,
  Model,
  OIEdgeBase,
  OIShapeBase,
  PointerEventGrabber,
  T as RecognizedKind,
  Q as RecognizerError,
  RecognizerEvent,
  K as RecognizerEventName,
  RecognizerHTTPV1,
  RecognizerHTTPV1Configuration,
  RecognizerHTTPV2,
  RecognizerHTTPV2Configuration,
  RecognizerWebSocket,
  RecognizerWebSocketConfiguration,
  RecognizerWebSocketSSR,
  RecognizerWebSocketSSRConfiguration,
  n as ResizeDirection,
  a as SELECTION_MARGIN,
  SVGBuilder,
  SVGStroker,
  M as ShapeKind,
  SnapConfiguration,
  ke as StrikeThroughAction,
  Stroke,
  v as StyleHelper,
  StyleManager,
  ve as SurroundAction,
  s as SvgElementRole,
  E as SymbolType,
  oe as TRecognizerWebSocketMessageType,
  computeAngleAxeRadian,
  computeAngleRadian,
  computeAverage,
  computeDistance,
  computeDistanceBetweenPointAndSegment,
  computeHmac,
  computeLinksPointers,
  computeMiddlePointer,
  computeNearestPointOnSegment,
  computePointOnEllipse,
  computeRotatedPoint,
  convertBoundingBoxMillimeterToPixel,
  convertDegreeToRadian,
  convertMillimeterToPixel,
  convertPartialStrokesToOIStrokes,
  convertPartialStrokesToStrokes,
  convertPixelToMillimeter,
  convertRadianToDegree,
  createPointsOnSegment,
  createUUID,
  findIntersectBetweenSegmentAndCircle,
  findIntersectionBetween2Segment,
  getApiInfos,
  getAvailableFontList,
  getAvailableLanguageList,
  getClosestPoint,
  getClosestPoints,
  getInitialHistoryContext,
  isBetween,
  isDeepEqual,
  isPointInsideBox,
  isPointInsidePolygon,
  isValidNumber,
  isValidPoint,
  isVersionSuperiorOrEqual,
  mergeDeep,
  scalaire
};
//# sourceMappingURL=iink-ts.js.map
